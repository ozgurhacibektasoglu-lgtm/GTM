<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Score Entry</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      .scores-container { max-width: 1600px; margin: 24px auto; padding: 16px; }
      .round-selector { background: #fff; border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .round-selector label { display: block; font-weight: 600; margin-bottom: 8px; }
      .round-selector select { padding: 10px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 15px; min-width: 200px; }
      .scores-grid { display: grid; grid-template-columns: 1fr 400px; gap: 20px; }
      .scorecard-panel { background: #fff; border-radius: 12px; padding: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .players-panel { background: #fff; border-radius: 12px; padding: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .player-info { background: #f8fafc; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
      .player-info h3 { margin: 0 0 8px 0; color: #1e293b; font-size: 18px; }
      .player-info-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; font-size: 13px; }
      .info-item { display: flex; flex-direction: column; }
      .info-label { color: #64748b; font-weight: 600; margin-bottom: 2px; }
      .info-value { color: #1e293b; font-weight: 500; }
      .search-box { margin-bottom: 12px; }
      .search-box input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 14px; }
      .table-wrapper { overflow: auto; max-height: calc(100vh - 240px); border-radius: 8px; }
      .scorecard-table { width: 100%; border-collapse: collapse; font-size: 13px; }
      .scorecard-table th { background: #1e293b; color: white; padding: 8px 4px; text-align: center; font-size: 12px; font-weight: 600; min-width: 45px; }
      .scorecard-table td { padding: 6px 4px; text-align: center; border: 1px solid #e5e7eb; font-size: 13px; }
      .scorecard-table td:first-child { text-align: left; font-weight: 600; background: #f8fafc; min-width: 70px; }
      .scorecard-table .subtotal-cell { background: #f1f5f9; font-weight: 600; }
      .scorecard-table .total-cell { background: #dbeafe; font-weight: 700; }
      .score-input { width: 40px; padding: 4px; border-radius: 4px; border: 1px solid #e6e9ef; text-align: center; font-size: 13px; }
      .score-input:focus { outline: none; border-color: #3b82f6; background: #eff6ff; }
      .score-input.has-value { background: #dcfce7; border-color: #86efac; }
      .score-input:disabled { background: #f1f5f9; cursor: not-allowed; opacity: 0.6; }
      /* Score type styling */
      .score-input.score-par { background: white; color: black; border-color: #94a3b8; }
      .score-input.score-birdie { background: #dc2626; color: white; border-color: #991b1b; font-weight: 600; }
      .score-input.score-eagle { background: #fbbf24; color: black; border-color: #d97706; font-weight: 600; }
      .score-input.score-bogey { background: black; color: white; border-color: #1e293b; font-weight: 600; }
      .score-input.score-double-bogey { background: #2563eb; color: white; border-color: #1e40af; font-weight: 600; }
      .score-input.score-zero { background: #9ca3af; color: black; border-color: #6b7280; font-weight: 600; }
      .status-select { padding: 4px 8px; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 13px; background: white; cursor: pointer; }
      .status-select:focus { outline: none; border-color: #3b82f6; }
      .status-warning { background: #fef3c7; border: 1px solid #fbbf24; color: #92400e; padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 13px; text-align: center; font-weight: 500; }
      .status-warning { background: #fef3c7; border-color: #fbbf24; color: #92400e; padding: 8px 12px; border-radius: 6px; margin-top: 8px; font-size: 13px; text-align: center; font-weight: 500; }
      .scorecard-table input[type="number"]::-webkit-outer-spin-button,
      .scorecard-table input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; appearance: none; margin: 0; }
      .scorecard-table input[type="number"] { -moz-appearance: textfield; appearance: textfield; }
      .players-table { width: 100%; border-collapse: collapse; }
      .players-table th { position: sticky; top: 0; background: #f8fafc; padding: 10px 8px; border-bottom: 2px solid #e6e9ef; font-weight: 600; text-align: left; font-size: 13px; }
      .players-table td { padding: 10px 8px; border-bottom: 1px solid #f1f5f9; font-size: 14px; }
      .players-table tr { cursor: pointer; }
      .players-table tr:hover { background: #f0f9ff; }
      .players-table tr.selected { background: #dbeafe; font-weight: 600; }
      .players-table tr.completed { background: #d1fae5; }
      .players-table tr.completed:hover { background: #a7f3d0; }
      .players-table tr.completed.selected { background: #86efac; }
      .player-total-score { color: #059669; font-weight: 600; margin-left: 8px; font-size: 12px; }
      .empty-state { text-align: center; padding: 40px; color: #94a3b8; }
      .empty-state-icon { font-size: 48px; margin-bottom: 12px; }
      .btn-back { background: white; border: 1px solid #e6e9ef; padding: 10px 14px; border-radius: 8px; cursor: pointer; font-size: 14px; color: #333; text-decoration: none; display: inline-block; }
      .btn-save-scores { position: fixed; bottom: 20px; right: 20px; background: #28a745; color: white; border: 0; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; box-shadow: 0 4px 12px rgba(40,167,69,0.3); transition: all 0.2s; z-index: 100; }
      .btn-save-scores:hover { background: #218838; transform: translateY(-2px); box-shadow: 0 6px 16px rgba(40,167,69,0.4); }
      .status-text { font-size: 13px; color: #64748b; margin-bottom: 8px; }
      .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 1000; }
      .modal-overlay.active { display: flex; }
      .modal-box { background: white; border-radius: 12px; padding: 32px; min-width: 400px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
      .modal-box h3 { margin: 0 0 20px 0; font-size: 20px; color: #1e293b; text-align: center; }
      .modal-box p { margin: 0 0 24px 0; color: #64748b; text-align: center; font-size: 15px; }
      .modal-buttons { display: flex; gap: 12px; }
      .modal-buttons button { flex: 1; padding: 12px 20px; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
      .modal-btn-primary { background: #3b82f6; color: white; border: 0; }
      .modal-btn-primary:hover { background: #2563eb; }
      .modal-btn-secondary { background: #f1f5f9; color: #1e293b; border: 1px solid #e2e8f0; }
      .modal-btn-secondary:hover { background: #e2e8f0; }
      .modal-input { width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; text-align: center; margin-bottom: 20px; }
      .modal-input:focus { outline: none; border-color: #3b82f6; }
      .player-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); max-height: 300px; overflow-y: auto; z-index: 1000; margin-top: 4px; }
      .player-dropdown-item { padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f1f5f9; display: flex; justify-content: space-between; align-items: center; }
      .player-dropdown-item:last-child { border-bottom: none; }
      .player-dropdown-item:hover { background: #f0f9ff; }
      .player-dropdown-item.highlighted { background: #dbeafe; }
      .player-dropdown-item .player-name { font-weight: 500; color: #1e293b; }
      .player-dropdown-item .player-details { font-size: 12px; color: #64748b; }
    </style>
  </head>
  <body>
    <main class="scores-container">
      <header style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
        <div>
          <h1>Score Entry - By Flight</h1>
          <p class="lead" id="tournament-name">Enter scores for entire flights at once.</p>
        </div>
        <a href="index.html" class="btn-back">Back to Tournaments</a>
      </header>

      <section class="round-selector">
        <label for="round-select">Select Round:</label>
        <select id="round-select">
          <!-- Populated dynamically -->
        </select>
      </section>

      <section class="scores-grid">
        <!-- Left Panel: Scorecard -->
        <div class="scorecard-panel">
          <div id="player-info" class="player-info" style="display: none;">
            <h3 id="player-name">-</h3>
            <div class="player-info-grid">
              <div class="info-item">
                <span class="info-label">Reg No</span>
                <span class="info-value" id="player-reg">-</span>
              </div>
              <div class="info-item">
                <span class="info-label">Handicap</span>
                <span class="info-value" id="player-hcp">-</span>
              </div>
              <div class="info-item">
                <span class="info-label">Playing HCP</span>
                <span class="info-value" id="player-phcp">-</span>
              </div>
              <div class="info-item">
                <span class="info-label">Status</span>
                <select id="player-status" class="status-select">
                  <option value="">Playing</option>
                  <option value="DQ">Disqualified (DQ)</option>
                  <option value="NS">No Show (NS)</option>
                  <option value="NR">No Return (NR)</option>
                </select>
              </div>
            </div>
          </div>

          <div id="scorecard-content">
            <div class="empty-state">
              <div class="empty-state-icon">ðŸ“‹</div>
              <p>Select a player from the right panel to enter scores</p>
            </div>
          </div>
        </div>

        <!-- Right Panel: Flight List -->
        <div class="players-panel">
          <h2 style="margin-top: 0; font-size: 18px; color: #1e293b; margin-bottom: 12px;">Flights</h2>
          <div class="search-box" style="position: relative;">
            <input id="player-search" type="text" placeholder="Search by player name... (Press Enter to select)" autocomplete="off" />
            <div id="player-dropdown" class="player-dropdown" style="display: none;"></div>
          </div>
          <div id="status-text" class="status-text"></div>
          <div class="table-wrapper">
            <table class="players-table">
              <thead>
                <tr>
                  <th>Group</th>
                  <th style="text-align: center;">Time</th>
                  <th style="text-align: center;">Tee</th>
                </tr>
              </thead>
              <tbody id="players-tbody">
                <!-- Populated dynamically -->
              </tbody>
            </table>
          </div>
        </div>
      </section>
      
      <button class="btn-save-scores" onclick="saveScores()">Save Scores</button>
    </main>

    <!-- Modal for score input -->
    <div id="score-modal" class="modal-overlay">
      <div class="modal-box">
        <h3 id="modal-title">Score Entry</h3>
        <p id="modal-message">Is this a Hole-in-One?</p>
        <div id="modal-input-container" style="display: none;">
          <input type="number" id="modal-input" class="modal-input" placeholder="Enter score" min="1" step="1">
        </div>
        <div class="modal-buttons">
          <button class="modal-btn-secondary" id="modal-cancel">Cancel</button>
          <button class="modal-btn-primary" id="modal-confirm">Confirm</button>
        </div>
      </div>
    </div>

    <script>
      // Get tournament from URL
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentIdParam = urlParams.get('tournamentId');
      
      let currentTournament = null;
      let currentRoundId = null;
      let currentRoundIndex = 0;
      let admittedPlayers = [];
      let selectedFlight = null;
      let courseData = null;
      let scores = {}; // { playerId: { holes: [hole1, hole2, ...], points: [p1, p2, ...] } }
      let flights = []; // Groups from draw
      let filteredFlights = [];
      let highlightedIndex = -1;

      // Add keyboard shortcut for F12 to save scores
      document.addEventListener('keydown', (e) => {
        if (e.key === 'F12') {
          e.preventDefault();
          saveScores();
          // Focus search bar for next player
          const searchInput = document.getElementById('player-search');
          if (searchInput) {
            searchInput.focus();
            searchInput.select();
          }
        }
      });

      // LocalStorage helpers
      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function getTournament() {
        const tournaments = getTournaments();
        return tournaments.find(t => t.tournamentId === tournamentIdParam);
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse courses', err);
          return [];
        }
      }

      function getTeeData(player) {
        if (!currentTournament || currentRoundIndex === undefined || currentRoundIndex < 0) return null;
        const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
        if (!roundData) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeValue = '';
        
        // Check if player has an assigned tee (from categories)
        if (player.tee) {
          // Convert tee ID to courseId||teeIndex format
          const courses = getCourses();
          const courseId = roundData.course;
          const course = courses.find(c => c.courseId === courseId);
          
          if (course && course.teeIds) {
            const idx = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              teeValue = `${courseId}||${idx}`;
            }
          }
        }
        
        // If no assigned tee, use default from tournament settings
        if (!teeValue) {
          if (playerGender === 'male' || playerGender === 'm') {
            teeValue = roundData.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            teeValue = roundData.teeWomen || '';
          }
        }
        
        if (!teeValue || !teeValue.includes('||')) return null;
        
        const [courseId, teeIndexStr] = teeValue.split('||');
        const teeIndex = parseInt(teeIndexStr, 10);
        
        const courses = getCourses();
        const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
        
        if (!course) return null;
        
        // Calculate total par from pars array (sum of all 18 holes)
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        // Get tee-specific data from teeData array
        const teeData = course.teeData?.[teeIndex];
        if (!teeData) return null;
        
        let slope, rating;
        
        // Check if this tee is for both genders (has nested ratings structure)
        const teeGender = course.genders?.[teeIndex];
        if (teeGender === 'B' && teeData.ratings) {
          // Both genders - use appropriate gender's ratings
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else if (playerGender === 'female' || playerGender === 'f') {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          // Single gender tee
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        return { slope, rating, par, course };
      }

      function calculatePlayingHcp(player) {
        const playerHcp = parseFloat(player.hcp);
        if (isNaN(playerHcp)) {
          return '';
        }
        
        const teeData = getTeeData(player);
        if (!teeData || !teeData.slope || !teeData.rating || !teeData.par) {
          return playerHcp; // Fallback to WHS HCP if data missing
        }
        
        const slope = parseFloat(teeData.slope);
        const rating = parseFloat(teeData.rating);
        const par = parseFloat(teeData.par);
        const hcpAllowance = parseFloat(currentTournament.meta?.hcpAllow || 100) / 100;
        
        if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
          return playerHcp;
        }
        
        // Formula: (HCP Ã— (Slope/113) + (Rating - Par)) Ã— HCP_Allowance
        const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
        
        // Round to nearest whole number (.5 rounds up)
        const rounded = Math.round(playingHcp);
        
        return rounded;
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          return data[currentRoundId] || [];
        } catch (err) {
          console.error('Failed to parse admitted players', err);
          return [];
        }
      }

      function getScoresData() {
        try {
          const raw = localStorage.getItem('scores');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse scores', err);
          return {};
        }
      }

      function saveScoresData(scoresData) {
        localStorage.setItem('scores', JSON.stringify(scoresData));
      }

      // Initialize
      function init() {
        currentTournament = getTournament();
        
        if (!currentTournament) {
          alert('Tournament not found.');
          window.location.href = 'index.html';
          return;
        }

        document.getElementById('tournament-name').textContent = `Enter scores for ${currentTournament.name}`;

        // Populate round selector
        const roundSelect = document.getElementById('round-select');
        const roundIds = currentTournament.meta?.roundIds || [currentTournament.tournamentId + '-1'];
        const roundsData = currentTournament.meta?.roundsData || [];

        roundIds.forEach((rid, idx) => {
          const option = document.createElement('option');
          option.value = rid;
          
          if (roundsData[idx]) {
            const roundDate = roundsData[idx].date || '';
            option.textContent = `Round ${idx + 1}${roundDate ? ' - ' + roundDate : ''}`;
          } else {
            option.textContent = `Round ${idx + 1}`;
          }
          
          roundSelect.appendChild(option);
        });

        currentRoundId = roundIds[0];
        currentRoundIndex = 0;
        roundSelect.value = currentRoundId;

        roundSelect.addEventListener('change', (e) => {
          currentRoundId = e.target.value;
          currentRoundIndex = roundIds.indexOf(currentRoundId);
          loadFlights();
        });

        loadFlights();
      }

      function loadFlights() {
        admittedPlayers = getAdmittedPlayers();
        selectedFlight = null;
        
        // Load draw/flights for this round
        const draws = JSON.parse(localStorage.getItem('draws') || '{}');
        console.log('All draws:', draws);
        console.log('Current round ID:', currentRoundId);
        const roundDraw = draws[currentRoundId];
        console.log('Round draw:', roundDraw);
        
        if (!roundDraw || !roundDraw.groups || roundDraw.groups.length === 0) {
          document.getElementById('status-text').textContent = 'No draw created for this round.';
          document.getElementById('players-tbody').innerHTML = '<tr><td colspan="3" style="text-align: center; color: #6b7280; padding: 20px;">Please create a draw first.</td></tr>';
          return;
        }
        
        // Filter groups with players and enrich with player data
        console.log('Round draw groups:', roundDraw.groups);
        flights = roundDraw.groups
          .filter(g => g.players && g.players.length > 0)
          .map((group, index) => {
            console.log('Processing group:', group);
            // Players in groups are already full player objects, not just reg numbers
            const groupPlayers = group.players.map(player => {
              // Always look up from admittedPlayers to get full data including categories
              const reg = typeof player === 'object' ? player.reg : player;
              return admittedPlayers.find(p => p.reg === reg);
            }).filter(p => p); // Remove null/undefined
            
            return {
              flightId: group.groupId || `flight-${index}`,
              flightName: group.groupName || `Group ${index + 1}`,
              time: group.time || '',
              tee: group.tee || '',
              players: groupPlayers
            };
          })
          .filter(f => f.players.length > 0);
        
        console.log('Processed flights:', flights);
        console.log('Number of flights:', flights.length);
        
        if (flights.length === 0) {
          document.getElementById('status-text').textContent = 'No players in draw.';
          document.getElementById('players-tbody').innerHTML = '<tr><td colspan="3" style="text-align: center; color: #6b7280; padding: 20px;">No players assigned to flights.</td></tr>';
          updateStatus();
          return;
        }

        // Get course info
        const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
        if (roundData && roundData.course) {
          const courses = getCourses();
          courseData = courses.find(c => c.courseId === roundData.course);
        }

        // Load existing scores
        const scoresData = getScoresData();
        const roundScores = scoresData[currentRoundId] || {};
        scores = {};
        
        admittedPlayers.forEach(player => {
          const playerKey = player.reg;
          const numHoles = courseData?.pars?.length || 18;
          scores[playerKey] = roundScores[playerKey] || {
            holes: Array(numHoles).fill(''),
            points: Array(numHoles).fill(''),
            stablefordPoints: Array(numHoles).fill(''),
            incompleteHoles: [], // Track holes where player did not complete (0 entered)
            status: ''
          };
        });

        console.log('About to render flights list');
        renderFlightsList();
        updateStatus();
      }

      function renderFlightsList() {
        console.log('renderFlightsList called, flights:', flights);
        const tbody = document.getElementById('players-tbody');
        const searchTerm = document.getElementById('player-search').value.toLowerCase();
        console.log('Search term:', searchTerm);
        
        // Get flights with completion status
        let flightsToShow = flights.map(flight => {
          // Check if all players are either scored or have a status
          const allPlayersComplete = flight.players.every(player => {
            const playerStatus = scores[player.reg]?.status;
            // If player has status (DQ/NS/NR), they're considered complete
            if (playerStatus) return true;
            
            // For active players, check if they have all 18 holes scored
            const playerScores = scores[player.reg]?.holes || [];
            return playerScores.filter(s => s !== '' && s !== null && s !== undefined).length === 18;
          });
          return { ...flight, isComplete: allPlayersComplete };
        });
        
        // Filter by search term
        if (searchTerm) {
          flightsToShow = flightsToShow.filter(flight => {
            return flight.players.some(p => {
              const fullName = `${p.firstName} ${p.lastName}`.toLowerCase();
              const reg = (p.reg || '').toString().toLowerCase();
              return fullName.includes(searchTerm) || reg.includes(searchTerm);
            });
          });
        }
        
        // Separate incomplete and complete
        const incompleteFlights = flightsToShow.filter(f => !f.isComplete);
        const completePlayers = [];
        
        // Extract all players from complete flights
        flightsToShow.filter(f => f.isComplete).forEach(flight => {
          flight.players.forEach(player => {
            const playerScores = scores[player.reg]?.holes || [];
            const total = playerScores.reduce((sum, score) => sum + (parseInt(score) || 0), 0);
            completePlayers.push({ ...player, totalScore: total });
          });
        });
        
        // Separate completed players by status - status players go to bottom
        const playersWithScores = completePlayers.filter(p => !scores[p.reg]?.status);
        const playersWithStatus = completePlayers.filter(p => scores[p.reg]?.status);
        
        // Sort players with scores by score
        playersWithScores.sort((a, b) => a.totalScore - b.totalScore);
        
        // Sort players with status alphabetically
        playersWithStatus.sort((a, b) => {
          const aName = `${a.firstName} ${a.lastName}`.toLowerCase();
          const bName = `${b.firstName} ${b.lastName}`.toLowerCase();
          return aName.localeCompare(bName);
        });
        
        filteredFlights = incompleteFlights;
        console.log('Incomplete flights to render:', filteredFlights.length);
        console.log('Completed players to render:', playersWithScores.length + playersWithStatus.length);

        tbody.innerHTML = '';
        
        // Render incomplete flights
        filteredFlights.forEach((flight, idx) => {
          const row = tbody.insertRow();
          row.dataset.flightId = flight.flightId;
          
          if (selectedFlight && selectedFlight.flightId === flight.flightId) {
            row.classList.add('selected');
          }
          
          // Highlight row if it matches highlightedIndex
          if (idx === highlightedIndex) {
            row.style.background = '#dbeafe';
          }

          const nameCell = row.insertCell();
          nameCell.textContent = flight.flightName;
          nameCell.style.fontWeight = '600';
          
          const timeCell = row.insertCell();
          timeCell.textContent = flight.time || '-';
          timeCell.style.textAlign = 'center';
          
          const teeCell = row.insertCell();
          teeCell.textContent = flight.tee || '-';
          teeCell.style.textAlign = 'center';

          row.addEventListener('click', () => {
            selectFlight(flight);
            highlightedIndex = -1;
          });
        });
        
        // Add separator row if there are completed players
        if (playersWithScores.length > 0 || playersWithStatus.length > 0) {
          const separatorRow = tbody.insertRow();
          separatorRow.innerHTML = '<td colspan="3" style="background: #f1f5f9; padding: 8px; font-weight: 600; color: #475569; text-align: left; border-top: 2px solid #cbd5e1;">Completed Players</td>';
        }
        
        // Render completed players with scores
        playersWithScores.forEach(player => {
          const row = tbody.insertRow();
          row.classList.add('completed');
          
          const nameCell = row.insertCell();
          const playerName = `${player.firstName} ${player.lastName}`;
          nameCell.innerHTML = `${playerName} <span class="player-total-score">(${player.totalScore})</span>`;
          
          const scoreCell = row.insertCell();
          scoreCell.textContent = player.totalScore;
          scoreCell.style.textAlign = 'center';
          scoreCell.style.fontWeight = '600';
          scoreCell.style.color = '#059669';
          
          const teeCell = row.insertCell();
          teeCell.textContent = '';
          teeCell.style.textAlign = 'center';
        });
        
        // Render players with status (DQ, NS, NR)
        playersWithStatus.forEach(player => {
          const row = tbody.insertRow();
          row.style.background = '#fee2e2'; // Light red background
          
          const nameCell = row.insertCell();
          const playerName = `${player.firstName} ${player.lastName}`;
          const status = scores[player.reg]?.status || '';
          nameCell.innerHTML = `${playerName} <span class="player-total-score" style="color: #dc2626;">(${status})</span>`;
          
          const scoreCell = row.insertCell();
          scoreCell.textContent = status;
          scoreCell.style.textAlign = 'center';
          scoreCell.style.fontWeight = '600';
          scoreCell.style.color = '#dc2626';
          
          const teeCell = row.insertCell();
          teeCell.textContent = '';
          teeCell.style.textAlign = 'center';
        });

        updateStatus();
      }

      function selectFlight(flight) {
        selectedFlight = flight;
        
        console.log('Selected flight:', flight);
        
        // Update selection in flight list
        document.querySelectorAll('.players-table tr').forEach(tr => tr.classList.remove('selected'));
        const selectedRow = document.querySelector(`[data-flight-id="${flight.flightId}"]`);
        if (selectedRow) {
          selectedRow.classList.add('selected');
        }

        // Hide player info section (not needed for flight mode)
        document.getElementById('player-info').style.display = 'none';

        // Render scorecard for all players in flight
        renderFlightScorecard(flight);
        
        // Focus on first hole input after a short delay (to ensure DOM is ready)
        setTimeout(() => {
          const firstInput = document.querySelector('.score-input[data-hole="0"]');
          if (firstInput && !firstInput.disabled) {
            firstInput.focus();
            firstInput.select();
          }
        }, 100);
      }

      function renderFlightScorecard(flight) {
        const content = document.getElementById('scorecard-content');
        
        if (!courseData || !courseData.pars) {
          content.innerHTML = '<div class="empty-state"><p>Course data not available</p></div>';
          return;
        }

        const pars = courseData.pars;
        const strokeIndexes = courseData.strokeIndexes || Array(pars.length).fill('-');
        
        let html = `<div style="margin-bottom: 16px; padding: 12px; background: #f0f9ff; border-radius: 8px; border: 1px solid #bae6fd;">
          <strong style="font-size: 16px; color: #0369a1;">${flight.flightName}</strong>
          <span style="margin-left: 12px; color: #64748b;">Time: ${flight.time || '-'}</span>
          <span style="margin-left: 12px; color: #64748b;">Players: ${flight.players.length}</span>
        </div>`;
        
        html += '<table class="scorecard-table">';
        
        // Build header row (Hole numbers)
        html += '<thead><tr><th>Hole</th>';
        for (let i = 0; i < 9 && i < pars.length; i++) {
          html += `<th>${i + 1}</th>`;
        }
        html += '<th class="subtotal-cell">OUT</th>';
        for (let i = 9; i < 18 && i < pars.length; i++) {
          html += `<th>${i + 1}</th>`;
        }
        html += '<th class="total-cell">IN</th>';
        html += '<th class="total-cell">TOT</th>';
        html += '</tr></thead><tbody>';

        // Par row (no stroke dots in flight mode - different for each player)
        html += '<tr><td><strong>Par</strong></td>';
        let front9Par = 0, back9Par = 0;
        
        for (let i = 0; i < 9 && i < pars.length; i++) {
          html += `<td>${pars[i]}</td>`;
          front9Par += pars[i];
        }
        html += `<td class="subtotal-cell">${front9Par}</td>`;
        for (let i = 9; i < 18 && i < pars.length; i++) {
          html += `<td>${pars[i]}</td>`;
          back9Par += pars[i];
        }
        html += `<td class="subtotal-cell">${back9Par}</td>`;
        html += `<td class="total-cell">${front9Par + back9Par}</td>`;
        html += '</tr>';

        // SI row
        html += '<tr><td><strong>SI</strong></td>';
        for (let i = 0; i < 9 && i < pars.length; i++) {
          html += `<td>${strokeIndexes[i]}</td>`;
        }
        html += '<td class="subtotal-cell">-</td>';
        for (let i = 9; i < 18 && i < pars.length; i++) {
          html += `<td>${strokeIndexes[i]}</td>`;
        }
        html += '<td class="subtotal-cell">-</td>';
        html += '<td class="total-cell">-</td>';
        html += '</tr>';

        // Loop through each player in the flight
        flight.players.forEach((player, playerIndex) => {
          const playerKey = player.reg;
          const playerScores = scores[playerKey];
          const playerStatus = playerScores.status || '';
          const disableInputs = playerStatus === 'NS' ? 'disabled' : '';
          const playerName = `${player.firstName} ${player.lastName}`;
          
          // Status dropdown for each player
          const statusDropdown = `
            <select class="status-select" data-player="${playerKey}" style="margin-left: 10px; padding: 2px 6px; font-size: 11px; border: 1px solid #cbd5e1; border-radius: 4px; background: white;">
              <option value="" ${!playerStatus ? 'selected' : ''}>Active</option>
              <option value="DQ" ${playerStatus === 'DQ' ? 'selected' : ''}>DQ</option>
              <option value="NS" ${playerStatus === 'NS' ? 'selected' : ''}>NS</option>
              <option value="NR" ${playerStatus === 'NR' ? 'selected' : ''}>NR</option>
            </select>
          `;
          
          // Score row for this player
          html += `<tr><td><strong>${playerName}</strong>${statusDropdown}</td>`;
          let front9Score = 0, back9Score = 0;
          
          for (let i = 0; i < 9 && i < pars.length; i++) {
            const score = playerScores.holes[i];
            if (score) front9Score += parseInt(score);
            html += `<td><input type="number" class="score-input" value="${score || ''}" 
                      data-hole="${i}" data-player="${playerKey}" min="1" max="15" step="1" ${score ? 'class="score-input has-value"' : ''} ${disableInputs}></td>`;
          }
          html += `<td class="subtotal-cell" id="front9-score-${playerKey}">${front9Score || '-'}</td>`;
          for (let i = 9; i < 18 && i < pars.length; i++) {
            const score = playerScores.holes[i];
            if (score) back9Score += parseInt(score);
            html += `<td><input type="number" class="score-input" value="${score || ''}" 
                      data-hole="${i}" data-player="${playerKey}" min="1" max="15" step="1" ${score ? 'class="score-input has-value"' : ''} ${disableInputs}></td>`;
          }
          html += `<td class="subtotal-cell" id="back9-score-${playerKey}">${back9Score || '-'}</td>`;
          html += `<td class="total-cell" id="total-score-${playerKey}">${(front9Score + back9Score) || '-'}</td>`;
          html += '</tr>';

          // Medal Net row for this player
          html += `<tr><td style="padding-left: 20px; font-size: 12px; color: #64748b;">Medal Net</td>`;
          let front9Net = 0, back9Net = 0;
          for (let i = 0; i < 9 && i < pars.length; i++) {
            const net = playerScores.points[i];
            if (net !== '' && net !== undefined && net !== null) front9Net += parseInt(net);
            html += `<td id="points-${playerKey}-${i}">${net !== '' && net !== undefined && net !== null ? net : '-'}</td>`;
          }
          html += `<td class="subtotal-cell" id="front9-points-${playerKey}">${front9Net || '-'}</td>`;
          for (let i = 9; i < 18 && i < pars.length; i++) {
            const net = playerScores.points[i];
            if (net !== '' && net !== undefined && net !== null) back9Net += parseInt(net);
            html += `<td id="points-${playerKey}-${i}">${net !== '' && net !== undefined && net !== null ? net : '-'}</td>`;
          }
          html += `<td class="subtotal-cell" id="back9-points-${playerKey}">${back9Net || '-'}</td>`;
          html += `<td class="total-cell" id="total-points-${playerKey}">${(front9Net + back9Net) || '-'}</td>`;
          html += '</tr>';

          // Stableford Net row for this player
          html += `<tr><td style="padding-left: 20px; font-size: 12px; color: #64748b;">Stableford</td>`;
          let front9Stableford = 0, back9Stableford = 0;
          for (let i = 0; i < 9 && i < pars.length; i++) {
            const stableford = playerScores.stablefordPoints[i];
            if (stableford !== '' && stableford !== undefined && stableford !== null) front9Stableford += parseInt(stableford);
            html += `<td id="stableford-${playerKey}-${i}">${stableford !== '' && stableford !== undefined && stableford !== null ? stableford : '-'}</td>`;
          }
          html += `<td class="subtotal-cell" id="front9-stableford-${playerKey}">${front9Stableford || '-'}</td>`;
          for (let i = 9; i < 18 && i < pars.length; i++) {
            const stableford = playerScores.stablefordPoints[i];
            if (stableford !== '' && stableford !== undefined && stableford !== null) back9Stableford += parseInt(stableford);
            html += `<td id="stableford-${playerKey}-${i}">${stableford !== '' && stableford !== undefined && stableford !== null ? stableford : '-'}</td>`;
          }
          html += `<td class="subtotal-cell" id="back9-stableford-${playerKey}">${back9Stableford || '-'}</td>`;
          html += `<td class="total-cell" id="total-stableford-${playerKey}">${(front9Stableford + back9Stableford) || '-'}</td>`;
          html += '</tr>';
        });

        html += '</tbody></table>';
        content.innerHTML = html;

        // Add event listeners to score inputs
        content.querySelectorAll('.score-input').forEach(input => {
          input.addEventListener('input', (e) => {
            const playerKey = e.target.dataset.player;
            handleScoreInput(e, playerKey);
          });

          input.addEventListener('focus', (e) => {
            // Select all text when clicking on an input with existing value
            if (e.target.value) {
              e.target.select();
            }
          });

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              const allInputs = Array.from(content.querySelectorAll('.score-input'));
              const currentIdx = allInputs.indexOf(e.target);
              if (currentIdx < allInputs.length - 1) {
                allInputs[currentIdx + 1].focus();
                allInputs[currentIdx + 1].select();
              }
            }
          });
        });

        // Add status change listeners
        content.querySelectorAll('.status-select').forEach(select => {
          select.addEventListener('change', (e) => {
            const playerKey = e.target.dataset.player;
            const newStatus = e.target.value;
            handleStatusChange(playerKey, newStatus);
          });
        });
      }

      function handleStatusChange(playerKey, newStatus) {
        // Update status in scores object
        if (!scores[playerKey]) {
          scores[playerKey] = { holes: [], points: [], stablefordPoints: [], incompleteHoles: [], isMaxScoreApplied: {}, status: '' };
        }
        scores[playerKey].status = newStatus;
        
        // Save to localStorage
        const scoresData = getScoresData();
        scoresData[currentRoundId] = scores;
        saveScoresData(scoresData);
        
        // Update disabled state of inputs for this player
        const playerInputs = document.querySelectorAll(`.score-input[data-player="${playerKey}"]`);
        playerInputs.forEach(input => {
          if (newStatus === 'NS') {
            input.disabled = true;
          } else {
            input.disabled = false;
          }
        });
        
        // Note: Don't call loadFlights() here - it would destroy the active scorecard
        // The flight list will be updated when user saves scores or navigates away
      }

      function handleScoreInput(e, playerKey) {
        const holeIndex = parseInt(e.target.dataset.hole);
        let score = e.target.value ? parseInt(e.target.value) : '';
        
        // Handle score of 1 - ask if hole-in-one or double digit
        if (score === 1 && e.target.value.length === 1) {
          showScoreModal(e.target, playerKey, holeIndex);
          return;
        }
        
        // Process score (including empty/deleted scores)
        processScore(e.target, playerKey, holeIndex, score);
      }

      function showScoreModal(inputElement, playerKey, holeIndex) {
        const modal = document.getElementById('score-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalInputContainer = document.getElementById('modal-input-container');
        const modalInput = document.getElementById('modal-input');
        const modalConfirm = document.getElementById('modal-confirm');
        const modalCancel = document.getElementById('modal-cancel');
        
        let stage = 1; // Stage 1: Ask if hole-in-one, Stage 2: Enter double digit
        
        // Stage 1: Is this a hole-in-one?
        modalTitle.textContent = 'Score Entry';
        modalMessage.textContent = 'Is this a Hole-in-One?';
        modalInputContainer.style.display = 'none';
        modalConfirm.textContent = 'Yes, Hole-in-One';
        modalCancel.textContent = 'No, Double Digit';
        modal.classList.add('active');
        
        const handleConfirm = () => {
          if (stage === 1) {
            // Hole-in-one confirmed
            cleanup();
            inputElement.value = 1;
            processScore(inputElement, playerKey, holeIndex, 1);
          } else {
            // Stage 2: Validate and save double digit
            const doubleDigit = parseInt(modalInput.value);
            if (doubleDigit && doubleDigit >= 10) {
              cleanup();
              inputElement.value = doubleDigit;
              processScore(inputElement, playerKey, holeIndex, doubleDigit);
            } else {
              modalInput.focus();
            }
          }
        };
        
        const handleCancel = () => {
          if (stage === 1) {
            // Move to stage 2: Enter double digit
            stage = 2;
            modalTitle.textContent = 'Enter Double-Digit Score';
            modalMessage.textContent = 'Enter the score (10 or higher):';
            modalInputContainer.style.display = 'block';
            modalInput.value = '10';
            modalInput.focus();
            modalInput.select();
            modalConfirm.textContent = 'Confirm';
            modalCancel.textContent = 'Cancel';
          } else {
            // Cancel double digit entry
            cleanup();
            inputElement.value = '';
          }
        };
        
        const cleanup = () => {
          modal.classList.remove('active');
          modalConfirm.removeEventListener('click', handleConfirm);
          modalCancel.removeEventListener('click', handleCancel);
          modalInput.removeEventListener('keydown', handleEnter);
        };
        
        const handleEnter = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleConfirm();
          }
        };
        
        modalConfirm.addEventListener('click', handleConfirm);
        modalCancel.addEventListener('click', handleCancel);
        modalInput.addEventListener('keydown', handleEnter);
      }

      function playerHasStablefordCategory(player) {
        // Check if player has any Stableford category assigned
        console.log('Checking Stableford for player:', player.firstName, player.lastName);
        console.log('Player categories:', player.categories);
        
        if (!player.categories || !Array.isArray(player.categories)) {
          console.log('No categories array found');
          return false;
        }
        
        const categories = getCategories();
        console.log('All tournament categories:', categories);
        
        for (const catCode of player.categories) {
          const category = categories.find(c => c.code === catCode);
          console.log(`Category ${catCode}:`, category);
          if (category && category.tournamentType) {
            console.log('Tournament type:', category.tournamentType);
            if (category.tournamentType.toLowerCase().includes('stableford')) {
              console.log('âœ“ Player HAS Stableford category!');
              return true;
            }
          }
        }
        
        console.log('âœ— Player does NOT have Stableford category');
        return false;
      }
      
      function getCategories() {
        try {
          // Categories are stored in tournament.categories
          return currentTournament?.categories || [];
        } catch (err) {
          console.error('Error loading categories:', err);
          return [];
        }
      }

      function getMaxScoreForHole(holeIndex, player) {
        const maxScoreSetting = currentTournament?.meta?.maxScore;
        if (!maxScoreSetting || maxScoreSetting === 'na' || !courseData || !courseData.pars) {
          return null;
        }
        
        const par = courseData.pars[holeIndex];
        const si = courseData.strokeIndexes?.[holeIndex] || 999;
        const phcp = player.phcp || 0;
        
        switch(maxScoreSetting) {
          case 'net_double_bogey':
            // Net double bogey = par + 2 + strokes received
            const strokesReceived = getStrokesForHole(phcp, si);
            return par + 2 + strokesReceived;
          case 'par_plus_4':
            return par + 4;
          case 'double_par':
            return par * 2;
          case '10':
            return 10;
          default:
            return null;
        }
      }

      function processScore(inputElement, playerKey, holeIndex, score) {
        // Find player object from flight
        const player = selectedFlight.players.find(p => p.reg === playerKey);
        if (!player) return;
        
        // Handle empty/deleted score
        if (score === '' || score === null || score === undefined) {
          scores[playerKey].holes[holeIndex] = '';
          scores[playerKey].points[holeIndex] = '';
          scores[playerKey].stablefordPoints[holeIndex] = '';
          
          // Remove from incomplete holes
          if (scores[playerKey].incompleteHoles) {
            scores[playerKey].incompleteHoles = scores[playerKey].incompleteHoles.filter(h => h !== holeIndex);
          }
          
          // Clear max score flag
          if (scores[playerKey].isMaxScoreApplied) {
            scores[playerKey].isMaxScoreApplied[holeIndex] = false;
          }
          
          // Clear styling
          inputElement.classList.remove('has-value', 'score-par', 'score-birdie', 'score-eagle', 'score-bogey', 'score-double-bogey');
          
          // Update displays
          const pointsCell = document.getElementById(`points-${playerKey}-${holeIndex}`);
          if (pointsCell) pointsCell.textContent = '-';
          
          const stablefordCell = document.getElementById(`stableford-${playerKey}-${holeIndex}`);
          if (stablefordCell) stablefordCell.textContent = '-';
          
          // Update totals
          updateTotals(playerKey);
          return;
        }
        
        let isMaxScoreApplied = false;
        let isIncompleteHole = false;
        
        // Track if 0 was originally entered (player did not complete hole)
        if (score === 0) {
          isIncompleteHole = true;
          
          // Check if max score option is NOT activated
          const maxScore = getMaxScoreForHole(holeIndex, player);
          if (maxScore === null) {
            // No max score option - check if player has Stableford category
            const hasStableford = playerHasStablefordCategory(player);
            
            if (!hasStableford) {
              // Player doesn't have Stableford category - show warning
              const playerName = `${player.firstName} ${player.lastName}`;
              const confirmed = confirm(
                `Player ${playerName} is not assigned to a category which allows no score for a hole.\n\n` +
                `Player will be disqualified.\n\n` +
                `Click OK to mark as DQ, or Cancel to enter a proper score.`
              );
              
              if (confirmed) {
                // Mark player as DQ
                scores[playerKey].status = 'DQ';
                
                // Auto-save the DQ status
                const scoresData = getScoresData();
                scoresData[currentRoundId] = scores;
                saveScoresData(scoresData);
                
                // Update the status dropdown for this player
                const statusSelect = document.querySelector(`.status-select[data-player="${playerKey}"]`);
                if (statusSelect) {
                  statusSelect.value = 'DQ';
                }
                
                // Clear input - don't call loadFlights() as it would destroy the scorecard
                inputElement.value = '';
                return;
              } else {
                // Cancel - clear the input and don't process
                inputElement.value = '';
                return;
              }
            }
          }
          
          // Track incomplete hole
          if (!scores[playerKey].incompleteHoles) {
            scores[playerKey].incompleteHoles = [];
          }
          if (!scores[playerKey].incompleteHoles.includes(holeIndex)) {
            scores[playerKey].incompleteHoles.push(holeIndex);
          }
        } else {
          // Remove from incomplete holes if a real score is entered
          if (scores[playerKey].incompleteHoles) {
            scores[playerKey].incompleteHoles = scores[playerKey].incompleteHoles.filter(h => h !== holeIndex);
          }
        }
        
        // Check if max score is activated and should be applied
        const maxScore = getMaxScoreForHole(holeIndex, player);
        if (maxScore !== null) {
          // Apply max score if score is 0 or exceeds max score
          if (score === 0 || score > maxScore) {
            score = maxScore;
            inputElement.value = maxScore;
            isMaxScoreApplied = true;
          }
        }
        
        scores[playerKey].holes[holeIndex] = score;
        scores[playerKey].isMaxScoreApplied = scores[playerKey].isMaxScoreApplied || {};
        scores[playerKey].isMaxScoreApplied[holeIndex] = isMaxScoreApplied;
        
        // Apply score type styling based on par
        inputElement.classList.remove('has-value', 'score-par', 'score-birdie', 'score-eagle', 'score-bogey', 'score-double-bogey', 'score-zero');
        
        if (score === 0) {
          // Special styling for zero score (incomplete hole)
          inputElement.classList.add('score-zero');
        } else if (score && courseData && courseData.pars) {
          const par = courseData.pars[holeIndex];
          const diff = score - par;
          
          if (diff === 0) {
            inputElement.classList.add('score-par');
          } else if (diff === -1) {
            inputElement.classList.add('score-birdie');
          } else if (diff <= -2) {
            inputElement.classList.add('score-eagle');
          } else if (diff === 1) {
            inputElement.classList.add('score-bogey');
          } else if (diff >= 2) {
            inputElement.classList.add('score-double-bogey');
          }
        }
        if (!player) return;

        // Calculate Medal Net
        const points = calculatePoints(holeIndex, score, player);
        scores[playerKey].points[holeIndex] = points;
        
        // Update Medal Net display (with player-specific ID)
        const pointsCell = document.getElementById(`points-${playerKey}-${holeIndex}`);
        if (pointsCell) {
          pointsCell.textContent = points || '-';
        }

        // Calculate Stableford Net
        const stablefordPoints = calculateStablefordPoints(holeIndex, score, player);
        scores[playerKey].stablefordPoints[holeIndex] = stablefordPoints;
        
        // Update Stableford Net display (with player-specific ID)
        const stablefordCell = document.getElementById(`stableford-${playerKey}-${holeIndex}`);
        if (stablefordCell) {
          stablefordCell.textContent = stablefordPoints !== '' ? stablefordPoints : '-';
        }

        // Update totals
        updateTotals(playerKey);

        // Auto-advance to next hole (advance for any number including 0)
        if (score !== '' && score !== null && score !== undefined) {
          const allInputs = Array.from(document.querySelectorAll('.score-input'));
          const currentIdx = allInputs.indexOf(inputElement);
          if (currentIdx < allInputs.length - 1) {
            allInputs[currentIdx + 1].focus();
            allInputs[currentIdx + 1].select();
          }
        }
      }

      function getStrokesForHole(phcp, strokeIndex) {
        // Calculate how many strokes a player receives/gives on this hole
        const si = parseInt(strokeIndex);
        if (isNaN(si) || si > 18 || si < 1) return 0;
        
        // Convert phcp to number, handling both old string format ("+2") and new numeric format (-2)
        let numPhcp;
        if (typeof phcp === 'string') {
          if (phcp.startsWith('+')) {
            // Plus handicap: "+2" becomes -2
            numPhcp = -parseInt(phcp.substring(1));
          } else {
            numPhcp = parseInt(phcp) || 0;
          }
        } else {
          numPhcp = phcp || 0;
        }
        
        const absPhcp = Math.abs(numPhcp);
        const fullStrokes = Math.floor(absPhcp / 18);
        const remainingStrokes = absPhcp % 18;
        
        if (numPhcp >= 0) {
          // Positive handicap - receives strokes on easiest holes (lowest SI)
          // SI 1, 2, 3... up to remainingStrokes
          return fullStrokes + (si <= remainingStrokes ? 1 : 0);
        } else {
          // Plus handicap - gives strokes on hardest holes (highest SI)
          // For PHCP -2: gives on SI 17 and 18 (the 2 hardest)
          // For PHCP -5: gives on SI 14, 15, 16, 17, 18 (the 5 hardest)
          // SI must be >= (19 - remainingStrokes) to give a stroke
          const givesStroke = si >= (19 - remainingStrokes) ? 1 : 0;
          return -(fullStrokes + givesStroke);
        }
      }

      function calculatePoints(holeIndex, score, player) {
        if (!score || !courseData || !courseData.pars) return '';
        
        const playerKey = player.reg;
        const isMaxScoreApplied = scores[playerKey]?.isMaxScoreApplied?.[holeIndex];
        
        // If max score was applied (0 entered or score exceeded max), don't subtract strokes
        if (isMaxScoreApplied) {
          return score; // Medal Net = Gross (no handicap adjustment)
        }
        
        const si = courseData.strokeIndexes?.[holeIndex] || 999;
        const phcp = player.phcp || 0;
        
        // Calculate strokes received/given on this hole
        const strokesReceived = getStrokesForHole(phcp, si);
        
        // Medal Net score = Gross score - strokes received
        // For plus handicaps, strokesReceived is negative, so subtracting adds to the score
        // Example: score=4, strokes=-1 (gives 1), net = 4 - (-1) = 5
        const netScore = score - strokesReceived;
        
        return netScore;
      }

      function calculateStablefordPoints(holeIndex, score, player) {
        if (score === '' || score === null || score === undefined || !courseData || !courseData.pars) return '';
        
        // If score is 0, return 0 Stableford points
        if (score === 0) return 0;
        
        const par = courseData.pars[holeIndex];
        const si = courseData.strokeIndexes?.[holeIndex] || 999;
        const phcp = player.phcp || 0;
        
        // Calculate strokes received/given on this hole
        const strokesReceived = getStrokesForHole(phcp, si);
        
        // Net score for this hole
        const netScore = score - strokesReceived;
        
        // Stableford points calculation
        // Par or better: 2 + (par - netScore)
        // Over par: max(0, 2 - (netScore - par))
        const scoreDiff = netScore - par;
        
        if (scoreDiff <= 0) {
          // Par or better: Birdie = 3, Eagle = 4, etc.
          return 2 - scoreDiff;
        } else {
          // Over par: Bogey = 1, Double+ = 0
          return Math.max(0, 2 - scoreDiff);
        }
      }

      function updateTotals(playerKey) {
        const playerScores = scores[playerKey];
        
        let front9Score = 0, front9Points = 0, front9Stableford = 0;
        let back9Score = 0, back9Points = 0, back9Stableford = 0;

        for (let i = 0; i < 9; i++) {
          if (playerScores.holes[i]) front9Score += parseInt(playerScores.holes[i]);
          if (playerScores.points[i]) front9Points += parseInt(playerScores.points[i]);
          if (playerScores.stablefordPoints[i] !== '' && playerScores.stablefordPoints[i] !== undefined) {
            front9Stableford += parseInt(playerScores.stablefordPoints[i]);
          }
        }

        for (let i = 9; i < 18; i++) {
          if (playerScores.holes[i]) back9Score += parseInt(playerScores.holes[i]);
          if (playerScores.points[i]) back9Points += parseInt(playerScores.points[i]);
          if (playerScores.stablefordPoints[i] !== '' && playerScores.stablefordPoints[i] !== undefined) {
            back9Stableford += parseInt(playerScores.stablefordPoints[i]);
          }
        }

        // Use player-specific IDs
        const front9El = document.getElementById(`front9-score-${playerKey}`);
        const back9El = document.getElementById(`back9-score-${playerKey}`);
        const totalEl = document.getElementById(`total-score-${playerKey}`);
        const front9PtsEl = document.getElementById(`front9-points-${playerKey}`);
        const back9PtsEl = document.getElementById(`back9-points-${playerKey}`);
        const totalPtsEl = document.getElementById(`total-points-${playerKey}`);
        const front9StablefordEl = document.getElementById(`front9-stableford-${playerKey}`);
        const back9StablefordEl = document.getElementById(`back9-stableford-${playerKey}`);
        const totalStablefordEl = document.getElementById(`total-stableford-${playerKey}`);
        
        if (front9El) front9El.textContent = front9Score || '-';
        if (back9El) back9El.textContent = back9Score || '-';
        if (totalEl) totalEl.textContent = (front9Score + back9Score) || '-';
        if (front9PtsEl) front9PtsEl.textContent = front9Points || '-';
        if (back9PtsEl) back9PtsEl.textContent = back9Points || '-';
        if (totalPtsEl) totalPtsEl.textContent = (front9Points + back9Points) || '-';
        if (front9StablefordEl) front9StablefordEl.textContent = front9Stableford || '-';
        if (back9StablefordEl) back9StablefordEl.textContent = back9Stableford || '-';
        if (totalStablefordEl) totalStablefordEl.textContent = (front9Stableford + back9Stableford) || '-';
      }

      function updateStatus() {
        const playersWithScores = Object.values(scores).filter(data => 
          data.holes && data.holes.some(s => s !== '')
        ).length;
        
        document.getElementById('status-text').textContent = 
          `${admittedPlayers.length} players | ${playersWithScores} with scores entered`;
      }

      function renderPlayerDropdown() {
        const dropdown = document.getElementById('player-dropdown');
        dropdown.innerHTML = '';
        
        filteredPlayersList.forEach((player, index) => {
          const item = document.createElement('div');
          item.className = 'player-dropdown-item';
          if (index === dropdownHighlightIndex) {
            item.classList.add('highlighted');
          }
          
          // Find which flight this player is in
          const playerFlight = flights.find(f => f.players.some(p => p.reg === player.reg));
          const flightInfo = playerFlight ? `${playerFlight.groupName} - ${playerFlight.time}` : 'No flight';
          
          item.innerHTML = `
            <span class="player-name">${player.firstName} ${player.lastName}</span>
            <span class="player-details">${flightInfo}</span>
          `;
          
          item.addEventListener('click', () => {
            selectPlayerFromDropdown(player);
          });
          
          dropdown.appendChild(item);
        });
      }

      function selectPlayerFromDropdown(player) {
        // Find the flight this player belongs to
        const playerFlight = flights.find(f => f.players.some(p => p.reg === player.reg));
        
        if (playerFlight) {
          // Select the flight
          selectFlight(playerFlight);
        }
        
        // Close dropdown and clear search
        const dropdown = document.getElementById('player-dropdown');
        const searchInput = document.getElementById('player-search');
        dropdown.style.display = 'none';
        searchInput.value = '';
        filteredPlayersList = [];
        dropdownHighlightIndex = -1;
        
        // Re-render flights list to original state
        renderFlightsList();
      }

      function saveScores() {
        if (!selectedFlight) {
          alert('Please select a flight first.');
          return;
        }
        
        // Save all players in the flight
        const scoresData = getScoresData();
        scoresData[currentRoundId] = scores;
        saveScoresData(scoresData);
        
        // Reload flights to update completion status
        loadFlights();
        
        // Clear selection and focus search bar
        selectedFlight = null;
        document.getElementById('scorecard-content').innerHTML = '';
        
        const searchInput = document.getElementById('player-search');
        if (searchInput) {
          searchInput.focus();
          searchInput.select();
        }
      }

      // Search functionality with player dropdown
      const searchInput = document.getElementById('player-search');
      const dropdown = document.getElementById('player-dropdown');
      let filteredPlayersList = [];
      let dropdownHighlightIndex = -1;
      
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase().trim();
        
        if (query) {
          // Show player dropdown
          filteredPlayersList = admittedPlayers.filter(p => {
            const fullName = `${p.firstName} ${p.lastName}`.toLowerCase();
            const reg = (p.reg || '').toString();
            return fullName.includes(query) || reg.includes(query);
          });
          
          if (filteredPlayersList.length > 0) {
            renderPlayerDropdown();
            dropdownHighlightIndex = 0;
            dropdown.style.display = 'block';
          } else {
            dropdown.style.display = 'none';
          }
        } else {
          dropdown.style.display = 'none';
          filteredPlayersList = [];
        }
        
        // Also filter flights list
        highlightedIndex = -1;
        renderFlightsList();
      });
      
      searchInput.addEventListener('keydown', (e) => {
        if (dropdown.style.display === 'block' && filteredPlayersList.length > 0) {
          // Navigate dropdown
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            dropdownHighlightIndex = Math.min(dropdownHighlightIndex + 1, filteredPlayersList.length - 1);
            renderPlayerDropdown();
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            dropdownHighlightIndex = Math.max(dropdownHighlightIndex - 1, 0);
            renderPlayerDropdown();
          } else if (e.key === 'Enter') {
            e.preventDefault();
            if (dropdownHighlightIndex >= 0 && filteredPlayersList[dropdownHighlightIndex]) {
              selectPlayerFromDropdown(filteredPlayersList[dropdownHighlightIndex]);
            }
          } else if (e.key === 'Escape') {
            dropdown.style.display = 'none';
            searchInput.value = '';
            renderFlightsList();
          }
        } else {
          // Navigate flight list (old behavior when dropdown is not shown)
          if (e.key === 'Enter') {
            e.preventDefault();
            if (highlightedIndex >= 0 && filteredFlights[highlightedIndex]) {
              selectFlight(filteredFlights[highlightedIndex]);
              searchInput.value = '';
              highlightedIndex = -1;
              renderFlightsList();
            }
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (filteredFlights.length > 0) {
              highlightedIndex = Math.min(highlightedIndex + 1, filteredFlights.length - 1);
              renderFlightsList();
              // Scroll highlighted row into view
              const rows = document.querySelectorAll('.players-table tbody tr');
              if (rows[highlightedIndex]) {
                rows[highlightedIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
              }
            }
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (filteredFlights.length > 0) {
              highlightedIndex = Math.max(highlightedIndex - 1, 0);
              renderFlightsList();
              // Scroll highlighted row into view
              const rows = document.querySelectorAll('.players-table tbody tr');
              if (rows[highlightedIndex]) {
                rows[highlightedIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
              }
            }
          }
        }
      });

      // Setup table header sorting
      function setupTableSorting() {
        document.querySelectorAll('.players-table th[data-sort]').forEach(header => {
          header.addEventListener('click', () => {
            const column = header.getAttribute('data-sort');
            
            // Toggle direction if same column, otherwise default to asc
            if (sortColumn === column) {
              sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
              sortColumn = column;
              sortDirection = 'asc';
            }
            
            // Update sort indicators
            document.querySelectorAll('.players-table th span').forEach(span => {
              span.textContent = '';
            });
            
            const indicator = sortDirection === 'asc' ? 'â–²' : 'â–¼';
            document.getElementById(`sort-${column}`).textContent = indicator;
            
            renderFlightsList();
          });
        });
      }

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.getElementById('player-dropdown');
        const searchInput = document.getElementById('player-search');
        
        if (dropdown && searchInput && 
            !dropdown.contains(e.target) && 
            e.target !== searchInput) {
          dropdown.style.display = 'none';
        }
      });

      // Initialize on load
      init();
      setupTableSorting();
    </script>
  </body>
</html>
