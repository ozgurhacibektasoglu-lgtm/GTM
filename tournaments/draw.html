<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tournament Draw</title>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="../firebase-config.js"></script>
  
  <link rel="stylesheet" href="../styles.css">
  <style>
    .container {
      max-width: 100%;
      padding: 12px 20px;
    }

    .draw-container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }

    .left-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .right-panel {
      flex: 0 0 320px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      font-size: 14px;
    }

    .form-group select,
    .form-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .players-list {
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      max-height: calc(100vh - 380px);
      overflow-y: auto;
      flex: 1;
    }

    .players-list h3 {
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 16px;
      color: #333;
    }

    .player-card {
      background: #f8f9fa;
      padding: 10px;
      margin-bottom: 8px;
      border-radius: 4px;
      cursor: move;
      border: 2px solid transparent;
      transition: all 0.2s;
      border-left: 4px solid #94a3b8;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .player-card.male {
      background: #e0f2fe;
      border-left: 4px solid #0284c7;
    }

    .player-card.female {
      background: #fce7f3;
      border-left: 4px solid #ec4899;
    }

    .player-card:hover {
      border-color: #007bff;
      background: #e7f3ff;
      border-left-color: #007bff;
    }

    .player-card.male:hover {
      background: #bae6fd;
      border-left-color: #0369a1;
    }

    .player-card.female:hover {
      background: #fbcfe8;
      border-left-color: #db2777;
    }

    .player-card.dragging {
      opacity: 0.5;
    }

    .player-card.pairing-card {
      cursor: move;
    }

    .player-card.pairing-card:hover {
      border-color: #7c3aed;
      background: linear-gradient(135deg, #bae6fd 50%, #fbcfe8 50%);
    }

    .player-name {
      font-weight: 600;
      font-size: clamp(11px, 2.5vw, 13px);
      margin-bottom: 4px;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .player-info {
      font-size: 12px;
      color: #666;
      display: flex;
      justify-content: space-between;
    }

    .groups-area {
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      height: fit-content;
    }

    .groups-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .groups-header h3 {
      margin: 0;
      font-size: 16px;
    }

    .auto-buttons {
      display: flex;
      gap: 10px;
    }

    .auto-buttons button {
      padding: 8px 15px;
      font-size: 13px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #28a745;
      color: white;
      transition: background 0.2s;
    }

    .auto-buttons button:hover {
      background: #218838;
    }

    .auto-buttons button.secondary {
      background: #6c757d;
    }

    .auto-buttons button.secondary:hover {
      background: #5a6268;
    }

    .groups-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
    }

    .group-box {
      background: #f8f9fa;
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 12px;
      min-height: 280px;
      transition: all 0.2s;
      cursor: pointer;
    }

    .group-box:hover {
      border-color: #999;
    }

    .group-box.selected-group {
      border: 2px solid #dc3545;
      background: #fff5f5;
      box-shadow: 0 0 8px rgba(220, 53, 69, 0.3);
    }

    .group-box.drag-over {
      border-color: #007bff;
      background: #e7f3ff;
    }

    .group-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #ddd;
      gap: 8px;
    }

    .group-title {
      font-weight: 600;
      font-size: 14px;
      color: #333;
    }

    .group-time {
      font-size: 12px;
      color: #666;
      margin-left: auto;
    }

    .group-players {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .group-player-card {
      background: white;
      padding: 8px;
      border-radius: 4px;
      font-size: 13px;
      cursor: move;
      border: 1px solid #ddd;
      border-left: 4px solid #94a3b8;
      position: relative;
      min-height: 50px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .group-player-card.male {
      background: #e0f2fe;
      border-left: 4px solid #0284c7;
    }

    .group-player-card.female {
      background: #fce7f3;
      border-left: 4px solid #ec4899;
    }

    .group-player-card:hover {
      border-color: #007bff;
      border-left-color: #007bff;
    }

    .group-player-card.male:hover {
      background: #bae6fd;
      border-left-color: #0369a1;
    }

    .group-player-card.female:hover {
      background: #fbcfe8;
      border-left-color: #db2777;
    }

    .remove-player {
      position: absolute;
      right: 5px;
      top: 5px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 3px;
      width: 20px;
      height: 20px;
      font-size: 12px;
      cursor: pointer;
      display: none;
    }

    .group-player-card:hover .remove-player {
      display: block;
    }

    /* Pin group button */
    .pin-group-btn {
      background: #6b7280;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
      margin-left: 8px;
    }

    .pin-group-btn:hover {
      background: #f59e0b;
    }

    /* Pinned group styling */
    .group-box.pinned-group {
      background: linear-gradient(135deg, #fef3c7, #fde68a) !important;
      border: 2px solid #f59e0b !important;
    }

    .group-box.pinned-group .group-header {
      background: #f59e0b;
      margin: -12px -12px 10px -12px;
      padding: 8px 12px;
      border-radius: 6px 6px 0 0;
      color: white;
    }

    .group-box.pinned-group .pin-group-btn {
      background: white;
      color: #f59e0b;
    }

    /* Pin group button */
    .pin-group-btn {
      padding: 2px 8px;
      font-size: 11px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f8f9fa;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .pin-group-btn:hover {
      background: #fef3c7;
      border-color: #f59e0b;
    }

    /* Draggable group styling */
    .group-box.draggable-group {
      cursor: grab;
    }
    
    .group-box.draggable-group:active {
      cursor: grabbing;
    }
    
    .group-box.dragging-group {
      opacity: 0.5;
      border: 2px dashed #007bff;
    }
    
    .group-box.pinned-group {
      cursor: default;
    }
    
    .group-box.drop-left {
      border-left: 4px solid #007bff;
    }
    
    .group-box.drop-right {
      border-right: 4px solid #007bff;
    }
    
    .group-box.drop-blocked-indicator {
      border-left: 4px solid #dc3545;
    }

    .empty-state {
      text-align: center;
      color: #999;
      padding: 30px;
      font-size: 14px;
    }

    .time-config {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    /* Modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .modal-content h2 {
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 20px;
      color: #1e293b;
    }

    .modal-form-group {
      margin-bottom: 20px;
    }

    .modal-form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }

    .modal-form-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 24px;
      justify-content: flex-end;
    }

    .modal-buttons button {
      padding: 10px 20px;
      border-radius: 8px;
      border: 0;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }

    .modal-btn-primary {
      background: #007bff;
      color: white;
    }

    .modal-btn-primary:hover {
      background: #0056b3;
    }

    .modal-btn-secondary {
      background: white;
      border: 1px solid #ddd;
      color: #333;
    }

    .modal-btn-secondary:hover {
      background: #f8f9fa;
    }

    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .group-distribution-info {
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 8px;
      padding: 12px;
      margin-top: 10px;
      font-size: 14px;
      color: #0c4a6e;
    }

    .group-distribution-options {
      margin-top: 10px;
    }

    .distribution-option {
      display: flex;
      align-items: center;
      padding: 8px;
      margin-bottom: 6px;
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .distribution-option:hover {
      border-color: #007bff;
      background: #f8fafc;
    }

    .distribution-option input[type="radio"] {
      margin-right: 10px;
    }

    .distribution-option label {
      cursor: pointer;
      margin: 0;
      font-weight: 500;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      font-weight: normal;
      cursor: pointer;
    }

    .checkbox-group input[type="checkbox"] {
      margin-right: 8px;
      cursor: pointer;
    }
    
    /* Action Buttons - Top Bar */
    .action-buttons-bar {
      background: #f8fafc;
      padding: 8px 20px;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .action-btn {
      background: linear-gradient(180deg, #0b6efd, #0a58d1);
      color: white;
      border: 0;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .action-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(11,110,253,0.3);
    }
    
    .action-btn.success {
      background: linear-gradient(180deg, #28a745, #218838);
    }
    
    .action-btn.danger {
      background: linear-gradient(180deg, #dc3545, #c82333);
    }
    
    .action-btn.secondary {
      background: white;
      color: #333;
      border: 1px solid #e6e9ef;
    }
    
    .btn-save {
      background: linear-gradient(180deg, #28a745, #218838);
      color: white;
      border: 0;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
      margin-left: auto;
    }
    
    .btn-save:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(40,167,69,0.3);
    }
  </style>
</head>
<body>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>
    <script src="../components/auth.js"></script>
    <script>
      (async function(){
        const { user, role } = await window.Auth.requireAuth();
        const uid = user.uid;
        const params = new URLSearchParams(window.location.search);
        const tournamentId = params.get('tournamentId');
        try {
          const raw = localStorage.getItem('tournaments');
          const list = raw ? JSON.parse(raw) : [];
          const t = list.find(x => x && x.tournamentId === tournamentId);
          if (!t) return; // if not found, let page handle its own fallback
          if (role !== 'admin' && t.createdBy && t.createdBy !== uid){
            alert('You do not have access to this tournament.');
            window.location.href = 'index.html';
          }
        } catch(e){}
      })();
    </script>
  <div class="top-nav">
    <h1>üèÜ Draw</h1>
    <a href="index.html" class="btn-back-top">‚Üê Back</a>
  </div>
  
  <!-- Action Buttons Bar -->
  <div class="action-buttons-bar">
    <button class="action-btn" onclick="openAutoGroupModal()">‚ö° Auto Group</button>
    <button class="action-btn success" onclick="addNewGroup()">+ Add Group</button>
    <button class="action-btn danger" onclick="removeSelectedGroup()">- Remove Group</button>
    <button class="action-btn secondary" onclick="clearGroups()">Clear All</button>
    <button class="btn-save" id="btn-save-draw">üíæ Save Draw</button>
  </div>
  
  <!-- Auto Group Modal -->
  <div id="auto-group-modal" class="modal-overlay">
    <div class="modal-content">
      <h2>Auto Group Settings</h2>
      
      <div id="pinned-players-info" style="display: none; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 10px 12px; margin-bottom: 15px; font-size: 13px;">
        <span style="font-weight: 600;">üìå <span id="pinned-count">0</span> pinned group(s)</span> will remain unchanged.
      </div>
      
      <div class="modal-form-group">
        <label>Number of Players in Group</label>
        <select id="modal-group-size" onchange="calculateGroupDistribution()">
          <option value="2">2 Players</option>
          <option value="3">3 Players</option>
          <option value="4" selected>4 Players</option>
        </select>
      </div>

      <div id="group-distribution-section" style="display: none;">
        <div class="modal-form-group">
          <label>Group Distribution</label>
          <div id="group-distribution-info" class="group-distribution-info"></div>
          <div id="group-distribution-options" class="group-distribution-options"></div>
        </div>
      </div>

      <div class="modal-form-group">
        <label>Grouping Order</label>
        <select id="grouping-order">
          <option value="random">Random</option>
          <option value="hcp-asc">HCP (Ascending)</option>
          <option value="hcp-desc">HCP (Descending)</option>
          <option value="phcp-asc">PHCP (Ascending)</option>
          <option value="phcp-desc">PHCP (Descending)</option>
          <option value="hcp-distribution">HCP Distribution</option>
          <option value="club-distribution">Club/Country Distribution</option>
        </select>
      </div>

      <div class="modal-form-group">
        <label>Separate By</label>
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="separate-gender" onchange="calculateGroupDistribution()">
            Gender
          </label>
          <label>
            <input type="checkbox" id="separate-categories" onchange="calculateGroupDistribution()">
            Categories
          </label>
        </div>
      </div>

      <div class="modal-buttons">
        <button class="modal-btn-secondary" onclick="closeAutoGroupModal()">Cancel</button>
        <button class="modal-btn-primary" onclick="confirmAutoGroup()">Generate Groups</button>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- Round Select and Starting Protocol - Horizontal Bar -->
    <div style="display: flex; gap: 20px; align-items: flex-start; flex-wrap: wrap; background: white; padding: 12px 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 12px;">
      <!-- Round Select -->
      <div style="display: flex; align-items: center; gap: 10px;">
        <label for="round-select" style="font-weight: 600; white-space: nowrap;">Select Round:</label>
        <select id="round-select" style="padding: 8px 12px; border-radius: 4px; border: 1px solid #ddd; min-width: 180px;">
          <option value="">-- Select Round --</option>
        </select>
      </div>
      
      <!-- Starting Protocol - Horizontal -->
      <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; border-left: 1px solid #e2e8f0; padding-left: 20px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <label style="font-weight: 500; font-size: 13px; white-space: nowrap;">Protocol:</label>
          <select id="protocol-type" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #ddd; font-size: 13px;">
            <option value="single">1st Tee Start</option>
            <option value="twotee">Two Tee Start</option>
            <option value="shotgun">Shotgun</option>
          </select>
        </div>
        <div id="alternate-tee-group" style="display: none; align-items: center; gap: 8px;">
          <label style="font-weight: 500; font-size: 13px; white-space: nowrap;">Alt Tee:</label>
          <input type="number" id="alternate-tee" value="10" min="1" max="18" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #ddd; width: 60px; font-size: 13px;">
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <label style="font-weight: 500; font-size: 13px; white-space: nowrap;">Start:</label>
          <input type="time" id="start-time" value="08:00" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #ddd; font-size: 13px;">
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <label style="font-weight: 500; font-size: 13px; white-space: nowrap;">Interval:</label>
          <input type="number" id="interval" value="10" min="1" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #ddd; width: 60px; font-size: 13px;">
          <span style="font-size: 12px; color: #666;">min</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <label style="font-weight: 500; font-size: 13px; white-space: nowrap;">Group Size:</label>
          <select id="group-size" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #ddd; font-size: 13px;">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4" selected>4</option>
          </select>
        </div>
        <button onclick="applyConfiguration()" style="padding: 6px 14px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 13px;">Apply</button>
      </div>
    </div>

    <div id="draw-content" style="display: none;">
      <div class="draw-container">
        <!-- Left Panel: Groups -->
        <div class="left-panel">
          <div class="groups-area">
            <div class="groups-header">
              <h3>Starting Groups</h3>
            </div>
            <div id="groups-container" class="groups-grid"></div>
          </div>
        </div>

        <!-- Right Panel: Players -->
        <div class="right-panel">
          <div class="players-list" style="position: sticky; top: 130px; max-height: calc(100vh - 150px); overflow-y: auto;">
            <h3>Available Players (<span id="player-count">0</span>)</h3>
            <div id="players-container"></div>
          </div>
        </div>
      </div>
    </div>

    <div id="no-round" style="display: none; text-align: center; padding: 50px; color: #999;">
      <p style="font-size: 18px;">Please select a round to create the draw.</p>
    </div>
  </div>

  <script>
    let currentTournament = null;
    let currentRound = null;
    let currentRoundData = null;
    let admittedPlayers = [];
    let groups = [];
    let draggedPlayer = null;
    let isPairingMode = false; // True for fourball/foursomes match play
    let pairings = []; // Pairings for the current team/round
    let draggedPairing = null; // For dragging pairings instead of players
    let pinnedGroups = new Set(); // Track pinned group indices (0-based)

    // Toggle pin status for a group
    function toggleGroupPin(groupIndex) {
      if (pinnedGroups.has(groupIndex)) {
        pinnedGroups.delete(groupIndex);
        console.log(`Group ${groupIndex + 1} unpinned`);
      } else {
        pinnedGroups.add(groupIndex);
        console.log(`Group ${groupIndex + 1} pinned`);
      }
      renderGroups();
    }

    // Format date as dd.mm.yyyy
    function formatDateDDMMYYYY(dateStr) {
      if (!dateStr) return '';
      const d = new Date(dateStr);
      const day = String(d.getDate()).padStart(2, '0');
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const year = d.getFullYear();
      return `${day}.${month}.${year}`;
    }
    let draggedFromGroupId = null;

    // Load data from Firebase before initializing
    async function loadFromFirebase() {
      // Wait for Firebase to be ready
      let attempts = 0;
      while (!syncEnabled && attempts < 10) {
        await new Promise(resolve => setTimeout(resolve, 200));
        attempts++;
      }
      
      if (syncEnabled) {
        try {
          // Load tournaments
          if (typeof loadTournamentsFromFirebase !== 'undefined') {
            await loadTournamentsFromFirebase();
            console.log('‚úì Tournaments loaded from Firebase');
          }
          // Load players
          if (typeof loadPlayersFromFirebase !== 'undefined') {
            await loadPlayersFromFirebase();
            console.log('‚úì Players loaded from Firebase');
          }
          // Load admitted players
          const admittedData = await syncFromFirebase('admittedPlayers');
          if (admittedData) {
            localStorage.setItem('admittedPlayers', JSON.stringify(admittedData));
            console.log('‚úì Admitted players loaded from Firebase');
          }
          // Load draws
          const drawsData = await syncFromFirebase('draws');
          if (drawsData) {
            localStorage.setItem('draws', JSON.stringify(drawsData));
            console.log('‚úì Draws loaded from Firebase');
          }
        } catch(e) {
          console.log('Firebase load error:', e);
        }
      }
    }

    // Load tournament and rounds
    async function init() {
      // Load data from Firebase first
      await loadFromFirebase();
      
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');
      
      if (!tournamentId) {
        alert('No tournament selected');
        window.location.href = 'index.html';
        return;
      }

      const tournaments = JSON.parse(localStorage.getItem('tournaments') || '[]');
      currentTournament = tournaments.find(t => t.tournamentId === tournamentId);
      
      if (!currentTournament) {
        alert('Tournament not found');
        window.location.href = 'index.html';
        return;
      }

      // Populate round selector
      const roundSelect = document.getElementById('round-select');
      console.log('Tournament:', currentTournament);
      console.log('Meta:', currentTournament.meta);
      
      if (currentTournament.meta && currentTournament.meta.rounds > 1) {
        console.log('Rounds data:', currentTournament.meta.roundsData);
        console.log('Round IDs:', currentTournament.meta.roundIds);
        
        currentTournament.meta.roundsData.forEach((round, index) => {
          const option = document.createElement('option');
          // Use roundId from roundIds array or round object
          const roundId = currentTournament.meta.roundIds?.[index] || round.roundId || `${currentTournament.tournamentId}_R${index + 1}`;
          option.value = roundId;
          option.textContent = `Round ${index + 1}: ${round.date ? formatDateDDMMYYYY(round.date) : 'TBD'}`;
          console.log(`Created option: value="${roundId}", text="${option.textContent}"`);
          roundSelect.appendChild(option);
        });
      } else {
        // Single round tournament - use roundId from meta.roundIds if available
        const option = document.createElement('option');
        const roundId = currentTournament.meta?.roundIds?.[0] || `${currentTournament.tournamentId}-1`;
        option.value = roundId;
        option.textContent = `Single Round: ${currentTournament.date ? formatDateDDMMYYYY(currentTournament.date) : 'TBD'}`;
        console.log(`Created single round option: value="${roundId}"`);
        roundSelect.appendChild(option);
      }

      roundSelect.addEventListener('change', loadRound);
      
      // Auto-select round based on current date or first available round
      if (roundSelect.options.length > 1) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        let selectedIndex = 1; // Default to first round
        
        if (currentTournament.meta && currentTournament.meta.rounds > 1) {
          // Multi-round tournament: find appropriate round based on date
          for (let i = 0; i < currentTournament.meta.roundsData.length; i++) {
            const roundDate = new Date(currentTournament.meta.roundsData[i].date);
            roundDate.setHours(0, 0, 0, 0);
            
            if (today >= roundDate) {
              selectedIndex = i + 1; // +1 because index 0 is placeholder
            } else {
              break; // Stop at first future round
            }
          }
        }
        
        roundSelect.selectedIndex = selectedIndex;
        loadRound();
      }

      // Setup protocol type change listener
      document.getElementById('protocol-type').addEventListener('change', (e) => {
        const alternateTeeGroup = document.getElementById('alternate-tee-group');
        
        if (e.target.value === 'twotee') {
          alternateTeeGroup.style.display = 'flex';
        } else {
          alternateTeeGroup.style.display = 'none';
        }
        
        applyConfiguration();
      });

      // Setup alternate tee change listener
      document.getElementById('alternate-tee').addEventListener('change', applyConfiguration);
    }

    // Load round data
    function loadRound() {
      const roundSelect = document.getElementById('round-select');
      const roundId = roundSelect.value;
      
      console.log('Round select value:', roundId);
      console.log('All admittedPlayers keys:', Object.keys(JSON.parse(localStorage.getItem('admittedPlayers') || '{}')));
      
      if (!roundId || roundId === '') {
        document.getElementById('draw-content').style.display = 'none';
        document.getElementById('no-round').style.display = 'block';
        return;
      }

      currentRound = roundId;
      
      // Load admitted players for this round
      const allAdmittedPlayers = JSON.parse(localStorage.getItem('admittedPlayers') || '{}');
      const roundPlayers = allAdmittedPlayers[roundId] || [];
      
      // Check if roundPlayers contains full player objects or just reg numbers
      console.log('Round ID:', roundId);
      console.log('Round Players from storage:', roundPlayers);
      console.log('Type of first element:', roundPlayers.length > 0 ? typeof roundPlayers[0] : 'none');
      console.log('First element:', roundPlayers.length > 0 ? roundPlayers[0] : 'none');
      
      if (roundPlayers.length > 0 && typeof roundPlayers[0] === 'object' && roundPlayers[0] !== null) {
        // Already full player objects
        admittedPlayers = roundPlayers;
        console.log('Using player objects directly');
      } else {
        // Just reg numbers, need to fetch full player objects
        console.log('Fetching players from players list');
        const allPlayers = JSON.parse(localStorage.getItem('players') || '[]');
        admittedPlayers = roundPlayers.map(reg => 
          allPlayers.find(p => p.reg === reg)
        ).filter(p => p);
      }
      
      console.log('Admitted players loaded:', admittedPlayers.length, admittedPlayers);

      // Load existing draw if available
      const savedDraws = JSON.parse(localStorage.getItem('draws') || '{}');
      const savedDraw = savedDraws[roundId];
      
      if (savedDraw && savedDraw.groups && savedDraw.groups.length > 0) {
        groups = savedDraw.groups;
        
        // Merge fresh admitted player data into saved groups
        // This ensures tee/category changes are reflected
        const admittedByReg = {};
        admittedPlayers.forEach(p => { if (p.reg) admittedByReg[p.reg] = p; });
        groups.forEach(group => {
          group.players = group.players.map(drawPlayer => {
            const freshPlayer = admittedByReg[drawPlayer.reg];
            if (freshPlayer) {
              // Merge: keep draw-specific data, update player data from admissions
              return {...drawPlayer, ...freshPlayer};
            }
            return drawPlayer;
          });
        });
        
        document.getElementById('protocol-type').value = savedDraw.protocol || 'single';
        document.getElementById('start-time').value = savedDraw.startTime || '08:00';
        document.getElementById('interval').value = savedDraw.interval || 10;
        document.getElementById('group-size').value = savedDraw.groupSize || 4;
      } else {
        // Create default 24 groups
        const protocol = document.getElementById('protocol-type').value || 'single';
        const startTime = document.getElementById('start-time').value || '08:00';
        const interval = parseInt(document.getElementById('interval').value) || 10;
        
        groups = [];
        for (let i = 0; i < 24; i++) {
          groups.push({
            groupId: `group-${Date.now()}-${i}`,
            players: [],
            time: calculateStartTime(i, protocol, startTime, interval),
            tee: calculateTee(i, protocol)
          });
        }
      }

      // Detect if this round is fourball/foursomes match play
      isPairingMode = false;
      pairings = [];
      currentRoundData = null;
      
      // Get round data to check match type
      const roundIds = currentTournament.meta?.roundIds || [];
      const roundIndex = roundIds.indexOf(roundId);
      if (roundIndex >= 0 && currentTournament.meta?.roundsData) {
        currentRoundData = currentTournament.meta.roundsData[roundIndex];
      } else if (currentTournament.meta?.roundsData?.[0]) {
        currentRoundData = currentTournament.meta.roundsData[0];
      }
      
      console.log('Current round data:', currentRoundData);
      
      if (currentRoundData) {
        const matchType = (currentRoundData.matchType || '').toLowerCase();
        console.log('Match type:', matchType);
        
        if (matchType === 'fourball' || matchType === 'foursomes') {
          isPairingMode = true;
          console.log('Pairing mode enabled for', matchType);
          
          // Load teams to get team names
          const teams = currentTournament.teams || [];
          
          // Load pairings from tournament.teamPairings[roundId]
          if (currentTournament.teamPairings && currentTournament.teamPairings[roundId]) {
            const teamPairingsData = currentTournament.teamPairings[roundId];
            console.log('Team pairings data:', teamPairingsData);
            
            // Flatten all team pairings into a single array
            // teamPairingsData is { teamIndex: [[player1, player2], [player3, player4]] }
            Object.keys(teamPairingsData).forEach(teamIndex => {
              const teamPairs = teamPairingsData[teamIndex];
              const teamName = teams[parseInt(teamIndex)]?.name || `Team ${parseInt(teamIndex) + 1}`;
              if (Array.isArray(teamPairs)) {
                teamPairs.forEach((pair, pairIndex) => {
                  if (pair && pair.length === 2) {
                    pairings.push({
                      pairingId: `pairing-${teamIndex}-${pairIndex}`,
                      teamIndex: parseInt(teamIndex),
                      teamName: teamName,
                      players: pair
                    });
                  }
                });
              }
            });
            console.log('Loaded pairings:', pairings);
          }
          
          // In pairing mode, force group size to 4 (2 pairs per group) and disable selection
          document.getElementById('group-size').value = '4';
          document.getElementById('group-size').disabled = true;
          document.getElementById('modal-group-size').value = '4';
          document.getElementById('modal-group-size').disabled = true;
        }
      }
      
      // Re-enable group size if not in pairing mode
      if (!isPairingMode) {
        document.getElementById('group-size').disabled = false;
        document.getElementById('modal-group-size').disabled = false;
      }

      document.getElementById('draw-content').style.display = 'block';
      document.getElementById('no-round').style.display = 'none';
      
      renderPlayers();
      renderGroups();
    }

    // Calculate age
    function calculateAge(dob) {
      if (!dob) return '-';
      const birthDate = new Date(dob);
      const referenceDate = new Date(new Date().getFullYear(), 0, 1);
      let age = referenceDate.getFullYear() - birthDate.getFullYear();
      return age;
    }

    // Get tee data for pHCP calculation
    function getTeeData(player) {
      if (!currentTournament || !currentTournament.meta) return null;
      
      const roundIds = currentTournament.meta.roundIds || [];
      const roundIndex = roundIds.indexOf(currentRound);
      const roundData = currentTournament.meta.roundsData?.[roundIndex >= 0 ? roundIndex : 0];
      if (!roundData) return null;
      
      const playerGender = (player.gender || '').toLowerCase();
      let teeValue = '';
      
      console.log(`getTeeData for ${player.firstName}: player.tee = "${player.tee}", roundData.course = "${roundData.course}"`);
      
      // Check if player has an assigned tee (from categories)
      if (player.tee) {
        // Convert tee ID to courseId||teeIndex format by looking up in course.teeIds
        const courses = JSON.parse(localStorage.getItem('courses') || '[]');
        const courseId = roundData.course;
        const course = courses.find(c => c.courseId === courseId);
        
        console.log(`  course found: ${!!course}, teeIds: ${JSON.stringify(course?.teeIds)}`);
        
        if (course && course.teeIds) {
          const idx = course.teeIds.findIndex(id => {
            if (typeof id === 'object') {
              return id.men === player.tee || id.women === player.tee;
            }
            return id === player.tee;
          });
          
          console.log(`  teeIds lookup result: idx = ${idx}`);
          
          if (idx !== -1) {
            teeValue = `${courseId}||${idx}`;
          }
        }
        
        // If player.tee is already in courseId||index format, use it directly
        if (!teeValue && player.tee.includes('||')) {
          teeValue = player.tee;
        }
      }
      
      // If no assigned tee found, use default from tournament settings
      if (!teeValue) {
        console.log(`  No tee found, using default. teeMen=${roundData.teeMen}, teeWomen=${roundData.teeWomen}`);
        if (playerGender === 'male' || playerGender === 'm') {
          teeValue = roundData.teeMen || '';
        } else if (playerGender === 'female' || playerGender === 'f') {
          teeValue = roundData.teeWomen || '';
        }
      }
      
      console.log(`  Final teeValue: "${teeValue}"`);
      
      if (!teeValue || !teeValue.includes('||')) return null;
      
      const [courseId, teeIndexStr] = teeValue.split('||');
      const teeIndex = parseInt(teeIndexStr, 10);
      
      const courses = JSON.parse(localStorage.getItem('courses') || '[]');
      const course = courses.find(c => c.courseId === courseId);
      
      if (!course) return null;
      
      let par = 0;
      if (course.pars && Array.isArray(course.pars)) {
        par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
      }
      
      const teeData = course.teeData?.[teeIndex];
      if (!teeData) return null;
      
      let slope, rating;
      const teeGender = course.genders?.[teeIndex];
      if (teeGender === 'B' && teeData.ratings) {
        if (playerGender === 'male' || playerGender === 'm') {
          slope = teeData.ratings.men?.slope18;
          rating = teeData.ratings.men?.rating18;
        } else if (playerGender === 'female' || playerGender === 'f') {
          slope = teeData.ratings.women?.slope18;
          rating = teeData.ratings.women?.rating18;
        }
      } else {
        slope = teeData.slope18 || teeData.slope;
        rating = teeData.rating18 || teeData.rating;
      }
      
      return { slope, rating, par };
    }

    // Calculate playing HCP dynamically
    function getPlayingHcp(player) {
      const playerHcp = parseFloat(player.hcp);
      if (isNaN(playerHcp)) return '-';
      
      const teeData = getTeeData(player);
      if (!teeData || !teeData.slope || !teeData.rating || !teeData.par) {
        return playerHcp;
      }
      
      const hcpAllowance = parseFloat(currentTournament?.meta?.hcpAllow || 100) / 100;
      const slope = parseFloat(teeData.slope);
      const rating = parseFloat(teeData.rating);
      const par = parseFloat(teeData.par);
      
      if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
        return playerHcp;
      }
      
      const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
      const rounded = Math.round(playingHcp);
      
      return rounded < 0 ? '+' + Math.abs(rounded) : rounded;
    }

    // Render available players (or pairings in pairing mode)
    function renderPlayers() {
      const container = document.getElementById('players-container');
      const assignedRegs = new Set(groups.flatMap(g => g.players.map(p => p.reg)));
      
      // In pairing mode, show pairings instead of individual players
      if (isPairingMode) {
        // Filter out pairings where both players are already assigned
        const availablePairings = pairings.filter(pairing => {
          const player1Assigned = assignedRegs.has(pairing.players[0]?.playerId);
          const player2Assigned = assignedRegs.has(pairing.players[1]?.playerId);
          return !player1Assigned && !player2Assigned;
        });
        
        document.getElementById('player-count').textContent = `${availablePairings.length} pairings`;
        
        if (availablePairings.length === 0) {
          container.innerHTML = '<div class="empty-state">All pairings assigned</div>';
          return;
        }
        
        container.innerHTML = availablePairings.map(pairing => {
          const p1 = pairing.players[0];
          const p2 = pairing.players[1];
          return `
          <div class="player-card pairing-card" draggable="true" data-pairing-id="${pairing.pairingId}" style="background: linear-gradient(135deg, #e0f2fe 50%, #fce7f3 50%); border-left: 4px solid #7c3aed;">
            <div style="font-size: 10px; font-weight: 600; color: #7c3aed; margin-bottom: 4px; border-bottom: 1px solid #e2e8f0; padding-bottom: 4px;">üè∑Ô∏è ${pairing.teamName}</div>
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 10px; color: #0284c7;">üë§</span>
                <span class="player-name" style="margin: 0; font-size: 12px;">${p1?.name || 'Unknown'}</span>
                <span style="font-size: 10px; color: #666;">HCP ${p1?.hcp || '-'}</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 10px; color: #ec4899;">üë§</span>
                <span class="player-name" style="margin: 0; font-size: 12px;">${p2?.name || 'Unknown'}</span>
                <span style="font-size: 10px; color: #666;">HCP ${p2?.hcp || '-'}</span>
              </div>
            </div>
          </div>
        `;}).join('');
        
        // Add drag event listeners for pairings
        container.querySelectorAll('.pairing-card').forEach(card => {
          card.addEventListener('dragstart', handlePairingDragStart);
          card.addEventListener('dragend', handlePairingDragEnd);
        });
        return;
      }
      
      // Normal mode - show individual players
      const availablePlayers = admittedPlayers.filter(p => !assignedRegs.has(p.reg));
      
      document.getElementById('player-count').textContent = availablePlayers.length;
      
      if (availablePlayers.length === 0) {
        container.innerHTML = '<div class="empty-state">All players assigned</div>';
        return;
      }
      
      container.innerHTML = availablePlayers.map(player => {
        const gender = (player.gender || '').toLowerCase();
        const genderClass = (gender === 'male' || gender === 'm') ? 'male' : (gender === 'female' || gender === 'f') ? 'female' : '';
        return `
        <div class="player-card ${genderClass}" draggable="true" data-reg="${player.reg}">
          <div class="player-name" style="margin: 0;">${player.firstName} ${player.lastName}</div>
          <div style="font-weight: 400; font-size: 11px; color: #666; white-space: nowrap;">${player.club || player.homeClub || '-'} / HCP ${getPlayingHcp(player)} / ${calculateAge(player.dob)}yrs</div>
        </div>
      `;}).join('');
      
      // Add drag event listeners
      container.querySelectorAll('.player-card').forEach(card => {
        card.addEventListener('dragstart', handleDragStart);
        card.addEventListener('dragend', handleDragEnd);
      });
    }

    // Drag handlers for pairings
    function handlePairingDragStart(e) {
      const pairingId = e.target.getAttribute('data-pairing-id') || e.target.closest('[data-pairing-id]')?.getAttribute('data-pairing-id');
      draggedPairing = pairings.find(p => p.pairingId === pairingId);
      draggedPlayer = null;
      draggedFromGroupId = null;
      
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('type', 'pairing');
    }

    function handlePairingDragEnd(e) {
      e.target.classList.remove('dragging');
      draggedPairing = null;
    }

    // Apply configuration and generate groups
    function applyConfiguration() {
      const groupSize = parseInt(document.getElementById('group-size').value);
      const protocol = document.getElementById('protocol-type').value;
      const startTime = document.getElementById('start-time').value;
      const interval = parseInt(document.getElementById('interval').value);
      
      // If no groups exist, create 20 empty groups
      if (groups.length === 0) {
        for (let i = 0; i < 20; i++) {
          groups.push({
            groupId: `group-${Date.now()}-${i}`,
            players: [],
            time: calculateStartTime(i, protocol, startTime, interval),
            tee: calculateTee(i, protocol)
          });
        }
      } else {
        // Keep the same number of groups and update their times/tees
        for (let i = 0; i < groups.length; i++) {
          groups[i].time = calculateStartTime(i, protocol, startTime, interval);
          groups[i].tee = calculateTee(i, protocol);
        }
      }
      
      renderGroups();
    }

    // Calculate start time for group
    function calculateStartTime(index, protocol, startTime, interval) {
      if (protocol === 'shotgun') {
        return startTime;
      }
      
      const [hours, minutes] = startTime.split(':').map(Number);
      let intervalMultiplier = index;
      
      // For two-tee start, groups alternate between tees, so time progresses by pairs
      if (protocol === 'twotee') {
        intervalMultiplier = Math.floor(index / 2);
      }
      
      const totalMinutes = hours * 60 + minutes + (intervalMultiplier * interval);
      const newHours = Math.floor(totalMinutes / 60);
      const newMinutes = totalMinutes % 60;
      
      return `${String(newHours).padStart(2, '0')}:${String(newMinutes).padStart(2, '0')}`;
    }

    // Calculate tee for group
    function calculateTee(index, protocol) {
      if (protocol === 'single') return '1st Tee';
      if (protocol === 'twotee') {
        const alternateTee = parseInt(document.getElementById('alternate-tee').value) || 10;
        return index % 2 === 0 ? '1st Tee' : `${alternateTee}th Tee`;
      }
      if (protocol === 'shotgun') return `Hole ${(index % 18) + 1}`;
      return '1st Tee';
    }

    // Render players in a group (handles both normal and pairing mode)
    function renderGroupPlayers(group) {
      if (group.players.length === 0) {
        if (isPairingMode) {
          return '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">Drop pairings here<br><small>(2 pairings per group)</small></div>';
        }
        return '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px;">Drop players here</div>';
      }
      
      if (isPairingMode) {
        // Group players by pairingId and render as pairs
        const playersByPairing = {};
        group.players.forEach(player => {
          const pairingId = player.pairingId || 'unknown';
          if (!playersByPairing[pairingId]) {
            playersByPairing[pairingId] = { players: [], teamName: player.teamName };
          }
          playersByPairing[pairingId].players.push(player);
        });
        
        return Object.entries(playersByPairing).map(([pairingId, data]) => `
          <div class="group-pairing-card" style="background: linear-gradient(135deg, #e0f2fe 50%, #fce7f3 50%); border: 1px solid #ddd; border-left: 4px solid #7c3aed; border-radius: 4px; padding: 8px; margin-bottom: 6px; position: relative;">
            <button class="remove-player" onclick="removePairingFromGroup('${group.groupId}', '${pairingId}')" style="display: block;">√ó</button>
            <div style="font-size: 9px; font-weight: 600; color: #7c3aed; margin-bottom: 4px;">üè∑Ô∏è ${data.teamName || 'Team'}</div>
            ${data.players.map(player => `
              <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 2px;">
                <span style="font-weight: 600; font-size: 11px;">${player.firstName || ''} ${player.lastName || player.name || ''}</span>
                <span style="font-size: 9px; color: #666;">HCP ${player.hcp || '-'}</span>
              </div>
            `).join('')}
          </div>
        `).join('');
      }
      
      // Normal mode - render individual players
      return group.players.map(player => {
        const gender = (player.gender || '').toLowerCase();
        const genderClass = (gender === 'male' || gender === 'm') ? 'male' : (gender === 'female' || gender === 'f') ? 'female' : '';
        return `
          <div class="group-player-card ${genderClass}" draggable="true" data-reg="${player.reg}">
            <button class="remove-player" onclick="removeFromGroup('${group.groupId}', '${player.reg}')">√ó</button>
            <div style="font-weight: 600; font-size: 12px;">${player.firstName} ${player.lastName}</div>
            <div style="font-weight: 400; font-size: 10px; color: #666; white-space: nowrap;">${player.club || player.homeClub || '-'} / HCP ${getPlayingHcp(player)} / ${calculateAge(player.dob)}yrs</div>
          </div>
        `;
      }).join('');
    }

    // Remove a pairing (both players) from a group
    function removePairingFromGroup(groupId, pairingId) {
      const group = groups.find(g => g.groupId === groupId);
      if (group) {
        group.players = group.players.filter(p => p.pairingId !== pairingId);
        renderGroups();
      }
    }

    // Render groups - always show 24 group boxes
    function renderGroups() {
      const container = document.getElementById('groups-container');
      const protocol = document.getElementById('protocol-type').value;
      const startTime = document.getElementById('start-time').value;
      const interval = parseInt(document.getElementById('interval').value) || 10;
      const MIN_GROUPS = 24; // Minimum number of group boxes to show
      
      // Ensure we always have at least 24 groups (but can have more)
      while (groups.length < MIN_GROUPS) {
        groups.push({
          groupId: `group-${Date.now()}-${groups.length}`,
          players: [],
          time: calculateStartTime(groups.length, protocol, startTime, interval),
          tee: calculateTee(groups.length, protocol)
        });
      }
      
      // Display ALL groups (not capped at 24)
      let displayGroups = [...groups];
      let isTwoTee = false;
      
      // For two-tee layout, keep track of original indices
      if (protocol === 'twotee') {
        isTwoTee = true;
        displayGroups = [];
        // Add all even-indexed groups (1st tee: 0, 2, 4...)
        for (let i = 0; i < groups.length; i += 2) {
          displayGroups.push({ ...groups[i], originalIndex: i, teeType: '1st' });
        }
        // Add all odd-indexed groups (alternate tee: 1, 3, 5...)
        for (let i = 1; i < groups.length; i += 2) {
          displayGroups.push({ ...groups[i], originalIndex: i, teeType: 'alt' });
        }
      }
      
      // For two-tee, split HTML into two sections
      if (isTwoTee) {
        const firstTeeGroups = displayGroups.filter(g => g.teeType === '1st');
        const altTeeGroups = displayGroups.filter(g => g.teeType === 'alt');
        
        const groupsHTML = (groupsList) => groupsList.map((group) => {
          const originalIndex = group.originalIndex;
          const isPinned = pinnedGroups.has(originalIndex);
          const pinnedClass = isPinned ? 'pinned-group' : 'draggable-group';
          const pinBtnText = isPinned ? 'üìå Pinned' : 'üìå Pin';
          const draggable = isPinned ? 'false' : 'true';
          
          return `
            <div class="group-box ${pinnedClass}" data-group-id="${group.groupId}" data-group-index="${originalIndex}" draggable="${draggable}">
              <div class="group-header">
                <div class="group-title">Group ${originalIndex + 1}</div>
                <button class="pin-group-btn" onclick="event.stopPropagation(); toggleGroupPin(${originalIndex})">${pinBtnText}</button>
                <div class="group-time">${group.time}</div>
              </div>
              <div class="group-players">
                ${renderGroupPlayers(group)}
              </div>
            </div>
          `;
        }).join('');
        
        container.innerHTML = `
          <div style="display: flex; gap: 40px;">
            <div>
              <h3 style="color: #333; margin-top: 0; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #28a745; padding-bottom: 10px;">1st Tee (${firstTeeGroups.length} groups)</h3>
              <div style="display: grid; grid-template-columns: repeat(2, 250px); gap: 15px;">
                ${groupsHTML(firstTeeGroups)}
              </div>
            </div>
            <div>
              <h3 style="color: #333; margin-top: 0; margin-bottom: 15px; font-size: 16px; border-bottom: 2px solid #0b6efd; padding-bottom: 10px;">Alternative Tee (${altTeeGroups.length} groups)</h3>
              <div style="display: grid; grid-template-columns: repeat(2, 250px); gap: 15px;">
                ${groupsHTML(altTeeGroups)}
              </div>
            </div>
          </div>
        `;
        
        // Expand the draw container to accommodate two side-by-side sections with same-width boxes
        const drawContainer = document.querySelector('.draw-container');
        if (drawContainer) {
          drawContainer.style.maxWidth = 'none';
          drawContainer.style.width = 'calc(100vw - 60px)';
        }
      } else {
        // Reset draw container width for single tee mode
        const drawContainer = document.querySelector('.draw-container');
        if (drawContainer) {
          drawContainer.style.maxWidth = '';
          drawContainer.style.width = '';
        }
        
        // Standard layout with drop zones between groups
        let html = '';
        displayGroups.forEach((group, displayIndex) => {
          const isPinned = pinnedGroups.has(displayIndex);
          const pinnedClass = isPinned ? 'pinned-group' : 'draggable-group';
          const pinBtnText = isPinned ? 'üìå Pinned' : 'üìå Pin';
          const draggable = isPinned ? 'false' : 'true';
          
          html += `
            <div class="group-box ${pinnedClass}" data-group-id="${group.groupId}" data-group-index="${displayIndex}" draggable="${draggable}">
              <div class="group-header">
                <div class="group-title">Group ${displayIndex + 1}</div>
                <button class="pin-group-btn" onclick="event.stopPropagation(); toggleGroupPin(${displayIndex})">${pinBtnText}</button>
                <div class="group-time">${group.time} - ${group.tee}</div>
              </div>
              <div class="group-players">
                ${renderGroupPlayers(group)}
              </div>
            </div>
          `;
        });
        
        container.innerHTML = html;
      }
      
      // Add drop event listeners
      container.querySelectorAll('.group-box').forEach(box => {
        box.addEventListener('dragover', handleDragOver);
        box.addEventListener('drop', handleDrop);
        box.addEventListener('dragleave', handleDragLeave);
        // Add click to select group
        box.addEventListener('click', (e) => {
          // Don't select if clicking on a player card or remove button
          if (e.target.closest('.group-player-card') || e.target.closest('.group-pairing-card') || e.target.closest('.remove-player')) return;
          selectGroup(box.getAttribute('data-group-id'));
        });
        
        // Add group drag listeners (for non-pinned groups)
        if (box.classList.contains('draggable-group')) {
          box.addEventListener('dragstart', handleGroupDragStart);
          box.addEventListener('dragend', handleGroupDragEnd);
        }
        
        // Add group drop listeners for reordering (detect left/right side)
        box.addEventListener('dragover', handleGroupDragOverForReorder);
        box.addEventListener('dragleave', handleGroupDragLeaveForReorder);
        box.addEventListener('drop', handleGroupDropForReorder);
      });
      
      // Add drag listeners for players in groups (only in normal mode)
      if (!isPairingMode) {
        container.querySelectorAll('.group-player-card').forEach(card => {
          card.addEventListener('dragstart', handleDragStart);
          card.addEventListener('dragend', handleDragEnd);
        });
      }
      
      // Highlight selected group
      if (selectedGroupId) {
        const selectedBox = container.querySelector(`[data-group-id="${selectedGroupId}"]`);
        if (selectedBox) {
          selectedBox.classList.add('selected-group');
        }
      }
      renderPlayers();
    }

    // Track dragged group
    let draggedGroupIndex = null;

    // Group drag handlers
    function handleGroupDragStart(e) {
      // Don't start if clicking on pin button or player card
      if (e.target.closest('.pin-group-btn') || e.target.closest('.group-player-card')) {
        e.preventDefault();
        return;
      }
      
      const groupIndex = parseInt(e.currentTarget.getAttribute('data-group-index'));
      
      // Don't allow dragging pinned groups
      if (pinnedGroups.has(groupIndex)) {
        e.preventDefault();
        return;
      }
      
      draggedGroupIndex = groupIndex;
      e.currentTarget.classList.add('dragging-group');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', 'group'); // Mark as group drag
    }
    
    function handleGroupDragEnd(e) {
      e.currentTarget.classList.remove('dragging-group');
      draggedGroupIndex = null;
      
      // Clear all drop indicators
      document.querySelectorAll('.group-box').forEach(box => {
        box.classList.remove('drop-left', 'drop-right', 'drop-blocked-indicator');
      });
    }
    
    // Handle drag over group box for reordering (detect left/right side)
    function handleGroupDragOverForReorder(e) {
      // Only handle if dragging a group
      if (draggedGroupIndex === null) return;
      
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      const targetIndex = parseInt(e.currentTarget.getAttribute('data-group-index'));
      
      // Don't show indicator on the dragged group itself
      if (targetIndex === draggedGroupIndex) return;
      
      // Determine if we're on the left or right half of the target
      const rect = e.currentTarget.getBoundingClientRect();
      const midpoint = rect.left + rect.width / 2;
      const isLeftSide = e.clientX < midpoint;
      
      // Calculate where we would drop
      const dropIndex = isLeftSide ? targetIndex : targetIndex + 1;
      
      // Clear previous indicators
      document.querySelectorAll('.group-box').forEach(box => {
        box.classList.remove('drop-left', 'drop-right', 'drop-blocked-indicator');
      });
      
      // Check if dropping at a pinned group's position
      if (pinnedGroups.has(dropIndex)) {
        e.currentTarget.classList.add('drop-blocked-indicator');
      } else {
        e.currentTarget.classList.add(isLeftSide ? 'drop-left' : 'drop-right');
      }
    }
    
    function handleGroupDragLeaveForReorder(e) {
      e.currentTarget.classList.remove('drop-left', 'drop-right', 'drop-blocked-indicator');
    }
    
    function handleGroupDropForReorder(e) {
      // Only handle if dragging a group
      if (draggedGroupIndex === null) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const targetIndex = parseInt(e.currentTarget.getAttribute('data-group-index'));
      
      // Don't do anything if dropping on itself
      if (targetIndex === draggedGroupIndex) return;
      
      // Clear indicators
      document.querySelectorAll('.group-box').forEach(box => {
        box.classList.remove('drop-left', 'drop-right', 'drop-blocked-indicator');
      });
      
      // Determine if we're on the left or right half
      const rect = e.currentTarget.getBoundingClientRect();
      const midpoint = rect.left + rect.width / 2;
      const isLeftSide = e.clientX < midpoint;
      
      // Calculate drop position
      const dropIndex = isLeftSide ? targetIndex : targetIndex + 1;
      
      // Don't allow dropping at a pinned group's position
      if (pinnedGroups.has(dropIndex)) {
        alert(`Cannot move group to position ${dropIndex + 1} because it is occupied by a pinned group.`);
        return;
      }
      
      // Same position or adjacent - no change needed
      if (dropIndex === draggedGroupIndex || dropIndex === draggedGroupIndex + 1) {
        return;
      }
      
      moveGroupToPosition(draggedGroupIndex, dropIndex);
    }
    
    // Move a group to a new position, respecting pinned groups
    function moveGroupToPosition(fromIndex, toIndex) {
      const protocol = document.getElementById('protocol-type').value;
      const startTime = document.getElementById('start-time').value;
      const interval = parseInt(document.getElementById('interval').value);
      
      // Get the group being moved
      const movingGroup = groups[fromIndex];
      
      // Collect all groups: pinned stay in place, others will be rearranged
      const nonPinnedGroups = [];
      for (let i = 0; i < groups.length; i++) {
        if (!pinnedGroups.has(i) && i !== fromIndex) {
          nonPinnedGroups.push(groups[i]);
        }
      }
      
      // Calculate where in the non-pinned sequence to insert
      // Adjust toIndex if moving to a later position (since we removed one)
      let adjustedToIndex = toIndex;
      if (fromIndex < toIndex) {
        adjustedToIndex--;
      }
      
      // Find the insert position in the non-pinned array
      let nonPinnedInsertIdx = 0;
      for (let i = 0; i < adjustedToIndex; i++) {
        if (!pinnedGroups.has(i)) {
          nonPinnedInsertIdx++;
        }
      }
      
      // Insert the moving group at the calculated position
      nonPinnedGroups.splice(nonPinnedInsertIdx, 0, movingGroup);
      
      // Rebuild the groups array
      const newGroups = [];
      let nonPinnedIdx = 0;
      
      for (let pos = 0; pos < groups.length; pos++) {
        if (pinnedGroups.has(pos)) {
          // Pinned group stays at this position
          newGroups.push(groups[pos]);
        } else {
          // Fill with next non-pinned group
          if (nonPinnedIdx < nonPinnedGroups.length) {
            newGroups.push(nonPinnedGroups[nonPinnedIdx]);
            nonPinnedIdx++;
          }
        }
      }
      
      // Update groups
      groups = newGroups;
      
      // Recalculate times
      groups.forEach((group, index) => {
        group.time = calculateStartTime(index, protocol, startTime, interval);
        group.tee = calculateTee(index, protocol);
      });
      
      renderGroups();
    }

    // Drag handlers (for players)
    function handleDragStart(e) {
      e.stopPropagation(); // Don't trigger group drag
      
      const reg = e.target.getAttribute('data-reg') || e.target.closest('[data-reg]')?.getAttribute('data-reg');
      draggedPlayer = admittedPlayers.find(p => p.reg === reg);
      
      // Track which group the player is being dragged from
      const card = e.target.closest('.player-card, .group-player-card');
      if (card?.closest('.group-box')) {
        draggedFromGroupId = card.closest('.group-box').getAttribute('data-group-id');
      } else {
        draggedFromGroupId = null;
      }
      
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', 'player'); // Mark as player drag
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      draggedFromGroupId = null;
      draggedPlayer = null;
    }

    function handleDragOver(e) {
      // Only handle player drags
      if (draggedGroupIndex !== null) return;
      
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      e.currentTarget.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e) {
      // Only handle player drops
      if (draggedGroupIndex !== null) return;
      
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');
      
      // Handle pairing drop in pairing mode
      if (isPairingMode && draggedPairing) {
        const targetGroupBox = e.currentTarget.closest('.group-box') || e.currentTarget;
        const targetGroupId = targetGroupBox.getAttribute('data-group-id');
        const targetGroup = groups.find(g => g.groupId === targetGroupId);
        
        if (!targetGroup) return;
        
        // In pairing mode, each group holds 2 pairings (4 players)
        // Check if group has space for 2 more players
        if (targetGroup.players.length >= 4) {
          alert('Group is full (max 2 pairings / 4 players)');
          draggedPairing = null;
          return;
        }
        
        // Add both players from the pairing to the group
        const p1 = draggedPairing.players[0];
        const p2 = draggedPairing.players[1];
        
        if (p1) {
          targetGroup.players.push({
            reg: p1.playerId,
            firstName: p1.name?.split(' ')[0] || '',
            lastName: p1.name?.split(' ').slice(1).join(' ') || '',
            name: p1.name,
            hcp: p1.hcp,
            pairingId: draggedPairing.pairingId,
            teamName: draggedPairing.teamName
          });
        }
        if (p2) {
          targetGroup.players.push({
            reg: p2.playerId,
            firstName: p2.name?.split(' ')[0] || '',
            lastName: p2.name?.split(' ').slice(1).join(' ') || '',
            name: p2.name,
            hcp: p2.hcp,
            pairingId: draggedPairing.pairingId,
            teamName: draggedPairing.teamName
          });
        }
        
        draggedPairing = null;
        renderGroups();
        return;
      }
      
      if (!draggedPlayer) return;
      
      // Check if dropping on a player card (for swap) or on empty group space
      const targetCard = e.target.closest('.group-player-card');
      const targetGroupBox = e.currentTarget.closest('.group-box') || e.currentTarget;
      const targetGroupId = targetGroupBox.getAttribute('data-group-id');
      const targetGroup = groups.find(g => g.groupId === targetGroupId);
      
      if (!targetGroup) return;
      
      if (targetCard && targetCard.getAttribute('data-reg')) {
        // Swap with target player
        const targetReg = targetCard.getAttribute('data-reg');
        const targetPlayer = admittedPlayers.find(p => p.reg === targetReg);
        
        if (!targetPlayer || !draggedFromGroupId) return;
        
        const draggedFromGroup = groups.find(g => g.groupId === draggedFromGroupId);
        if (!draggedFromGroup) return;
        
        // Find positions
        const draggedIndex = draggedFromGroup.players.findIndex(p => p.reg === draggedPlayer.reg);
        const targetIndex = targetGroup.players.findIndex(p => p.reg === targetPlayer.reg);
        
        if (draggedIndex === -1 || targetIndex === -1) return;
        
        // Perform swap
        if (draggedFromGroupId === targetGroupId) {
          // Swap within same group
          [draggedFromGroup.players[draggedIndex], draggedFromGroup.players[targetIndex]] = 
          [draggedFromGroup.players[targetIndex], draggedFromGroup.players[draggedIndex]];
        } else {
          // Swap between different groups
          draggedFromGroup.players[draggedIndex] = targetPlayer;
          targetGroup.players[targetIndex] = draggedPlayer;
        }
      } else {
        // Drop on empty space - move player if group has space
        const groupSize = parseInt(document.getElementById('group-size').value);
        
        // Remove from previous group if exists
        groups.forEach(g => {
          g.players = g.players.filter(p => p.reg !== draggedPlayer.reg);
        });
        
        // Add to new group if there's space
        if (targetGroup.players.length < groupSize) {
          targetGroup.players.push(draggedPlayer);
        } else {
          alert(`Group is full (max ${groupSize} players)`);
        }
      }
      
      draggedPlayer = null;
      draggedFromGroupId = null;
      renderGroups();
    }

    // Remove player from group
    function removeFromGroup(groupId, reg) {
      const group = groups.find(g => g.groupId === groupId);
      if (group) {
        group.players = group.players.filter(p => p.reg !== reg);
        renderGroups();
      }
    }

    // Select a group for removal or other actions
    function selectGroup(groupId) {
      if (selectedGroupId === groupId) {
        // Deselect if clicking the same group
        selectedGroupId = null;
      } else {
        selectedGroupId = groupId;
      }
      // Re-render to show selection
      renderGroups();
    }

    // Open auto group modal
    function openAutoGroupModal() {
      // Show pinned groups info if any
      const pinnedInfo = document.getElementById('pinned-players-info');
      const pinnedCount = document.getElementById('pinned-count');
      if (pinnedGroups.size > 0) {
        pinnedInfo.style.display = 'block';
        pinnedCount.textContent = pinnedGroups.size;
      } else {
        pinnedInfo.style.display = 'none';
      }
      
      document.getElementById('auto-group-modal').classList.add('active');
      calculateGroupDistribution();
    }

    // Close auto group modal
    function closeAutoGroupModal() {
      document.getElementById('auto-group-modal').classList.remove('active');
    }

    // Calculate group distribution based on player count and group size
    function calculateGroupDistribution() {
      const groupSize = parseInt(document.getElementById('modal-group-size').value);
      const separateGender = document.getElementById('separate-gender').checked;
      const separateCategories = document.getElementById('separate-categories').checked;
      
      // Get players NOT in pinned groups for distribution calculation
      const playersInPinnedGroups = new Set();
      pinnedGroups.forEach(groupIndex => {
        if (groups[groupIndex]) {
          groups[groupIndex].players.forEach(player => {
            playersInPinnedGroups.add(player.reg);
          });
        }
      });
      const availablePlayersForGrouping = admittedPlayers.filter(p => !playersInPinnedGroups.has(p.reg));
      
      // Get player counts
      let playerCounts = [];
      
      if (separateGender) {
        const males = availablePlayersForGrouping.filter(p => (p.gender || '').toLowerCase() === 'male' || (p.gender || '').toLowerCase() === 'm');
        const females = availablePlayersForGrouping.filter(p => (p.gender || '').toLowerCase() === 'female' || (p.gender || '').toLowerCase() === 'f');
        if (males.length > 0) playerCounts.push({ label: 'Male', count: males.length });
        if (females.length > 0) playerCounts.push({ label: 'Female', count: females.length });
      } else if (separateCategories) {
        const categorized = {};
        availablePlayersForGrouping.forEach(p => {
          const cat = (p.categories && p.categories[0]) || 'Uncategorized';
          if (!categorized[cat]) categorized[cat] = 0;
          categorized[cat]++;
        });
        playerCounts = Object.entries(categorized).map(([cat, count]) => ({ label: cat, count }));
      } else {
        playerCounts = [{ label: 'All Players', count: availablePlayersForGrouping.length }];
      }

      const section = document.getElementById('group-distribution-section');
      const infoDiv = document.getElementById('group-distribution-info');
      const optionsDiv = document.getElementById('group-distribution-options');
      
      // Show distribution for each group
      let infoHTML = '';
      let needsOptions = false;
      
      playerCounts.forEach(pc => {
        const { label, count } = pc;
        const remainder = count % groupSize;
        
        if (remainder === 0) {
          const numGroups = count / groupSize;
          infoHTML += `<div><strong>${label}:</strong> ${count} players ‚Üí ${numGroups} groups of ${groupSize}</div>`;
        } else {
          needsOptions = true;
          const baseGroups = Math.floor(count / groupSize);
          const remainingPlayers = count % groupSize;
          infoHTML += `<div><strong>${label}:</strong> ${count} players (${baseGroups} √ó ${groupSize} + ${remainingPlayers} remaining)</div>`;
        }
      });
      
      infoDiv.innerHTML = infoHTML;
      
      // If we need to show options (remainder exists)
      if (needsOptions) {
        section.style.display = 'block';
        optionsDiv.innerHTML = '';
        
        playerCounts.forEach((pc, idx) => {
          const { label, count } = pc;
          const remainder = count % groupSize;
          
          if (remainder > 0) {
            const options = generateDistributionOptions(count, groupSize);
            
            if (options.length > 0) {
              optionsDiv.innerHTML += `<div style="margin-top: 12px; margin-bottom: 12px;"><strong>${label} - Choose distribution:</strong></div>`;
              
              options.forEach((option, optIdx) => {
                const radioId = `dist-${idx}-${optIdx}`;
                const isChecked = optIdx === 0 ? 'checked' : '';
                optionsDiv.innerHTML += `
                  <div class="distribution-option">
                    <input type="radio" id="${radioId}" name="distribution-${idx}" value='${JSON.stringify(option)}' ${isChecked}>
                    <label for="${radioId}">${option.description}</label>
                  </div>
                `;
              });
            }
          }
        });
      } else {
        section.style.display = 'block';
      }
    }

    // Generate possible distribution options
    function generateDistributionOptions(totalPlayers, preferredSize) {
      const options = [];
      
      // Calculate base distribution
      const baseGroups = Math.floor(totalPlayers / preferredSize);
      const remainder = totalPlayers % preferredSize;
      
      if (remainder === 0) {
        // Perfect division - no options needed
        return [];
      }
      
      // Option 1: Merge remainder into existing groups (if possible)
      if (remainder > 0 && baseGroups > 0) {
        // Can we distribute remainder players into existing groups without exceeding 4?
        const maxPlayersPerGroup = 4;
        const extraSlotsNeeded = remainder;
        const maxExtraSlots = baseGroups * (maxPlayersPerGroup - preferredSize);
        
        if (extraSlotsNeeded <= maxExtraSlots) {
          // Calculate how to distribute
          const groupsToExpand = Math.ceil(remainder / (maxPlayersPerGroup - preferredSize));
          const newSize = preferredSize + Math.ceil(remainder / groupsToExpand);
          
          if (newSize <= 4) {
            options.push({
              description: `${baseGroups} groups: expand ${groupsToExpand} group(s) to include ${remainder} extra player(s)`,
              distribution: [{ size: preferredSize, count: baseGroups - groupsToExpand }, { size: newSize, count: groupsToExpand }].filter(d => d.count > 0)
            });
          }
        }
      }
      
      // Option 2: Create smaller groups with remainder
      if (remainder >= 2) {
        options.push({
          description: `${baseGroups} groups of ${preferredSize} + 1 group of ${remainder}`,
          distribution: [{ size: preferredSize, count: baseGroups }, { size: remainder, count: 1 }]
        });
      }
      
      // Option 3: Split remainder into multiple groups of 2 or 3
      if (remainder >= 4) {
        const groupsOf2 = Math.floor(remainder / 2);
        options.push({
          description: `${baseGroups} groups of ${preferredSize} + ${groupsOf2} groups of 2`,
          distribution: [{ size: preferredSize, count: baseGroups }, { size: 2, count: groupsOf2 }]
        });
      }
      
      if (remainder === 5) {
        options.push({
          description: `${baseGroups} groups of ${preferredSize} + 1 group of 3 + 1 group of 2`,
          distribution: [{ size: preferredSize, count: baseGroups }, { size: 3, count: 1 }, { size: 2, count: 1 }]
        });
      }
      
      // Remove duplicates and invalid options
      return options.filter((opt, idx, self) => 
        idx === self.findIndex(o => o.description === opt.description)
      );
    }

    // Confirm and execute auto grouping
    function confirmAutoGroup() {
      const orderType = document.getElementById('grouping-order').value;
      const separateGender = document.getElementById('separate-gender').checked;
      const separateCategories = document.getElementById('separate-categories').checked;
      const modalGroupSize = parseInt(document.getElementById('modal-group-size').value);

      // Get selected distribution options (if any)
      const distributionInputs = document.querySelectorAll('input[name^="distribution-"]:checked');
      const customDistributions = [];
      distributionInputs.forEach(input => {
        try {
          const dist = JSON.parse(input.value);
          customDistributions.push(dist);
        } catch (e) {
          console.error('Failed to parse distribution', e);
        }
      });

      closeAutoGroupModal();
      executeAutoGroup(orderType, separateGender, separateCategories, modalGroupSize, customDistributions);
    }

    // Execute auto grouping with selected settings
    function executeAutoGroup(orderType, separateGender, separateCategories, modalGroupSize, customDistributions = []) {
      const groupSize = modalGroupSize || parseInt(document.getElementById('group-size').value);
      const protocol = document.getElementById('protocol-type').value;
      const startTime = document.getElementById('start-time').value;
      const interval = parseInt(document.getElementById('interval').value);
      
      console.log('executeAutoGroup called');
      console.log('admittedPlayers count:', admittedPlayers.length);
      console.log('pinnedGroups:', [...pinnedGroups]);
      
      // Collect players from pinned groups (they will stay in place)
      const playersInPinnedGroups = new Set();
      pinnedGroups.forEach(groupIndex => {
        if (groups[groupIndex]) {
          groups[groupIndex].players.forEach(player => {
            playersInPinnedGroups.add(player.reg);
          });
        }
      });
      
      console.log('playersInPinnedGroups:', [...playersInPinnedGroups]);
      
      // Get players NOT in pinned groups for auto grouping
      const availablePlayers = admittedPlayers.filter(p => !playersInPinnedGroups.has(p.reg));
      
      console.log('availablePlayers (not in pinned groups) count:', availablePlayers.length);

      // Separate players if needed
      let playerGroups = [];
      if (separateGender) {
        const males = availablePlayers.filter(p => (p.gender || '').toLowerCase() === 'male' || (p.gender || '').toLowerCase() === 'm');
        const females = availablePlayers.filter(p => (p.gender || '').toLowerCase() === 'female' || (p.gender || '').toLowerCase() === 'f');
        if (males.length > 0) playerGroups.push({ label: 'Male', players: males });
        if (females.length > 0) playerGroups.push({ label: 'Female', players: females });
      } else if (separateCategories) {
        const categorized = {};
        availablePlayers.forEach(p => {
          const cat = (p.categories && p.categories[0]) || 'Uncategorized';
          if (!categorized[cat]) categorized[cat] = [];
          categorized[cat].push(p);
        });
        playerGroups = Object.entries(categorized).map(([cat, players]) => ({ label: cat, players }));
      } else {
        playerGroups = [{ label: 'All', players: availablePlayers }];
      }

      // Calculate how many groups we need
      const totalPlayers = admittedPlayers.length;
      const groupsNeeded = Math.ceil(totalPlayers / groupSize);
      const MIN_GROUPS = 24;
      const totalGroupsToCreate = Math.max(MIN_GROUPS, groupsNeeded);
      
      console.log('Groups needed:', groupsNeeded, 'Total groups to create:', totalGroupsToCreate);
      
      // Prepare groups - keep pinned groups completely intact
      const newGroups = [];
      
      // Create groups: pinned groups keep their players, non-pinned groups start empty
      for (let i = 0; i < totalGroupsToCreate; i++) {
        const existingGroup = groups[i];
        const isPinned = pinnedGroups.has(i);
        
        // Pinned groups keep all their players, non-pinned groups start empty
        const playersInGroup = isPinned && existingGroup 
          ? [...existingGroup.players]
          : [];
        
        newGroups.push({
          groupId: existingGroup?.groupId || `group-${Date.now()}-${i}`,
          players: playersInGroup,
          time: calculateStartTime(i, protocol, startTime, interval),
          tee: calculateTee(i, protocol)
        });
      }
      
      // Replace groups with the new structure
      groups = newGroups;

      // Sort players based on order type
      playerGroups.forEach((pg, pgIndex) => {
        let sorted = [...pg.players];
        
        switch(orderType) {
          case 'hcp-asc':
            sorted.sort((a, b) => {
              const aHcp = parseFloat(a.hcp);
              const bHcp = parseFloat(b.hcp);
              // Handle invalid/missing HCP
              if (isNaN(aHcp) && isNaN(bHcp)) return 0;
              if (isNaN(aHcp)) return 1; // Push invalid to end
              if (isNaN(bHcp)) return -1;
              return aHcp - bHcp;
            });
            break;
          case 'hcp-desc':
            sorted.sort((a, b) => {
              const aHcp = parseFloat(a.hcp);
              const bHcp = parseFloat(b.hcp);
              // Handle invalid/missing HCP
              if (isNaN(aHcp) && isNaN(bHcp)) return 0;
              if (isNaN(aHcp)) return 1; // Push invalid to end
              if (isNaN(bHcp)) return -1;
              return bHcp - aHcp;
            });
            break;
          case 'phcp-asc':
            sorted.sort((a, b) => {
              const aPhcp = getPlayingHcp(a);
              const bPhcp = getPlayingHcp(b);
              const aVal = (typeof aPhcp === 'number') ? aPhcp : (parseFloat(aPhcp) || 999);
              const bVal = (typeof bPhcp === 'number') ? bPhcp : (parseFloat(bPhcp) || 999);
              return aVal - bVal;
            });
            break;
          case 'phcp-desc':
            sorted.sort((a, b) => {
              const aPhcp = getPlayingHcp(a);
              const bPhcp = getPlayingHcp(b);
              const aVal = (typeof aPhcp === 'number') ? aPhcp : (parseFloat(aPhcp) || 0);
              const bVal = (typeof bPhcp === 'number') ? bPhcp : (parseFloat(bPhcp) || 0);
              return bVal - aVal;
            });
            break;
          case 'hcp-distribution':
            sorted.sort((a, b) => (parseFloat(a.hcp) || 999) - (parseFloat(b.hcp) || 999));
            sorted = distributeEvenly(sorted, groupSize);
            break;
          case 'club-distribution':
            const byClub = {};
            sorted.forEach(p => {
              const club = p.club || 'Unknown';
              if (!byClub[club]) byClub[club] = [];
              byClub[club].push(p);
            });
            sorted = distributeByClub(byClub, groupSize);
            break;
          case 'random':
          default:
            sorted.sort(() => Math.random() - 0.5);
            break;
        }

        // Fill sorted players into the fixed groups sequentially
        // Skip pinned groups entirely
        let playerIndex = 0;
        
        for (let groupIdx = 0; groupIdx < groups.length && playerIndex < sorted.length; groupIdx++) {
          // Skip pinned groups entirely
          if (pinnedGroups.has(groupIdx)) {
            console.log(`Skipping pinned group ${groupIdx + 1}`);
            continue;
          }
          
          const group = groups[groupIdx];
          const availableSlots = groupSize - group.players.length;
          
          // Fill available slots in this group
          for (let slot = 0; slot < availableSlots && playerIndex < sorted.length; slot++) {
            group.players.push(sorted[playerIndex]);
            playerIndex++;
          }
        }
      });

      renderGroups();
    }

    // Distribute players evenly by HCP (snake draft style)
    function distributeEvenly(sortedPlayers, groupSize) {
      const numGroups = Math.ceil(sortedPlayers.length / groupSize);
      const tempGroups = Array(numGroups).fill(null).map(() => []);
      
      let groupIndex = 0;
      let direction = 1;
      
      sortedPlayers.forEach(player => {
        tempGroups[groupIndex].push(player);
        groupIndex += direction;
        
        if (groupIndex >= numGroups) {
          groupIndex = numGroups - 1;
          direction = -1;
        } else if (groupIndex < 0) {
          groupIndex = 0;
          direction = 1;
        }
      });
      
      return tempGroups.flat();
    }

    // Distribute players to mix clubs/countries
    function distributeByClub(byClub, groupSize) {
      const clubs = Object.keys(byClub);
      const result = [];
      let continueLoop = true;
      
      while (continueLoop) {
        continueLoop = false;
        clubs.forEach(club => {
          if (byClub[club].length > 0) {
            result.push(byClub[club].shift());
            continueLoop = true;
          }
        });
      }
      
      return result;
    }

    // Add a new empty group at a specific position
    // Pinned groups stay in place, non-pinned groups shift around them
    function addNewGroup() {
      const protocol = document.getElementById('protocol-type').value;
      const startTime = document.getElementById('start-time').value;
      const interval = parseInt(document.getElementById('interval').value);
      
      // Find pinned groups
      const pinnedGroupsList = [...pinnedGroups].map(idx => idx + 1).sort((a, b) => a - b); // 1-based for display
      
      let pinnedWarning = '';
      if (pinnedGroupsList.length > 0) {
        pinnedWarning = `\n\nüìå Pinned groups: ${pinnedGroupsList.join(', ')}\n(Pinned groups will stay in their position)`;
      }
      
      // Ask user where to insert the new group
      const position = prompt(`Insert new group at which position?\n\nEnter a number between 1 and ${groups.length + 1}\n(Enter ${groups.length + 1} or leave empty to add at the end)${pinnedWarning}`, groups.length + 1);
      
      if (position === null) return; // User cancelled
      
      let insertPosition = parseInt(position) - 1; // Convert to 0-based index
      
      // Validate input
      if (isNaN(insertPosition) || insertPosition < 0) {
        insertPosition = groups.length; // Add at end
      } else if (insertPosition > groups.length) {
        insertPosition = groups.length; // Add at end
      }
      
      // Check if trying to insert at a pinned group's position
      if (pinnedGroups.has(insertPosition)) {
        alert(`Cannot insert a group at position ${insertPosition + 1} because Group ${insertPosition + 1} is pinned.\n\nPinned groups must stay in their exact position.`);
        return;
      }
      
      // Create new empty group
      const newGroup = {
        groupId: `group-${Date.now()}-${groups.length}`,
        players: [],
        time: '',
        tee: ''
      };
      
      // Build new groups array with pinned groups staying in place
      // and non-pinned groups shifting to accommodate the new group
      const newGroups = [];
      const nonPinnedGroups = [];
      
      // Separate pinned and non-pinned groups
      for (let i = 0; i < groups.length; i++) {
        if (!pinnedGroups.has(i)) {
          nonPinnedGroups.push({ group: groups[i], originalIndex: i });
        }
      }
      
      // Insert the new group into non-pinned groups at the right position
      // Calculate where in the non-pinned sequence to insert
      let nonPinnedInsertIndex = 0;
      for (let i = 0; i < insertPosition; i++) {
        if (!pinnedGroups.has(i)) {
          nonPinnedInsertIndex++;
        }
      }
      nonPinnedGroups.splice(nonPinnedInsertIndex, 0, { group: newGroup, originalIndex: -1 });
      
      // Rebuild the groups array
      // Total positions = original length + 1
      const totalPositions = groups.length + 1;
      let nonPinnedIdx = 0;
      
      // New pinned groups set (indices may change as we add a new position)
      const newPinnedGroups = new Set();
      
      for (let pos = 0; pos < totalPositions; pos++) {
        // Check if there was a pinned group at or after this position that needs to stay
        // A pinned group at original index X should stay at position X
        let pinnedAtThisPos = null;
        pinnedGroups.forEach(pinnedIdx => {
          if (pinnedIdx === pos) {
            pinnedAtThisPos = groups[pinnedIdx];
            newPinnedGroups.add(pos);
          }
        });
        
        if (pinnedAtThisPos) {
          newGroups.push(pinnedAtThisPos);
        } else {
          // Fill with next non-pinned group
          if (nonPinnedIdx < nonPinnedGroups.length) {
            newGroups.push(nonPinnedGroups[nonPinnedIdx].group);
            nonPinnedIdx++;
          }
        }
      }
      
      // Update groups and pinned groups
      groups = newGroups;
      pinnedGroups = newPinnedGroups;
      
      // Recalculate times and tees for all groups
      groups.forEach((group, index) => {
        group.time = calculateStartTime(index, protocol, startTime, interval);
        group.tee = calculateTee(index, protocol);
      });
      
      renderGroups();
    }

    // Track selected group for removal
    let selectedGroupId = null;

    // Remove a specific group by number
    // Pinned groups stay in place, non-pinned groups shift to fill gaps
    function removeSelectedGroup() {
      if (groups.length === 0) {
        alert('No groups to remove.');
        return;
      }
      
      // Find pinned groups
      const pinnedGroupsList = [...pinnedGroups].map(idx => idx + 1).sort((a, b) => a - b); // 1-based for display
      
      let pinnedWarning = '';
      if (pinnedGroupsList.length > 0) {
        pinnedWarning = `\n\nüìå Pinned groups: ${pinnedGroupsList.join(', ')}\n(Pinned groups will stay in their position)`;
      }
      
      const groupNum = prompt(`Which group do you want to remove?\n\nEnter a number between 1 and ${groups.length}${pinnedWarning}`);
      
      if (groupNum === null) return; // User cancelled
      
      const groupIndex = parseInt(groupNum) - 1; // Convert to 0-based index
      
      // Validate input
      if (isNaN(groupIndex) || groupIndex < 0 || groupIndex >= groups.length) {
        alert('Invalid group number.');
        return;
      }
      
      // Don't allow deletion of pinned groups
      if (pinnedGroups.has(groupIndex)) {
        alert(`Cannot remove Group ${groupNum} because it is pinned.\n\nUnpin the group first if you want to remove it.`);
        return;
      }
      
      const group = groups[groupIndex];
      
      // Don't allow deletion if group has players
      if (group.players.length > 0) {
        alert(`Cannot remove Group ${groupNum} because it has ${group.players.length} player(s) assigned.\n\nPlease move or remove the players first.`);
        return;
      }
      
      // Build new groups array with pinned groups staying in place
      // and non-pinned groups filling the gaps
      const newGroups = [];
      const nonPinnedGroups = [];
      
      // Collect non-pinned groups (excluding the one being removed)
      for (let i = 0; i < groups.length; i++) {
        if (!pinnedGroups.has(i) && i !== groupIndex) {
          nonPinnedGroups.push(groups[i]);
        }
      }
      
      // Rebuild the groups array
      // Total positions = original length - 1
      const totalPositions = groups.length - 1;
      let nonPinnedIdx = 0;
      
      // New pinned groups set - pinned groups keep their same index
      const newPinnedGroups = new Set();
      
      for (let pos = 0; pos < totalPositions; pos++) {
        // Check if there's a pinned group that should be at this position
        let pinnedAtThisPos = null;
        pinnedGroups.forEach(pinnedIdx => {
          if (pinnedIdx === pos) {
            pinnedAtThisPos = groups[pinnedIdx];
            newPinnedGroups.add(pos);
          }
        });
        
        if (pinnedAtThisPos) {
          newGroups.push(pinnedAtThisPos);
        } else {
          // Fill with next non-pinned group
          if (nonPinnedIdx < nonPinnedGroups.length) {
            newGroups.push(nonPinnedGroups[nonPinnedIdx]);
            nonPinnedIdx++;
          }
        }
      }
      
      // Update groups and pinned groups
      groups = newGroups;
      pinnedGroups = newPinnedGroups;
      selectedGroupId = null;
      
      // Recalculate times for remaining groups
      recalculateGroupTimes();
      renderGroups();
    }

    // Recalculate start times for all groups after adding/removing
    function recalculateGroupTimes() {
      const protocol = document.getElementById('protocol-type').value;
      const startTime = document.getElementById('start-time').value;
      const interval = parseInt(document.getElementById('interval').value);
      
      groups.forEach((group, index) => {
        group.time = calculateStartTime(index, protocol, startTime, interval);
        group.tee = calculateTee(index, protocol);
      });
    }

    // Clear all groups (keeps pinned groups intact, clears all other groups)
    function clearGroups() {
      const pinnedCount = pinnedGroups.size;
      const message = pinnedCount > 0 
        ? `Are you sure you want to clear all groups?\n\nüìå ${pinnedCount} pinned group(s) will remain intact.`
        : 'Are you sure you want to clear all groups?';
      
      if (confirm(message)) {
        groups.forEach((g, idx) => {
          // Keep pinned groups intact, clear non-pinned groups
          if (!pinnedGroups.has(idx)) {
            g.players = [];
          }
        });
        // Don't remove empty groups - keep all 24 boxes
        renderGroups();
      }
    }

    // Save draw
    function saveDraw() {
      const protocol = document.getElementById('protocol-type').value;
      const startTime = document.getElementById('start-time').value;
      const interval = parseInt(document.getElementById('interval').value);
      const groupSize = parseInt(document.getElementById('group-size').value);
      
      const draw = {
        roundId: currentRound,
        protocol,
        startTime,
        interval,
        groupSize,
        groups: groups.filter(g => g.players.length > 0)
      };
      
      const draws = JSON.parse(localStorage.getItem('draws') || '{}');
      draws[currentRound] = draw;
      localStorage.setItem('draws', JSON.stringify(draws));
      
      // Calculate and save match HCPs for match play formats
      const matchType = (currentRoundData?.matchType || '').toLowerCase();
      if (matchType === 'singles' || matchType === 'fourball' || matchType === 'foursomes') {
        calculateAndSaveMatchHCPs(currentRound, draw.groups, matchType);
      }
      
      // Sync to Firebase
      if (typeof syncToFirebase !== 'undefined' && syncEnabled) {
        syncToFirebase('draws', draws).then(() => {
          console.log('‚úì Draws synced to Firebase');
        }).catch(e => console.log('Firebase sync failed:', e));
      }
      
      alert('Draw saved successfully!');
    }
    
    // Calculate and save match HCPs for all groups
    function calculateAndSaveMatchHCPs(roundId, groups, matchType) {
      const matchHCPData = JSON.parse(localStorage.getItem('matchHCPs') || '{}');
      matchHCPData[roundId] = {};
      
      groups.forEach((group, groupIndex) => {
        const players = group.players || [];
        if (players.length < 2) return;
        
        // Calculate PHCP for each player
        const playerPHCPs = {};
        players.forEach(player => {
          const pKey = player.playerId || player.reg;
          const hcp = parseFloat(player.hcp); const phcp = isNaN(hcp) ? "-" : Math.round(hcp);
          playerPHCPs[pKey] = phcp === '-' ? null : Math.round(parseFloat(phcp));
        });
        
        if (matchType === 'singles') {
          // Singles: pairs within group (1v2, 3v4)
          const numMatches = Math.floor(players.length / 2);
          for (let i = 0; i < numMatches; i++) {
            const p1 = players[i * 2];
            const p2 = players[i * 2 + 1];
            if (!p1 || !p2) continue;
            
            const p1Key = p1.playerId || p1.reg;
            const p2Key = p2.playerId || p2.reg;
            const p1Phcp = playerPHCPs[p1Key];
            const p2Phcp = playerPHCPs[p2Key];
            
            if (p1Phcp !== null && p2Phcp !== null) {
              const lowestPhcp = Math.min(p1Phcp, p2Phcp);
              matchHCPData[roundId][p1Key] = p1Phcp - lowestPhcp;
              matchHCPData[roundId][p2Key] = p2Phcp - lowestPhcp;
            }
          }
        } else if (matchType === 'fourball') {
          // Fourball: all 4 players, lowest plays off 0
          const validPhcps = Object.entries(playerPHCPs).filter(([k, v]) => v !== null);
          if (validPhcps.length > 0) {
            const lowestPhcp = Math.min(...validPhcps.map(([k, v]) => v));
            validPhcps.forEach(([pKey, phcp]) => {
              matchHCPData[roundId][pKey] = phcp - lowestPhcp;
            });
          }
        } else if (matchType === 'foursomes') {
          // Foursomes: Team PHCPs (average of pair)
          if (players.length >= 4) {
            const team1 = players.slice(0, 2);
            const team2 = players.slice(2, 4);
            
            const team1Phcps = team1.map(p => playerPHCPs[p.playerId || p.reg]).filter(v => v !== null);
            const team2Phcps = team2.map(p => playerPHCPs[p.playerId || p.reg]).filter(v => v !== null);
            
            if (team1Phcps.length > 0 && team2Phcps.length > 0) {
              const team1Avg = team1Phcps.reduce((a, b) => a + b, 0) / team1Phcps.length;
              const team2Avg = team2Phcps.reduce((a, b) => a + b, 0) / team2Phcps.length;
              const lowestTeamPhcp = Math.min(team1Avg, team2Avg);
              
              // Store team match HCP for each player in the team
              const team1MatchHCP = Math.round(team1Avg - lowestTeamPhcp);
              const team2MatchHCP = Math.round(team2Avg - lowestTeamPhcp);
              
              team1.forEach(p => {
                matchHCPData[roundId][p.playerId || p.reg] = team1MatchHCP;
              });
              team2.forEach(p => {
                matchHCPData[roundId][p.playerId || p.reg] = team2MatchHCP;
              });
            }
          }
        }
      });
      
      localStorage.setItem('matchHCPs', JSON.stringify(matchHCPData));
      
      // Sync to Firebase
      if (typeof syncToFirebase !== 'undefined' && syncEnabled) {
        syncToFirebase('matchHCPs', matchHCPData).then(() => {
          console.log('‚úì Match HCPs synced to Firebase');
        }).catch(e => console.log('Firebase sync failed:', e));
      }
      
      console.log('Match HCPs calculated and saved:', matchHCPData[roundId]);
    }

    // Initialize on load
    init();
    
    // Add event listener for the new save button
    document.getElementById('btn-save-draw').addEventListener('click', saveDraw);
  </script>
</body>
</html>
