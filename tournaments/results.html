<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tournament Results</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      body{padding-top:70px}
      .results-container { max-width: 1200px; margin: 36px auto; padding: 24px; }
      .card { background: #fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(2,6,23,0.06); padding: 24px; margin-bottom: 20px; }
      .card h2 { margin-top: 0; font-size: 18px; margin-bottom: 16px; }
      .category-item { 
        padding: 16px; 
        border: 1px solid #e5e7eb; 
        border-radius: 8px; 
        margin-bottom: 12px; 
        background: #f9fafb;
      }
      .category-header { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        margin-bottom: 12px;
      }
      .category-name { 
        font-weight: 600; 
        font-size: 16px; 
        color: #1e293b;
      }
      .options-grid { 
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
        gap: 12px; 
        margin-top: 12px;
      }
      .option-group { 
        display: flex; 
        flex-direction: column; 
        gap: 4px;
      }
      .option-group label { 
        font-size: 13px; 
        font-weight: 600; 
        color: #475569;
      }
      .option-group select,
      .option-group input[type="checkbox"] { 
        margin-top: 4px;
      }
      .option-group select {
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
        font-size: 14px;
      }
      .checkbox-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 4px;
      }
      .checkbox-wrapper input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }
      .checkbox-wrapper span {
        font-size: 14px;
        color: #1e293b;
      }
      .btn { 
        background: linear-gradient(180deg, var(--accent), #0a58d1); 
        color: white; 
        border: 0; 
        padding: 10px 20px; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 14px; 
        font-weight: 600;
        transition: transform 0.08s; 
      }
      .btn:active { transform: translateY(1px); }
      .btn-back { 
        background: white; 
        color: #0b6efd; 
        border: 1px solid #e6e9ef; 
      }
      .btn-show { 
        background: linear-gradient(180deg, #10b981, #059669);
        margin-top: 12px;
      }
      .action-buttons { 
        display: flex; 
        gap: 10px; 
        margin-top: 24px;
      }
      .empty-state { 
        text-align: center; 
        color: #6b7280; 
        padding: 40px; 
        font-size: 14px;
      }
      
      /* Match Play Results Styles */
      .match-result-card {
        display: flex;
        align-items: center;
        gap: 12px;
        background: #f8fafc;
        border-radius: 10px;
        padding: 16px;
        margin-bottom: 12px;
        border: 1px solid #e2e8f0;
      }
      .match-result-card.completed {
        background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
        border-color: #86efac;
      }
      .match-result-card.tied {
        background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
        border-color: #fcd34d;
      }
      .match-team-result {
        flex: 1;
        padding: 12px;
        border-radius: 8px;
        text-align: center;
      }
      .match-team-result.winner {
        background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
        border: 2px solid #22c55e;
      }
      .match-team-result.loser {
        background: #f1f5f9;
        border: 2px solid #e2e8f0;
        opacity: 0.8;
      }
      .match-team-result.tied {
        background: linear-gradient(135deg, #fef9c3 0%, #fef08a 100%);
        border: 2px solid #facc15;
      }
      .match-team-name {
        font-size: 13px;
        font-weight: 600;
        color: #dc2626;
        margin-bottom: 4px;
      }
      .match-player-name {
        font-size: 14px;
        font-weight: 600;
        color: #1e293b;
      }
      .match-score-display {
        font-size: 24px;
        font-weight: 700;
        color: #1e293b;
        min-width: 50px;
        text-align: center;
      }
      .match-vs-display {
        font-size: 12px;
        font-weight: 600;
        color: #94a3b8;
        padding: 0 8px;
      }
      .match-status-badge {
        font-size: 11px;
        padding: 2px 8px;
        border-radius: 12px;
        font-weight: 600;
      }
      .match-status-badge.pending { background: #f1f5f9; color: #64748b; }
      .match-status-badge.completed { background: #dcfce7; color: #16a34a; }
      .match-status-badge.tied { background: #fef3c7; color: #d97706; }
      
      /* Team Standings Table */
      .standings-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }
      .standings-table th {
        background: #f8fafc;
        padding: 12px 16px;
        text-align: left;
        font-weight: 600;
        color: #475569;
        border-bottom: 2px solid #e2e8f0;
      }
      .standings-table td {
        padding: 12px 16px;
        border-bottom: 1px solid #f1f5f9;
      }
      .standings-table tr:hover {
        background: #f8fafc;
      }
      .standings-rank {
        font-weight: 700;
        color: #1e293b;
        width: 50px;
      }
      .standings-rank.gold { color: #f59e0b; }
      .standings-rank.silver { color: #94a3b8; }
      .standings-rank.bronze { color: #cd7c32; }
    </style>
  </head>
  <body>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>
    <script src="../components/auth.js"></script>
    <script>
      (async function(){
        const { user, role } = await window.Auth.requireAuth();
        const uid = user.uid;
        const params = new URLSearchParams(window.location.search);
        const tournamentId = params.get('tournamentId');
        try {
          const raw = localStorage.getItem('tournaments');
          const list = raw ? JSON.parse(raw) : [];
          const t = list.find(x => x && x.tournamentId === tournamentId);
          if (!t) return;
          if (role !== 'admin' && t.createdBy && t.createdBy !== uid){
            alert('You do not have access to this tournament.');
            window.location.href = 'index.html';
          }
        } catch(e){}
      })();
    </script>
    <div class="top-nav">
      <h1>üèÜ Results</h1>
      <a href="index.html" class="btn-back-top">‚Üê Back</a>
    </div>
    <main class="results-container">
      <header>
        <h1>Tournament Results</h1>
        <p class="lead" id="tournament-name">Configure result displays</p>
      </header>

      <!-- Stroke Play Results Section -->
      <div class="card" id="stroke-play-section">
        <h2>Category Results Configuration</h2>
        <div style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
          <button class="btn" style="background: linear-gradient(180deg, #10b981, #059669);" onclick="generateAllResults()">üìä Generate All Results</button>
          <button class="btn" style="background: linear-gradient(180deg, #f59e0b, #d97706);" onclick="openWinnersList()">üèÜ Winners List</button>
          <button class="btn" style="background: linear-gradient(180deg, #ec4899, #db2777);" onclick="openPlayOff()">üèåÔ∏è Play Off Results</button>
        </div>
        <p id="generate-status" style="display: none; padding: 12px; border-radius: 8px; margin-bottom: 16px; font-weight: 500;"></p>
        <div id="categories-list">
          <div class="empty-state">Loading categories...</div>
        </div>
      </div>

      <!-- Match Play Results Section -->
      <div class="card" id="match-play-section" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <h2 style="margin: 0;">üéØ Match Play Results</h2>
          <button class="btn" style="background: linear-gradient(180deg, #10b981, #059669);" onclick="saveMatchPlayResults()">üíæ Save Results to Firebase</button>
        </div>
        <p style="color: #64748b; margin-bottom: 20px;">Team standings and match results aggregated across all rounds played.</p>
        <div id="match-play-save-status" style="display: none; padding: 12px; border-radius: 8px; margin-bottom: 16px; font-weight: 500;"></div>
        
        <!-- Team Standings at the top -->
        <div style="margin-bottom: 24px;">
          <h3 style="margin: 0 0 16px 0; font-size: 18px; color: #1e293b;">üèÜ Team Standings</h3>
          <div id="team-standings-container">
            <div class="empty-state">Loading team standings...</div>
          </div>
        </div>

        <!-- Match Results by Round -->
        <div style="padding-top: 20px; border-top: 1px solid #e5e7eb;">
          <h3 style="margin: 0 0 16px 0; font-size: 16px; color: #1e293b;">üìã Match Results</h3>
          <div id="match-results-container">
            <div class="empty-state">Loading match results...</div>
          </div>
        </div>
      </div>
    </main>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');
      
      // Global variable to store match play results for saving
      let currentMatchPlayResults = null;

      if (!tournamentId) {
        alert('No tournament selected. Redirecting to tournaments page.');
        window.location.href = 'index.html';
      }

      // Load data from Firebase first
      async function loadFromFirebase() {
        if (typeof initFirebase !== 'undefined') {
          initFirebase();
        }
        
        if (typeof syncFromFirebase !== 'undefined' && syncEnabled) {
          try {
            // Load tournaments
            const tournamentsData = await syncFromFirebase('tournaments');
            if (tournamentsData) {
              // Convert from object format to array if needed
              let tournamentsArray;
              if (Array.isArray(tournamentsData)) {
                tournamentsArray = tournamentsData.filter(t => t !== null);
              } else {
                tournamentsArray = Object.values(tournamentsData).filter(t => t !== null);
              }
              localStorage.setItem('tournaments', JSON.stringify(tournamentsArray));
              console.log('‚úì Tournaments loaded from Firebase:', tournamentsArray.length);
            }
            
            // Load admitted players
            const admittedData = await syncFromFirebase('admittedPlayers');
            if (admittedData) {
              localStorage.setItem('admittedPlayers', JSON.stringify(admittedData));
              console.log('‚úì Admitted players loaded from Firebase');
            }
            
            // Load scores
            const scoresData = await syncFromFirebase('scores');
            if (scoresData) {
              localStorage.setItem('scores', JSON.stringify(scoresData));
              console.log('‚úì Scores loaded from Firebase');
            }
          } catch(e) {
            console.log('Firebase load error:', e);
          }
        }
      }

      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }
      
      function saveTournaments(list) {
        localStorage.setItem('tournaments', JSON.stringify(list || []));
        // Sync to Firebase
        if (typeof syncToFirebase !== 'undefined' && syncEnabled) {
          syncToFirebase('tournaments', list || []);
        }
      }

      function getTournament() {
        const tournaments = getTournaments();
        return tournaments.find(t => t.tournamentId === tournamentId);
      }

      function getCategories() {
        const tournament = getTournament();
        return tournament?.categories || [];
      }
      
      // Get stored category assignments (single source of truth)
      function getCategoryAssignments(categoryCode) {
        const tournament = getTournament();
        if (!tournament || !tournament.categoryAssignments) return null;
        return tournament.categoryAssignments[categoryCode] || null;
      }
      
      // Calculate which categories a player belongs to
      // PRIORITY: Uses stored categoryAssignments if available, otherwise calculates on-the-fly
      function getPlayerCategories(player, tournament) {
        if (!tournament || !tournament.categories || tournament.categories.length === 0) {
          return [];
        }
        
        const playerId = player.reg || player.id;
        
        // PRIORITY 1: Check stored categoryAssignments (single source of truth)
        if (tournament.categoryAssignments && playerId) {
          const matchingFromStored = [];
          for (const catCode in tournament.categoryAssignments) {
            // Firebase may return arrays as objects with numeric keys - convert back to array
            let playerIds = tournament.categoryAssignments[catCode];
            if (playerIds && !Array.isArray(playerIds)) {
              playerIds = Object.values(playerIds);
            }
            if (playerIds && playerIds.includes(playerId)) {
              matchingFromStored.push(catCode);
            }
          }
          if (matchingFromStored.length > 0) {
            console.log(`Player ${playerId}: Using stored category assignments:`, matchingFromStored);
            return matchingFromStored;
          }
        }
        
        // FALLBACK: Calculate on-the-fly (backward compatibility)
        const matchingCategories = [];
        const playerGender = (player.gender || '').toLowerCase();
        const playerHcp = parseFloat(player.hcp);
        const playerAge = player.age ? parseInt(player.age) : null;
        
        for (const cat of tournament.categories) {
          // Skip result-only categories
          if (cat.isResultOnly) continue;
          
          // Check if this is a manual category with explicit player list
          if (cat.isManual === true) {
            const manualPlayerIds = cat.players || cat.manualPlayers || [];
            if (manualPlayerIds.includes(player.reg) || manualPlayerIds.includes(player.id)) {
              matchingCategories.push(cat.code);
            }
            continue;
          }
          
          // Check categoryTag first - if specified, player must have this tag
          if (cat.categoryTag && cat.categoryTag !== '') {
            const playerTag = player.categoryTag || player.tag || '';
            if (playerTag !== cat.categoryTag) continue;
          }
          
          // Check gender match
          const catGender = (cat.gender || '').toLowerCase();
          let genderMatch = false;
          if (!catGender || catGender === 'any' || catGender === '' || catGender === 'manual') {
            genderMatch = true;
          } else if (catGender === 'male' && (playerGender === 'm' || playerGender === 'male' || playerGender === 'e')) {
            genderMatch = true;
          } else if (catGender === 'female' && (playerGender === 'f' || playerGender === 'female' || playerGender === 'k')) {
            genderMatch = true;
          }
          
          if (!genderMatch) continue;
          
          // Check handicap range (skip if 'Manual')
          if (cat.handicapMin !== undefined && cat.handicapMin !== null && cat.handicapMin !== '' && cat.handicapMin !== 'Manual') {
            if (isNaN(playerHcp) || playerHcp < parseFloat(cat.handicapMin)) continue;
          }
          if (cat.handicapMax !== undefined && cat.handicapMax !== null && cat.handicapMax !== '' && cat.handicapMax !== 'Manual') {
            if (isNaN(playerHcp) || playerHcp > parseFloat(cat.handicapMax)) continue;
          }
          
          // Check age range (skip if 'Manual')
          if (cat.ageMin !== undefined && cat.ageMin !== null && cat.ageMin !== '' && cat.ageMin !== 'Manual') {
            if (playerAge === null || playerAge < parseInt(cat.ageMin)) continue;
          }
          if (cat.ageMax !== undefined && cat.ageMax !== null && cat.ageMax !== '' && cat.ageMax !== 'Manual') {
            if (playerAge === null || playerAge > parseInt(cat.ageMax)) continue;
          }
          
          // Player matches this category
          matchingCategories.push(cat.code);
        }
        
        return matchingCategories;
      }
      
      // Ensure a default category exists for team/match play tournaments
      // Ensure Team category exists for team tournaments
      function ensureTeamCategoryExists() {
        const tournament = getTournament();
        if (!tournament) return;
        
        // Check if this is a team tournament
        const isTeamTournament = tournament.meta?.teamsTournament === 'yes';
        if (!isTeamTournament) return;
        
        // Check if Team category already exists
        const categories = tournament.categories || [];
        const hasTeamCategory = categories.some(cat => cat.code === 'TEAM' || cat.name?.toLowerCase() === 'team');
        if (hasTeamCategory) {
          console.log('Team category already exists');
          return;
        }
        
        console.log('Creating Team category for team tournament');
        
        // Get default tees from tournament definition
        const roundData = tournament.meta?.roundsData?.[0];
        const defaultTeeMen = roundData?.teeMen || '';
        const defaultTeeWomen = roundData?.teeWomen || '';
        
        // Create Team category
        const teamCategory = {
          name: 'Team',
          code: 'TEAM',
          shortName: 'Team',
          gender: '',
          tournamentType: 'Stableford Net',
          playsFromMen: defaultTeeMen,
          playsFromWomen: defaultTeeWomen,
          isResultOnly: false
        };
        
        // Add to beginning of categories
        const tournaments = getTournaments();
        const index = tournaments.findIndex(t => t.tournamentId === tournamentId);
        if (index !== -1) {
          if (!tournaments[index].categories) {
            tournaments[index].categories = [];
          }
          tournaments[index].categories.unshift(teamCategory);
          saveTournaments(tournaments);
          console.log('‚úì Team category created for team tournament');
        }
      }
      
      function ensureDefaultCategory() {
        const tournament = getTournament();
        if (!tournament) return;
        
        // First ensure Team category for team tournaments
        ensureTeamCategoryExists();
        
        // Check if categories already exist
        if (tournament.categories && tournament.categories.length > 0) return;
        
        // Check if this is a team or match play tournament
        const isTeamTournament = tournament.meta?.teamsTournament === 'yes';
        const isMatchPlay = (tournament.type || '').toLowerCase().includes('match');
        
        if (!isTeamTournament && !isMatchPlay) return;
        
        console.log('Creating default category for team/match play tournament');
        
        // Get default tees from tournament definition
        const roundData = tournament.meta?.roundsData?.[0];
        const defaultTeeMen = roundData?.teeMen || '';
        const defaultTeeWomen = roundData?.teeWomen || '';
        
        // Create default category
        const defaultCategory = {
          name: isMatchPlay ? 'Match Play' : 'Team',
          code: isMatchPlay ? 'MATCH' : 'TEAM',
          shortName: isMatchPlay ? 'Match' : 'Team',
          gender: '',
          tournamentType: isMatchPlay ? 'Match Play' : 'Stableford Net',
          playsFromMen: defaultTeeMen,
          playsFromWomen: defaultTeeWomen,
          isResultOnly: false
        };
        
        // Save category to tournament
        const tournaments = getTournaments();
        const index = tournaments.findIndex(t => t.tournamentId === tournamentId);
        if (index !== -1) {
          tournaments[index].categories = [defaultCategory];
          saveTournaments(tournaments);
          console.log('‚úì Default category created:', defaultCategory.name);
        }
      }

      function getCategoryPreferences(categoryCode) {
        const tournament = getTournament();
        if (!tournament.resultPreferences) return null;
        return tournament.resultPreferences[categoryCode];
      }

      function saveCategoryPreferences(categoryCode, prefs) {
        const tournaments = getTournaments();
        const index = tournaments.findIndex(t => t.tournamentId === tournamentId);
        if (index !== -1) {
          if (!tournaments[index].resultPreferences) {
            tournaments[index].resultPreferences = {};
          }
          tournaments[index].resultPreferences[categoryCode] = prefs;
          localStorage.setItem('tournaments', JSON.stringify(tournaments));
        }
      }

      // Check if tournament is match play
      function isMatchPlayTournament() {
        const tournament = getTournament();
        return (tournament?.type || '').toLowerCase().includes('match');
      }

      // Get draw data for a round
      function getDrawData(roundId) {
        try {
          const draws = JSON.parse(localStorage.getItem('draws') || '{}');
          return draws[roundId] || null;
        } catch (err) {
          console.error('Failed to parse draw data', err);
          return null;
        }
      }

      // Get match scores data
      function getMatchScoresData() {
        try {
          const data = JSON.parse(localStorage.getItem('matchScores') || '{}');
          return data;
        } catch (err) {
          console.error('Failed to parse match scores', err);
          return {};
        }
      }

      // Get hole-by-hole scores data
      function getHoleByHoleScoresData() {
        try {
          const data = JSON.parse(localStorage.getItem('holeByHoleScores') || '{}');
          return data;
        } catch (err) {
          console.error('Failed to parse hole-by-hole scores', err);
          return {};
        }
      }

      // Get merged match scores (from both match-score entry and hole-by-hole entry methods)
      // Hole-by-hole entry stores matchResult directly, so we just read it
      // Falls back to simple calculation if matchResult not stored (for legacy data)
      function getMergedMatchScores(roundId) {
        const matchScores = getMatchScoresData()[roundId] || {};
        const holeByHoleScores = getHoleByHoleScoresData();
        
        // Look for hole-by-hole scores for this round
        const roundPrefix = `${roundId}_match_`;
        const merged = { ...matchScores };
        
        console.log('getMergedMatchScores for roundId:', roundId);
        console.log('holeByHoleScores keys:', Object.keys(holeByHoleScores));
        
        Object.keys(holeByHoleScores).forEach(key => {
          if (key.startsWith(roundPrefix)) {
            // Extract match index from key like "round1_match_0"
            const matchIndex = parseInt(key.replace(roundPrefix, ''));
            const matchKey = `match_${matchIndex}`;
            
            // Get the stored matchResult from scores page
            const matchData = holeByHoleScores[key];
            let storedResult = matchData?.matchResult;
            
            console.log(`Match ${key}: matchResult =`, storedResult);
            
            // If no stored result, try to calculate from hole scores (legacy data support)
            if (!storedResult && matchData) {
              storedResult = calculateSimpleMatchResult(matchData);
              console.log(`Match ${key}: calculated result =`, storedResult);
            }
            
            // Only use hole-by-hole result if no match score already exists
            if (storedResult && (!merged[matchKey] || (merged[matchKey].left === '' && merged[matchKey].right === ''))) {
              merged[matchKey] = { 
                left: storedResult.left, 
                right: storedResult.right,
                resultText: storedResult.resultText,
                winner: storedResult.winner,
                fromHoleByHole: true
              };
            }
          }
        });
        
        return merged;
      }
      
      // Simple match result calculation for legacy data (without handicap - uses gross scores)
      // This is a fallback when matchResult is not stored
      function calculateSimpleMatchResult(matchData) {
        if (!matchData) return null;
        
        let runningScore = 0; // Positive = Team 1 up
        let holesPlayed = 0;
        
        for (let i = 0; i < 18; i++) {
          const t1p1 = matchData.team1Player1Scores?.[i];
          const t1p2 = matchData.team1Player2Scores?.[i];
          const t2p1 = matchData.team2Player1Scores?.[i];
          const t2p2 = matchData.team2Player2Scores?.[i];
          
          // Need at least one score from each team
          const t1HasScore = (t1p1 !== '' && t1p1 !== undefined) || (t1p2 !== '' && t1p2 !== undefined);
          const t2HasScore = (t2p1 !== '' && t2p1 !== undefined) || (t2p2 !== '' && t2p2 !== undefined);
          
          if (!t1HasScore || !t2HasScore) continue;
          
          holesPlayed++;
          
          // Get best ball for each team (X=0 scores can't win)
          const getValidScore = (s) => {
            if (s === '' || s === null || s === undefined) return 999;
            const val = parseInt(s);
            return val === 0 ? 999 : val; // X (0) can't win
          };
          
          const t1Best = Math.min(getValidScore(t1p1), getValidScore(t1p2));
          const t2Best = Math.min(getValidScore(t2p1), getValidScore(t2p2));
          
          if (t1Best < t2Best) runningScore++;
          else if (t2Best < t1Best) runningScore--;
          
          // Check if match is finished
          const holesRemaining = 18 - holesPlayed;
          if (Math.abs(runningScore) > holesRemaining) {
            return {
              left: runningScore > 0 ? Math.abs(runningScore) : 0,
              right: runningScore < 0 ? Math.abs(runningScore) : 0,
              resultText: `${Math.abs(runningScore)}&${holesRemaining}`,
              winner: runningScore > 0 ? 'team1' : 'team2'
            };
          }
        }
        
        if (holesPlayed === 0) return null;
        
        if (runningScore === 0) {
          return { left: 0, right: 0, resultText: 'Halved', winner: 'tie' };
        } else {
          return {
            left: runningScore > 0 ? Math.abs(runningScore) : 0,
            right: runningScore < 0 ? Math.abs(runningScore) : 0,
            resultText: `${Math.abs(runningScore)}UP`,
            winner: runningScore > 0 ? 'team1' : 'team2'
          };
        }
      }

      // Initialize match play results UI - loads ALL rounds
      function initMatchPlayResults() {
        const tournament = getTournament();
        if (!tournament) return;

        // Load all match results from all rounds
        loadAllMatchResults();
      }

      // Format date for display
      function formatDateForDisplay(dateStr) {
        if (!dateStr) return '';
        const d = new Date(dateStr);
        return d.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' });
      }

      // Load and aggregate match results from ALL rounds
      function loadAllMatchResults() {
        const tournament = getTournament();
        if (!tournament) return;

        const roundIds = tournament.meta?.roundIds || [tournament.tournamentId + '-1'];
        const roundsData = tournament.meta?.roundsData || [];
        const allMatchScores = getMatchScoresData();
        
        // Build player-to-team lookup from teamsByRound
        const playerTeamLookup = {}; // { roundIndex: { playerReg: teamName } }
        const teamsByRound = tournament.teamsByRound || {};
        const legacyTeams = tournament.teams || [];
        
        // Build lookup for each round
        // First, build a complete lookup from all available team data
        const allPlayerTeams = {}; // { playerReg: teamName } - master lookup from all rounds
        
        // Collect all player-team mappings from all available sources
        const allTeamSources = [];
        if (Array.isArray(teamsByRound)) {
          teamsByRound.forEach(teams => { if (teams) allTeamSources.push(teams); });
        } else {
          Object.values(teamsByRound).forEach(teams => { if (teams) allTeamSources.push(teams); });
        }
        if (legacyTeams.length > 0) allTeamSources.push(legacyTeams);
        
        // Build master lookup from all sources
        allTeamSources.forEach(teamsList => {
          if (!teamsList) return;
          teamsList.forEach(team => {
            const teamName = team.name || '';
            (team.players || []).forEach(player => {
              const playerReg = typeof player === 'string' ? player : (player?.reg || '');
              if (playerReg && teamName) {
                // Only set if not already set (prefer earlier/more specific data)
                if (!allPlayerTeams[playerReg]) {
                  allPlayerTeams[playerReg] = teamName;
                }
              }
            });
          });
        });
        
        console.log('Master player-team lookup entries:', Object.keys(allPlayerTeams).length);
        
        // Now build per-round lookups, falling back to master lookup
        roundIds.forEach((roundId, roundIndex) => {
          playerTeamLookup[roundIndex] = {};
          
          // Try to get round-specific teams
          let roundTeams = null;
          if (Array.isArray(teamsByRound)) {
            roundTeams = teamsByRound[roundIndex];
          } else {
            roundTeams = teamsByRound[roundIndex] || teamsByRound[String(roundIndex)];
          }
          
          if (roundTeams && roundTeams.length > 0) {
            // Use round-specific teams
            roundTeams.forEach(team => {
              const teamName = team.name || '';
              (team.players || []).forEach(player => {
                const playerReg = typeof player === 'string' ? player : (player?.reg || '');
                if (playerReg) {
                  playerTeamLookup[roundIndex][playerReg] = teamName;
                }
              });
            });
          } else {
            // Fallback: use master lookup for this round
            playerTeamLookup[roundIndex] = { ...allPlayerTeams };
          }
        });
        
        console.log('playerTeamLookup:', playerTeamLookup);
        
        const standingsContainer = document.getElementById('team-standings-container');
        const resultsContainer = document.getElementById('match-results-container');
        
        // Aggregate all match results across all rounds
        const allMatchResults = [];
        let resultsHtml = '';
        
        console.log('=== loadAllMatchResults ===');
        console.log('roundIds:', roundIds);
        
        roundIds.forEach((roundId, roundIndex) => {
          const drawData = getDrawData(roundId);
          // Use merged scores from both match-score and hole-by-hole entry methods
          const matchScores = getMergedMatchScores(roundId);
          const roundPlayerTeams = playerTeamLookup[roundIndex] || {};
          
          console.log(`Round ${roundIndex}: roundId=${roundId}, drawData groups:`, drawData?.groups?.length);
          console.log(`Round ${roundIndex}: matchScores:`, matchScores);
          
          if (!drawData || !drawData.groups || drawData.groups.length === 0) {
            return; // Skip rounds with no draw
          }

          // Get round info and match type
          const roundDate = roundsData[roundIndex]?.date ? formatDateForDisplay(roundsData[roundIndex].date) : '';
          const roundLabel = `Round ${roundIndex + 1}${roundDate ? ' - ' + roundDate : ''}`;
          const matchType = (roundsData[roundIndex]?.matchType || '').toLowerCase();
          
          // Collect matches for this round
          const roundMatches = [];
          
          drawData.groups.forEach((group, groupIndex) => {
            const players = group.players || [];
            if (players.length < 2) return;

            // For SINGLES: Each group can have multiple individual matches (1v2, 3v4)
            // For FOURBALL/FOURSOMES: Group is one match (pair vs pair)
            if (matchType === 'singles' || matchType === '') {
              // Singles: Create separate matches for each pair of players
              const numMatches = Math.floor(players.length / 2);
              
              for (let i = 0; i < numMatches; i++) {
                const player1 = players[i * 2];
                const player2 = players[i * 2 + 1];
                
                if (!player1 || !player2) continue;
                
                const matchKey = `match_${groupIndex}_${i}`;
                const score = matchScores[matchKey] || { left: '', right: '' };
                
                // Determine match status and winner
                const leftScore = score.left !== '' ? parseInt(score.left) : null;
                const rightScore = score.right !== '' ? parseInt(score.right) : null;
                const resultText = score.resultText || null; // From hole-by-hole scoring
                
                let matchStatus = 'pending';
                let leftClass = '';
                let rightClass = '';
                
                if (leftScore !== null && rightScore !== null) {
                  if (leftScore === 0 && rightScore === 0) {
                    matchStatus = 'tied';
                    leftClass = 'tied';
                    rightClass = 'tied';
                  } else if (leftScore > rightScore) {
                    matchStatus = 'completed';
                    leftClass = 'winner';
                    rightClass = 'loser';
                  } else {
                    matchStatus = 'completed';
                    leftClass = 'loser';
                    rightClass = 'winner';
                  }
                }

                // For singles, look up player's team from teamsByRound
                // Fallback to player's own teamName/team property if not found
                const leftTeamName = roundPlayerTeams[player1.reg] || player1.teamName || player1.team || '';
                const rightTeamName = roundPlayerTeams[player2.reg] || player2.teamName || player2.team || '';

                // Store result for standings calculation
                allMatchResults.push({
                  roundIndex: roundIndex,
                  matchType: 'singles',
                  leftTeam: leftTeamName,
                  rightTeam: rightTeamName,
                  leftPlayer: player1,
                  rightPlayer: player2,
                  leftScore: leftScore,
                  rightScore: rightScore,
                  status: matchStatus
                });

                roundMatches.push({
                  matchType: 'singles',
                  leftPlayers: [player1],
                  rightPlayers: [player2],
                  leftTeamName,
                  rightTeamName,
                  leftScore,
                  rightScore,
                  leftClass,
                  rightClass,
                  matchStatus,
                  resultText
                });
              }
            } else {
              // Fourball/Foursomes: Group is one match with pairs
              const matchKey = `match_${groupIndex}`;
              const score = matchScores[matchKey] || { left: '', right: '' };
              
              // Determine match status and winner
              const leftScore = score.left !== '' ? parseInt(score.left) : null;
              const rightScore = score.right !== '' ? parseInt(score.right) : null;
              const resultText = score.resultText || null; // From hole-by-hole scoring
              
              let matchStatus = 'pending';
              let leftClass = '';
              let rightClass = '';
              
              if (leftScore !== null && rightScore !== null) {
                if (leftScore === 0 && rightScore === 0) {
                  matchStatus = 'tied';
                  leftClass = 'tied';
                  rightClass = 'tied';
                } else if (leftScore > rightScore) {
                  matchStatus = 'completed';
                  leftClass = 'winner';
                  rightClass = 'loser';
                } else {
                  matchStatus = 'completed';
                  leftClass = 'loser';
                  rightClass = 'winner';
                }
              }

              // Split players into teams
              const leftPlayers = players.slice(0, 2);
              const rightPlayers = players.slice(2, 4);
              
              // Look up team names from teamsByRound, fallback to player properties
              const leftTeamName = (leftPlayers[0]?.reg && roundPlayerTeams[leftPlayers[0].reg]) || leftPlayers[0]?.teamName || leftPlayers[0]?.team || '';
              const rightTeamName = (rightPlayers[0]?.reg && roundPlayerTeams[rightPlayers[0].reg]) || rightPlayers[0]?.teamName || rightPlayers[0]?.team || '';

              // Store result for standings calculation
              allMatchResults.push({
                roundIndex: roundIndex,
                matchType: matchType,
                leftTeam: leftTeamName,
                rightTeam: rightTeamName,
                leftPlayers: leftPlayers,
                rightPlayers: rightPlayers,
                leftScore: leftScore,
                rightScore: rightScore,
                status: matchStatus
              });

              roundMatches.push({
                matchType: matchType,
                leftPlayers,
                rightPlayers,
                leftTeamName,
                rightTeamName,
                leftScore,
                rightScore,
                leftClass,
                rightClass,
                matchStatus,
                resultText
              });
            }
          });

          // Only show round header if there are matches
          if (roundMatches.length > 0) {
            resultsHtml += `<div style="margin-bottom: 24px;">
              <h4 style="margin: 0 0 12px 0; font-size: 15px; color: #475569; padding: 8px 12px; background: #f1f5f9; border-radius: 6px;">
                üìÖ ${roundLabel}
              </h4>`;
            
            roundMatches.forEach(match => {
              // For singles, don't show team name with folder icon
              const showTeamName = match.matchType !== 'singles';
              
              // Determine score display: use resultText if available, otherwise show numeric scores
              const scoreDisplay = match.resultText 
                ? `<div class="match-score-display" style="font-size: 16px; min-width: 60px;">${match.resultText}</div>` 
                : `<div class="match-score-display">${match.leftScore !== null ? match.leftScore : '-'}</div>
                   <div class="match-vs-display">VS</div>
                   <div class="match-score-display">${match.rightScore !== null ? match.rightScore : '-'}</div>`;
              
              resultsHtml += `
                <div class="match-result-card ${match.matchStatus}">
                  <!-- Left Side -->
                  <div class="match-team-result ${match.leftClass}">
                    ${showTeamName && match.leftTeamName ? `<div class="match-team-name">üìÅ ${match.leftTeamName}</div>` : ''}
                    ${match.leftPlayers.map(p => `<div class="match-player-name">${p.firstName} ${p.lastName}</div>`).join('')}
                  </div>

                  <!-- Scores -->
                  <div style="display: flex; align-items: center; gap: 4px;">
                    ${scoreDisplay}
                  </div>

                  <!-- Right Side -->
                  <div class="match-team-result ${match.rightClass}">
                    ${showTeamName && match.rightTeamName ? `<div class="match-team-name">üìÅ ${match.rightTeamName}</div>` : ''}
                    ${match.rightPlayers.length > 0 ? match.rightPlayers.map(p => `<div class="match-player-name">${p.firstName} ${p.lastName}</div>`).join('') : '<div class="match-player-name" style="color: #94a3b8;">No opponent</div>'}
                  </div>

                  <!-- Status Badge -->
                  <div class="match-status-badge ${match.matchStatus}">
                    ${match.matchStatus === 'pending' ? '‚è≥ Pending' : match.matchStatus === 'tied' ? 'ü§ù Tied' : '‚úì Complete'}
                  </div>
                </div>
              `;
            });
            
            resultsHtml += '</div>';
          }
        });

        // Display results
        resultsContainer.innerHTML = resultsHtml || '<div class="empty-state">No match results found. Create draws and enter match scores first.</div>';
        
        // Calculate and display team standings
        calculateTeamStandings(allMatchResults);
      }

      // Calculate and display team standings with score differential as untie criteria
      function calculateTeamStandings(matchResults) {
        const container = document.getElementById('team-standings-container');
        
        // Aggregate team stats
        const teamStats = {};
        
        matchResults.forEach((match, idx) => {
          // Skip matches where either team is empty (can't attribute to standings)
          if (!match.leftTeam || !match.rightTeam) {
            return;
          }
          
          // Initialize teams if not exists
          if (!teamStats[match.leftTeam]) {
            teamStats[match.leftTeam] = { wins: 0, losses: 0, ties: 0, points: 0, matchesPlayed: 0, scoreDiff: 0 };
          }
          if (!teamStats[match.rightTeam]) {
            teamStats[match.rightTeam] = { wins: 0, losses: 0, ties: 0, points: 0, matchesPlayed: 0, scoreDiff: 0 };
          }
          
          if (match.status === 'pending') return;
          
          // Update stats based on result
          teamStats[match.leftTeam].matchesPlayed++;
          teamStats[match.rightTeam].matchesPlayed++;
          
          // Calculate score differential (winning margin)
          const leftScore = match.leftScore || 0;
          const rightScore = match.rightScore || 0;
          
          if (match.status === 'tied') {
            teamStats[match.leftTeam].ties++; teamStats[match.leftTeam].points += 0.5;
            teamStats[match.rightTeam].ties++; teamStats[match.rightTeam].points += 0.5;
            // No score differential for ties
          } else if (leftScore > rightScore) {
            // Left team wins
            teamStats[match.leftTeam].wins++; 
            teamStats[match.leftTeam].points += 1;
            teamStats[match.leftTeam].scoreDiff += leftScore; // Add winning margin
            teamStats[match.rightTeam].losses++;
            teamStats[match.rightTeam].scoreDiff -= leftScore; // Subtract opponent's winning margin
          } else {
            // Right team wins
            teamStats[match.rightTeam].wins++; 
            teamStats[match.rightTeam].points += 1;
            teamStats[match.rightTeam].scoreDiff += rightScore; // Add winning margin
            teamStats[match.leftTeam].losses++;
            teamStats[match.leftTeam].scoreDiff -= rightScore; // Subtract opponent's winning margin
          }
        });

        // Convert to array and sort by points, then by score differential (untie criteria)
        const standings = Object.entries(teamStats)
          .map(([team, stats]) => ({ team, ...stats }))
          .filter(t => t.team) // Filter out empty team names
          .sort((a, b) => {
            // Primary: Points (descending)
            if (b.points !== a.points) return b.points - a.points;
            // Secondary (untie criteria): Score differential (descending)
            if (b.scoreDiff !== a.scoreDiff) return b.scoreDiff - a.scoreDiff;
            // Tertiary: Wins (descending)
            return b.wins - a.wins;
          });

        if (standings.length === 0) {
          container.innerHTML = '<div class="empty-state">No team data available. Teams are assigned when creating the draw.</div>';
          return;
        }

        let html = `
          <table class="standings-table">
            <thead>
              <tr>
                <th style="width: 50px;">#</th>
                <th>Team</th>
                <th style="text-align: center;">Played</th>
                <th style="text-align: center;">Won</th>
                <th style="text-align: center;">Lost</th>
                <th style="text-align: center;">Tied</th>
                <th style="text-align: center;">Points</th>
                <th style="text-align: center;" title="Score Differential (Untie Criteria)">+/-</th>
              </tr>
            </thead>
            <tbody>
        `;

        standings.forEach((team, idx) => {
          const rankClass = idx === 0 ? 'gold' : idx === 1 ? 'silver' : idx === 2 ? 'bronze' : '';
          const diffDisplay = team.scoreDiff > 0 ? `+${team.scoreDiff}` : team.scoreDiff;
          const diffColor = team.scoreDiff > 0 ? '#16a34a' : team.scoreDiff < 0 ? '#dc2626' : '#64748b';
          
          html += `
            <tr>
              <td class="standings-rank ${rankClass}">${idx + 1}</td>
              <td style="font-weight: 600;">${team.team}</td>
              <td style="text-align: center;">${team.matchesPlayed}</td>
              <td style="text-align: center; color: #16a34a; font-weight: 600;">${team.wins}</td>
              <td style="text-align: center; color: #dc2626;">${team.losses}</td>
              <td style="text-align: center; color: #d97706;">${team.ties}</td>
              <td style="text-align: center; font-weight: 700; font-size: 16px;">${team.points}</td>
              <td style="text-align: center; font-weight: 600; color: ${diffColor};">${diffDisplay}</td>
            </tr>
          `;
        });

        html += '</tbody></table>';
        html += '<p style="margin-top: 12px; font-size: 12px; color: #64748b;">* +/- = Score Differential (sum of winning margins). Used as untie criteria when points are equal.</p>';
        container.innerHTML = html;
        
        // Store results for saving to Firebase
        currentMatchPlayResults = {
          standings: standings.map((team, idx) => ({
            rank: idx + 1,
            team: team.team || null,
            matchesPlayed: team.matchesPlayed || 0,
            wins: team.wins || 0,
            losses: team.losses || 0,
            ties: team.ties || 0,
            points: team.points || 0,
            scoreDiff: team.scoreDiff || 0
          })),
          matches: matchResults.map(m => ({
            roundIndex: m.roundIndex !== undefined ? m.roundIndex : null,
            matchType: m.matchType || null,
            leftTeam: m.leftTeam || null,
            rightTeam: m.rightTeam || null,
            leftPlayer: m.leftPlayer ? {
              reg: m.leftPlayer.reg || null,
              firstName: m.leftPlayer.firstName || '',
              lastName: m.leftPlayer.lastName || ''
            } : null,
            rightPlayer: m.rightPlayer ? {
              reg: m.rightPlayer.reg || null,
              firstName: m.rightPlayer.firstName || '',
              lastName: m.rightPlayer.lastName || ''
            } : null,
            leftPlayers: m.leftPlayers ? m.leftPlayers.map(p => ({
              reg: p.reg || null,
              firstName: p.firstName || '',
              lastName: p.lastName || ''
            })) : null,
            rightPlayers: m.rightPlayers ? m.rightPlayers.map(p => ({
              reg: p.reg || null,
              firstName: p.firstName || '',
              lastName: p.lastName || ''
            })) : null,
            leftScore: m.leftScore !== undefined ? m.leftScore : null,
            rightScore: m.rightScore !== undefined ? m.rightScore : null,
            status: m.status || 'pending'
          })),
          calculatedAt: new Date().toISOString()
        };
        console.log('‚úì Match play results stored for saving:', currentMatchPlayResults.standings.length, 'teams,', currentMatchPlayResults.matches.length, 'matches');
        console.log('Sample match with players:', currentMatchPlayResults.matches[0]);
        console.log('All matches leftPlayers check:', currentMatchPlayResults.matches.map(m => ({ matchType: m.matchType, leftPlayers: m.leftPlayers, rightPlayers: m.rightPlayers })));
      }
      
      // Save match play results to Firebase
      async function saveMatchPlayResults() {
        const statusEl = document.getElementById('match-play-save-status');
        
        if (!currentMatchPlayResults) {
          statusEl.style.display = 'block';
          statusEl.style.background = '#fee2e2';
          statusEl.style.color = '#991b1b';
          statusEl.textContent = '‚ùå No match play results to save. Please wait for results to load.';
          setTimeout(() => { statusEl.style.display = 'none'; }, 3000);
          return;
        }
        
        statusEl.style.display = 'block';
        statusEl.style.background = '#dbeafe';
        statusEl.style.color = '#1e40af';
        statusEl.textContent = '‚è≥ Saving match play results to Firebase...';
        
        try {
          const db = firebase.database();
          
          // Find the Firebase key for this tournament
          const tournamentsSnap = await db.ref('tournaments').once('value');
          const tournamentsData = tournamentsSnap.val();
          
          let firebaseKey = null;
          if (tournamentsData) {
            for (const key in tournamentsData) {
              if (tournamentsData[key] && tournamentsData[key].tournamentId === tournamentId) {
                firebaseKey = key;
                break;
              }
            }
          }
          
          if (!firebaseKey) {
            throw new Error('Tournament not found in Firebase');
          }
          
          // Save match play results to Firebase
          await db.ref(`tournaments/${firebaseKey}/calculatedResults/MATCHPLAY`).set(currentMatchPlayResults);
          
          // Also save to localStorage
          const tournaments = getTournaments();
          const index = tournaments.findIndex(t => t.tournamentId === tournamentId);
          if (index !== -1) {
            if (!tournaments[index].calculatedResults) {
              tournaments[index].calculatedResults = {};
            }
            tournaments[index].calculatedResults.MATCHPLAY = currentMatchPlayResults;
            localStorage.setItem('tournaments', JSON.stringify(tournaments));
          }
          
          statusEl.style.background = '#d1fae5';
          statusEl.style.color = '#065f46';
          statusEl.textContent = '‚úÖ Match play results saved to Firebase!';
          console.log('‚úì Match play results saved to Firebase');
          
          setTimeout(() => { statusEl.style.display = 'none'; }, 3000);
        } catch (err) {
          console.error('Error saving match play results:', err);
          statusEl.style.background = '#fee2e2';
          statusEl.style.color = '#991b1b';
          statusEl.textContent = `‚ùå Failed to save: ${err.message}`;
          
          setTimeout(() => { statusEl.style.display = 'none'; }, 5000);
        }
      }

      function loadCategories() {
        const tournament = getTournament();
        console.log('loadCategories - tournament:', tournament);
        console.log('loadCategories - tournament.categories:', tournament?.categories);
        
        if (tournament) {
          document.getElementById('tournament-name').textContent = tournament.name || 'Tournament Results';
        }

        const categories = getCategories();
        console.log('loadCategories - categories:', categories);
        const container = document.getElementById('categories-list');

        if (categories.length === 0) {
          container.innerHTML = '<div class="empty-state">No categories defined yet. Please create categories first.</div>';
          return;
        }

        let html = '';
        categories.forEach((cat, index) => {
          // Get saved preferences or use defaults
          const savedPrefs = getCategoryPreferences(cat.code);
          const displayType = savedPrefs?.display || 'club';
          const showHcp = savedPrefs?.hcp !== undefined ? savedPrefs.hcp : true;
          const showPhcp = savedPrefs?.phcp !== undefined ? savedPrefs.phcp : true;
          const showToPar = savedPrefs?.topar !== undefined ? savedPrefs.topar : false;
          
          // Check if this is the Team category
          const isTeamCategory = cat.code === 'TEAM';
          const untieCriteriaLabel = isTeamCategory ? '‚öñÔ∏è Team Untie Criteria' : '‚öñÔ∏è Untie Criteria';
          
          html += `
            <div class="category-item">
              <div class="category-header">
                <div class="category-name">${cat.name}</div>
              </div>
              
              <div class="options-grid">
                <div class="option-group">
                  <label>Display Club or Nationality</label>
                  <select id="display-${index}" data-category-index="${index}" onchange="savePreferences(${index})">
                    <option value="club" ${displayType === 'club' ? 'selected' : ''}>Club</option>
                    <option value="country" ${displayType === 'country' ? 'selected' : ''}>Country</option>
                    <option value="none" ${displayType === 'none' ? 'selected' : ''}>None</option>
                  </select>
                </div>

                <div class="option-group">
                  <label>HCP (WHS Handicap)</label>
                  <div class="checkbox-wrapper">
                    <input type="checkbox" id="hcp-${index}" data-category-index="${index}" ${showHcp ? 'checked' : ''} onchange="savePreferences(${index})">
                    <span>Show HCP</span>
                  </div>
                </div>

                <div class="option-group">
                  <label>PHCP (Playing Handicap)</label>
                  <div class="checkbox-wrapper">
                    <input type="checkbox" id="phcp-${index}" data-category-index="${index}" ${showPhcp ? 'checked' : ''} onchange="savePreferences(${index})">
                    <span>Show PHCP</span>
                  </div>
                </div>

                <div class="option-group">
                  <label>To Par</label>
                  <div class="checkbox-wrapper">
                    <input type="checkbox" id="topar-${index}" data-category-index="${index}" ${showToPar ? 'checked' : ''} onchange="savePreferences(${index})">
                    <span>Show To Par</span>
                  </div>
                </div>
              </div>

              <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                <button class="btn btn-show" onclick="showResults(${index})">Show Results</button>
                <button class="btn" style="background: linear-gradient(180deg, #8b5cf6, #7c3aed);" onclick="openUntieCriteria('${cat.code}')">${untieCriteriaLabel}</button>
              </div>
            </div>
          `;
        });

        container.innerHTML = html;
      }

      function savePreferences(categoryIndex) {
        const categories = getCategories();
        const category = categories[categoryIndex];
        
        if (!category) return;
        
        const prefs = {
          display: document.getElementById(`display-${categoryIndex}`).value,
          hcp: document.getElementById(`hcp-${categoryIndex}`).checked,
          phcp: document.getElementById(`phcp-${categoryIndex}`).checked,
          topar: document.getElementById(`topar-${categoryIndex}`).checked
        };
        
        saveCategoryPreferences(category.code, prefs);
      }

      function showResults(categoryIndex) {
        const categories = getCategories();
        const category = categories[categoryIndex];
        
        if (!category) {
          alert('Category not found');
          return;
        }

        // Get selected options
        const displayType = document.getElementById(`display-${categoryIndex}`).value;
        const showHcp = document.getElementById(`hcp-${categoryIndex}`).checked;
        const showPhcp = document.getElementById(`phcp-${categoryIndex}`).checked;
        const showToPar = document.getElementById(`topar-${categoryIndex}`).checked;

        // Store configuration in URL parameters
        const params = new URLSearchParams({
          tournamentId: tournamentId,
          categoryCode: category.code,
          categoryName: category.name,
          display: displayType,
          hcp: showHcp ? 'yes' : 'no',
          phcp: showPhcp ? 'yes' : 'no',
          topar: showToPar ? 'yes' : 'no'
        });

        // Open results display page (will be created next)
        window.open(`results_display.html?${params.toString()}`, '_blank');
      }

      // Generate results for all categories and save to Firebase
      async function generateAllResults() {
        const categories = getCategories();
        const statusEl = document.getElementById('generate-status');
        const tournament = getTournament();
        
        if (categories.length === 0) {
          alert('No categories found');
          return;
        }
        
        if (!tournament) {
          alert('Tournament not found');
          return;
        }
        
        statusEl.style.display = 'block';
        statusEl.style.background = '#dbeafe';
        statusEl.style.color = '#1e40af';
        statusEl.textContent = `Generating results for ${categories.length} categories...`;
        
        const roundIds = tournament.meta?.roundIds || [];
        const scores = JSON.parse(localStorage.getItem('scores') || '{}');
        const admittedPlayers = JSON.parse(localStorage.getItem('admittedPlayers') || '{}');
        const courses = JSON.parse(localStorage.getItem('courses') || '[]');
        
        // Get all players from first round
        const allPlayers = admittedPlayers[roundIds[0]] || [];
        
        let successCount = 0;
        let errorCount = 0;
        
        // Initialize Firebase database reference
        const db = firebase.database();
        
        // Find the Firebase key for this tournament
        let firebaseKey = null;
        try {
          const tournamentsSnap = await db.ref('tournaments').once('value');
          const tournamentsData = tournamentsSnap.val();
          if (tournamentsData) {
            for (const key in tournamentsData) {
              if (tournamentsData[key] && tournamentsData[key].tournamentId === tournamentId) {
                firebaseKey = key;
                break;
              }
            }
          }
        } catch (e) {
          console.error('Error finding tournament in Firebase:', e);
        }
        
        if (!firebaseKey) {
          statusEl.style.background = '#fee2e2';
          statusEl.style.color = '#991b1b';
          statusEl.textContent = 'Error: Could not find tournament in Firebase';
          return;
        }
        
        for (let i = 0; i < categories.length; i++) {
          const category = categories[i];
          statusEl.textContent = `Processing ${i + 1}/${categories.length}: ${category.name}...`;
          
          try {
            // Get players in this category
            // PRIORITY: Use stored categoryAssignments from tournament (single source of truth)
            let storedPlayerIds = tournament.categoryAssignments?.[category.code];
            
            // Firebase may return arrays as objects with numeric keys - convert back to array
            if (storedPlayerIds && !Array.isArray(storedPlayerIds)) {
              storedPlayerIds = Object.values(storedPlayerIds);
            }
            
            let categoryPlayers;
            if (storedPlayerIds && storedPlayerIds.length > 0) {
              // Use stored category assignments
              categoryPlayers = allPlayers.filter(player => {
                const playerId = player.reg || player.id;
                return storedPlayerIds.includes(playerId);
              });
              console.log(`Category ${category.code}: Using stored assignments (${categoryPlayers.length} players)`);
            } else {
              // FALLBACK: Check player-level categories or calculate on-the-fly
              categoryPlayers = allPlayers.filter(player => {
                // Check if player has stored categories
                if (player.categories && Array.isArray(player.categories) && player.categories.length > 0) {
                  return player.categories.includes(category.code);
                }
                if (player.category) {
                  return player.category === category.code;
                }
                // Fallback: calculate categories on-the-fly
                const calculatedCats = getPlayerCategories(player, tournament);
                return calculatedCats.includes(category.code);
              });
              console.log(`Category ${category.code}: Calculated on-the-fly (${categoryPlayers.length} players)`);
            }
            
            if (categoryPlayers.length === 0) {
              console.log(`No players in category ${category.name}, skipping...`);
              successCount++;
              continue;
            }
            
            // Determine tournament type
            const tournamentType = (category.tournamentType || 'Stroke Play').toUpperCase();
            const isStableford = tournamentType.includes('STABLEFORD');
            const isStrokePlay = !isStableford;
            
            // Helper function to check for incomplete holes
            function playerHasIncompleteHoles(playerId) {
              for (const roundId of roundIds) {
                const playerScore = scores[roundId]?.[playerId];
                if (!playerScore) continue;
                if (playerScore.incompleteHoles && playerScore.incompleteHoles.length > 0) return true;
                if (playerScore.isIncompleteHole) {
                  if (Object.values(playerScore.isIncompleteHole).some(v => v === true)) return true;
                }
              }
              return false;
            }
            
            // Filter players for Stroke Play
            let eligiblePlayers = categoryPlayers;
            if (isStrokePlay) {
              eligiblePlayers = categoryPlayers.filter(p => !playerHasIncompleteHoles(p.reg || p.id));
            }
            
            // Calculate scores
            const results = eligiblePlayers.map(player => {
              const playerId = player.reg || player.id || player.odaNo;
              const roundScores = [];
              let total = 0;
              let hasAnyScore = false;
              let playerStatus = null;
              
              roundIds.forEach(roundId => {
                const playerScore = scores[roundId]?.[playerId];
                if (playerScore) {
                  hasAnyScore = true;
                  
                  // Check for status
                  const status = playerScore.status || playerScore.playerStatus;
                  if (status && status !== 'OK' && ['NS', 'NR', 'DQ', 'WD', 'DNF', 'RTD'].includes(status.toUpperCase())) {
                    playerStatus = status.toUpperCase();
                  }
                  
                  if (isStableford) {
                    const stbPoints = playerScore.stablefordPoints || [];
                    const roundTotal = stbPoints.reduce((sum, p) => sum + (parseInt(p) || 0), 0);
                    roundScores.push(roundTotal);
                    total += roundTotal;
                  } else {
                    const holes = playerScore.holes || [];
                    const roundTotal = holes.reduce((sum, h) => sum + (parseInt(h) || 0), 0);
                    roundScores.push(roundTotal);
                    total += roundTotal;
                  }
                } else {
                  roundScores.push('-');
                }
              });
              
              return {
                type: 'individual',
                reg: playerId,
                firstName: player.firstName,
                lastName: player.lastName,
                club: player.club || player.homeClub,
                nationality: player.nationality || player.country,
                hcp: player.hcp,
                phcp: player.phcp,
                roundScores,
                total: hasAnyScore ? total : null,
                status: playerStatus,
                hasStatus: !!playerStatus
              };
            }).filter(r => r.total !== null || r.hasStatus);
            
            // Sort results
            results.sort((a, b) => {
              if (a.hasStatus && !b.hasStatus) return 1;
              if (!a.hasStatus && b.hasStatus) return -1;
              if (a.hasStatus && b.hasStatus) return 0;
              if (a.total === null) return 1;
              if (b.total === null) return -1;
              return isStableford ? (b.total - a.total) : (a.total - b.total);
            });
            
            // Assign ranks
            let rank = 1;
            results.forEach((r, idx) => {
              if (r.hasStatus) {
                r.rank = r.status;
              } else if (idx > 0 && r.total === results[idx - 1].total && !results[idx - 1].hasStatus) {
                r.rank = results[idx - 1].rank;
              } else {
                r.rank = rank;
              }
              if (!r.hasStatus) rank++;
            });
            
            // Save to Firebase
            await db.ref(`tournaments/${firebaseKey}/calculatedResults/${category.code}`).set({
              results: results,
              calculatedAt: new Date().toISOString()
            });
            
            console.log(`‚úì Results saved for category ${category.name}`);
            successCount++;
            
          } catch (err) {
            console.error(`Error generating results for ${category.name}:`, err);
            errorCount++;
          }
        }
        
        // Show final status
        if (errorCount === 0) {
          statusEl.style.background = '#dcfce7';
          statusEl.style.color = '#166534';
          statusEl.textContent = `‚úì Successfully generated results for all ${successCount} categories! Public results page will now show correct rankings.`;
        } else {
          statusEl.style.background = '#fef3c7';
          statusEl.style.color = '#92400e';
          statusEl.textContent = `Generated ${successCount} categories, ${errorCount} failed. Check console for errors.`;
        }
        
        // Hide status after 10 seconds
        setTimeout(() => {
          statusEl.style.display = 'none';
        }, 10000);
      }

      function checkAllScoresComplete() {
        const tournament = getTournament();
        const roundIds = tournament?.meta?.roundIds || [];
        const categories = getCategories();
        
        let incompleteCount = 0;
        const incompleteDetails = [];
        
        categories.forEach(category => {
          const tournament = getTournament();
          const isTeamTournament = tournament?.meta?.teamsTournament === 'yes';
          const isTeamCategory = category.code === 'TEAM';
          
          // PRIORITY: Use stored categoryAssignments (single source of truth)
          let storedPlayerIds = tournament?.categoryAssignments?.[category.code];
          
          // Firebase may return arrays as objects with numeric keys - convert back to array
          if (storedPlayerIds && !Array.isArray(storedPlayerIds)) {
            storedPlayerIds = Object.values(storedPlayerIds);
          }
          
          const allAdmittedPlayers = getAdmittedPlayers();
          
          let players;
          if (storedPlayerIds && storedPlayerIds.length > 0) {
            // Use stored assignments
            players = allAdmittedPlayers.filter(player => {
              const playerId = player.reg || player.id;
              // In team tournaments, all players belong to TEAM category
              if (isTeamTournament && isTeamCategory) {
                return true;
              }
              return storedPlayerIds.includes(playerId);
            });
          } else {
            // FALLBACK: Check player-level categories or calculate
            players = allAdmittedPlayers.filter(player => {
              // In team tournaments, all players belong to TEAM category
              if (isTeamTournament && isTeamCategory) {
                return true;
              }
              // First check if player has stored categories
              if (player.categories && Array.isArray(player.categories) && player.categories.length > 0) {
                return player.categories.includes(category.code);
              }
              if (player.category) {
                return player.category === category.code;
              }
              // Fallback: calculate categories on-the-fly
              const calculatedCats = getPlayerCategories(player, tournament);
              return calculatedCats.includes(category.code);
            });
          }
          
          players.forEach(player => {
            roundIds.forEach(roundId => {
              const scores = JSON.parse(localStorage.getItem('scores') || '{}');
              const playerScores = scores[roundId]?.[player.reg];
              
              if (!playerScores) {
                incompleteCount++;
                incompleteDetails.push(`${player.firstName} ${player.lastName} (${category.name})`);
                return;
              }
              
              if (playerScores.status && playerScores.status !== 'OK') {
                return; // Has status, considered complete
              }
              
              if (playerScores.holes && Array.isArray(playerScores.holes)) {
                const completedHoles = playerScores.holes.filter(s => s !== '' && s !== null && s !== undefined).length;
                if (completedHoles !== 18) {
                  incompleteCount++;
                  incompleteDetails.push(`${player.firstName} ${player.lastName} (${category.name}) - Round ${roundIds.indexOf(roundId) + 1}`);
                }
              } else {
                incompleteCount++;
                incompleteDetails.push(`${player.firstName} ${player.lastName} (${category.name})`);
              }
            });
          });
        });
        
        return { complete: incompleteCount === 0, incompleteCount, incompleteDetails };
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          const tournament = getTournament();
          if (!tournament || !tournament.meta || !tournament.meta.roundIds) return [];
          
          const allPlayers = [];
          tournament.meta.roundIds.forEach(roundId => {
            if (data[roundId]) {
              data[roundId].forEach(player => {
                if (!allPlayers.find(p => p.reg === player.reg)) {
                  allPlayers.push(player);
                }
              });
            }
          });
          
          return allPlayers;
        } catch (err) {
          console.error('Error loading admitted players:', err);
          return [];
        }
      }

      function openWinnersList() {
        const tournament = getTournament();
        if (!tournament) {
          alert('Tournament not found');
          return;
        }

        const categories = getCategories();
        if (categories.length === 0) {
          alert('No categories defined. Please create categories first.');
          return;
        }

        // Check if all scores are complete
        const completionStatus = checkAllScoresComplete();
        if (!completionStatus.complete) {
          const proceed = confirm(`Warning: ${completionStatus.incompleteCount} incomplete scorecard(s) found.\n\nThe winners list should only be generated when all tournament rounds are complete.\n\nDo you want to continue anyway?`);
          if (!proceed) {
            return;
          }
        }

        // Create custom modal for input
        const modalHTML = `
          <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;" id="winners-modal">
            <div style="background: white; border-radius: 12px; padding: 32px; max-width: 400px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
              <h2 style="margin: 0 0 24px 0; font-size: 20px; color: #1e293b;">Winners List Settings</h2>
              
              <div style="margin-bottom: 20px;">
                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #475569; font-size: 14px;">Number of winners per category</label>
                <input type="number" id="num-winners-input" value="3" min="1" style="width: 100%; padding: 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 14px;">
              </div>
              
              <div style="margin-bottom: 24px;">
                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #475569; font-size: 14px;">Display Order</label>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                  <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="order" value="ascending" checked style="margin-right: 8px; width: 18px; height: 18px;">
                    <span style="font-size: 14px;">Ascending (1st ‚Üí 3rd)</span>
                  </label>
                  <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="order" value="descending" style="margin-right: 8px; width: 18px; height: 18px;">
                    <span style="font-size: 14px;">Descending (3rd ‚Üí 1st)</span>
                  </label>
                </div>
              </div>
              
              <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeWinnersModal()" style="background: white; color: #64748b; border: 1px solid #e5e7eb; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">Cancel</button>
                <button onclick="generateWinners()" style="background: linear-gradient(180deg, #f59e0b, #d97706); color: white; border: 0; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">Generate</button>
              </div>
            </div>
          </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHTML);
      }

      function closeWinnersModal() {
        const modal = document.getElementById('winners-modal');
        if (modal) modal.remove();
      }

      function generateWinners() {
        const numWinners = document.getElementById('num-winners-input').value;
        const order = document.querySelector('input[name="order"]:checked').value;
        
        if (!numWinners || isNaN(numWinners) || parseInt(numWinners) < 1) {
          alert('Please enter a valid number of winners');
          return;
        }

        closeWinnersModal();

        // Open winners list page
        const params = new URLSearchParams({
          tournamentId: tournamentId,
          numWinners: numWinners,
          order: order
        });

        window.open(`winners_list.html?${params.toString()}`, '_blank');
      }

      function openUntieCriteria(categoryCode) {
        if (categoryCode === 'TEAM' || categoryCode === 'MATCH') {
          window.location.href = `untie_criteria.html?tournamentId=${tournamentId}&categoryCode=${categoryCode}`;
        } else {
          window.location.href = `untie_criteria.html?tournamentId=${tournamentId}`;
        }
      }

      function openPlayOff() {
        window.location.href = `play_off.html?tournamentId=${tournamentId}`;
      }

      // Initialize page - load from Firebase first, then setup UI
      async function init() {
        await loadFromFirebase();
        
        // Also load draws and match scores for match play
        if (typeof syncFromFirebase !== 'undefined' && syncEnabled) {
          try {
            const drawsData = await syncFromFirebase('draws');
            if (drawsData) {
              localStorage.setItem('draws', JSON.stringify(drawsData));
              console.log('‚úì Draws loaded from Firebase');
            }
            const matchScoresData = await syncFromFirebase('matchScores');
            if (matchScoresData) {
              localStorage.setItem('matchScores', JSON.stringify(matchScoresData));
              console.log('‚úì Match scores loaded from Firebase');
            }
            // Load hole-by-hole scores for match play
            const holeByHoleScoresData = await syncFromFirebase('holeByHoleScores');
            if (holeByHoleScoresData) {
              localStorage.setItem('holeByHoleScores', JSON.stringify(holeByHoleScoresData));
              console.log('‚úì Hole-by-hole scores loaded from Firebase');
            }
          } catch(e) {
            console.log('Firebase load error:', e);
          }
        }
        
        const tournament = getTournament();
        if (tournament) {
          document.getElementById('tournament-name').textContent = tournament.name || 'Tournament Results';
        }
        
        // Show appropriate section based on tournament type
        if (isMatchPlayTournament()) {
          // Show match play results section
          document.getElementById('stroke-play-section').style.display = 'none';
          document.getElementById('match-play-section').style.display = 'block';
          initMatchPlayResults();
        } else {
          // Show stroke play categories section
          document.getElementById('stroke-play-section').style.display = 'block';
          document.getElementById('match-play-section').style.display = 'none';
          ensureDefaultCategory();
          loadCategories();
        }
      }

      // Load on page load
      init();
    </script>
  </body>
</html>
