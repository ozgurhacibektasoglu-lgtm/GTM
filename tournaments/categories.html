<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tournament Categories</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      .categories-container { max-width: 1200px; margin: 36px auto; padding: 24px; }
      .top-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 24px; }
      .card { background: #fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(2,6,23,0.06); padding: 20px; }
      .card h2 { margin-top: 0; font-size: 18px; margin-bottom: 16px; }
      .summary-table { background: #fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(2,6,23,0.06); padding: 20px; }
      .summary-table h2 { margin-top: 0; font-size: 18px; margin-bottom: 16px; }
      .summary-table table { width: 100%; border-collapse: collapse; }
      .summary-table th { background: #f3f4f6; font-weight: 600; text-align: left; padding: 10px 12px; border-bottom: 2px solid #e5e7eb; font-size: 13px; }
      .summary-table td { padding: 10px 12px; border-bottom: 1px solid #e5e7eb; font-size: 14px; }
      .summary-table tr:last-child td { border-bottom: none; }
      .summary-empty { text-align: center; color: #6b7280; padding: 20px; font-size: 14px; }
      .table-wrapper { background: #fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(2,6,23,0.06); margin-bottom: 24px; overflow-x: auto; }
      table { width: 100%; border-collapse: collapse; }
      th { background: #f3f4f6; font-weight: 600; text-align: left; padding: 12px 16px; border-bottom: 2px solid #e5e7eb; }
      td { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; }
      tr { cursor: pointer; }
      tr.selected { background: #dbeafe; }
      tbody tr:hover { background: #f0f9ff; }
      tbody tr.dragging { opacity: 0.5; }
      tbody tr.drag-over { border-top: 3px solid #0b6efd; }
      .drag-handle { cursor: grab; color: #94a3b8; padding: 0 8px; user-select: none; font-size: 18px; }
      .drag-handle:active { cursor: grabbing; }
      .action-buttons { display: flex; flex-wrap: wrap; gap: 10px; }
      .btn { background: linear-gradient(180deg, var(--accent), #0a58d1); color: white; border: 0; padding: 10px 14px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: transform 0.08s; }
      .btn:active { transform: translateY(1px); }
      .btn-back { background: white; color: #0b6efd; border: 1px solid #e6e9ef; }
      .btn-delete { background: linear-gradient(180deg, #dc2626, #b91c1c); }
      .form-group { margin-bottom: 12px; }
      .form-group label { display: block; font-weight: 600; margin-bottom: 4px; color: #1e293b; font-size: 13px; }
      .form-group input, .form-group select { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 14px; }
      .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
      @media (max-width: 900px) { .top-section { grid-template-columns: 1fr; } .form-row { grid-template-columns: 1fr; } }
      
      /* Auto categorize modal */
      .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 100; align-items: center; justify-content: center; }
      .modal-overlay.active { display: flex; }
      .modal-content { background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
      .modal-content h3 { margin-top: 0; margin-bottom: 20px; font-size: 20px; }
      .modal-field { margin-bottom: 16px; }
      .modal-field label { display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px; }
      .modal-field select, .modal-field input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 14px; }
      .modal-actions { display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px; }
      .btn-secondary { background: #6b7280; }
      .btn-auto { background: linear-gradient(180deg, #059669, #047857); }
    </style>
  </head>
  <body>
    <main class="categories-container">
      <header>
        <h1>Tournament Categories</h1>
        <p class="lead" id="tournament-name">Managing categories</p>
      </header>

      <div class="top-section">
        <div class="card">
        <h2 id="form-title" style="margin-top: 0; font-size: 18px;">Add Category</h2>
        <form id="category-form">
          <div class="form-row">
            <div class="form-group">
              <label for="category-name">Category Name *</label>
              <input type="text" id="category-name" required placeholder="e.g., Men's Championship">
            </div>
            <div class="form-group">
              <label for="gender">Gender</label>
              <select id="gender">
                <option value="">Any</option>
                <option value="Male">Male</option>
                <option value="Female">Female</option>
              </select>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="handicap-min">Minimum Handicap</label>
              <input type="number" id="handicap-min" step="0.1" placeholder="e.g., 0.0">
            </div>
            <div class="form-group">
              <label for="handicap-max">Maximum Handicap</label>
              <input type="number" id="handicap-max" step="0.1" placeholder="e.g., 54.0">
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="age-min">Minimum Age</label>
              <input type="number" id="age-min" placeholder="e.g., 18">
            </div>
            <div class="form-group">
              <label for="age-max">Maximum Age</label>
              <input type="number" id="age-max" placeholder="e.g., 99">
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="tournament-type">Tournament Type</label>
              <select id="tournament-type">
                <option value="">Any</option>
                <option value="Stroke Play">Stroke Play</option>
                <option value="Medal Net">Medal Net</option>
                <option value="Stableford Net">Stableford Net</option>
              </select>
            </div>
            <div class="form-group">
              <label for="plays-from">Category Plays From:</label>
              <select id="plays-from">
                <option value="">Select tee...</option>
              </select>
            </div>
          </div>
          <div class="form-group" style="margin-bottom: 8px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
              <input type="checkbox" id="result-only" style="width: auto; cursor: pointer;">
              <span style="font-weight: 600;">Result-only category (Gross, Junior, Senior, etc.)</span>
            </label>
            <div style="font-size: 12px; color: #64748b; margin-top: 4px; margin-left: 28px;">
              This category will not assign tees or appear in the summary table. Use for additional result categories like Gross, Junior, Senior, etc.
            </div>
          </div>
          <div class="action-buttons">
            <button type="submit" class="btn" id="btn-submit">Add Category</button>
            <button type="button" class="btn" id="btn-clear" style="background: white; color: #0b6efd; border: 1px solid #e6e9ef;">Clear</button>
            <button type="button" class="btn" id="btn-cancel-edit" style="background: #dc3545; color: white; display: none;">Cancel Edit</button>
          </div>
        </form>
        </div>

        <div class="summary-table">
          <h2>Category Summary</h2>
          <div id="summary-content">
            <div class="summary-empty">No categories defined yet</div>
          </div>
        </div>
      </div>

      <div class="table-wrapper">
        <table id="categories-table">
          <thead>
            <tr>
              <th style="width: 40px;"></th>
              <th>Category Name</th>
              <th>Handicap Range</th>
              <th>Age Range</th>
              <th>Gender</th>
              <th>Type</th>
              <th>Plays From</th>
              <th>No Players</th>
              <th>Percentage</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="categories-body">
            <tr>
              <td colspan="9" style="text-align: center; color: #6b7280;">No categories yet. Add a category above.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="action-buttons">
        <button class="btn btn-auto" id="btn-auto-categorize">ü§ñ Auto Categorize</button>
        <button class="btn" id="btn-show-players" style="background: linear-gradient(180deg, #10b981, #059669);">Show Players in Categories</button>
        <a href="index.html" class="btn btn-back">Back to Tournaments</a>
      </div>
      
      <!-- Auto Categorize Modal -->
      <div class="modal-overlay" id="auto-categorize-modal">
        <div class="modal-content">
          <h3>Auto Categorize Players</h3>
          
          <div class="modal-field">
            <label for="modal-gender-split">Gender Split:</label>
            <select id="modal-gender-split">
              <option value="separated">Separated (Men & Women)</option>
              <option value="mixed">Mixed</option>
            </select>
          </div>
          
          <div class="modal-field" id="field-mixed-categories" style="display: none;">
            <label for="modal-mixed-count">Number of Categories:</label>
            <select id="modal-mixed-count">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
          </div>
          
          <div id="field-separated-categories">
            <div class="modal-field">
              <label for="modal-men-count">Number of Men Categories:</label>
              <select id="modal-men-count">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
              </select>
            </div>
            
            <div class="modal-field">
              <label for="modal-women-count">Number of Women Categories:</label>
              <select id="modal-women-count">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
              </select>
            </div>
          </div>
          
          <div class="modal-actions">
            <button class="btn btn-secondary" id="btn-cancel-auto">Cancel</button>
            <button class="btn btn-auto" id="btn-generate-categories">Generate Categories</button>
          </div>
        </div>
      </div>
    </main>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');

      if (!tournamentId) {
        alert('No tournament selected. Redirecting to tournaments page.');
        window.location.href = 'index.html';
      }

      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function saveTournaments(list) {
        localStorage.setItem('tournaments', JSON.stringify(list || []));
      }

      function getTournament() {
        const tournaments = getTournaments();
        return tournaments.find(t => t.tournamentId === tournamentId);
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse courses', err);
          return [];
        }
      }

      function getCategories() {
        const tournament = getTournament();
        console.log('getCategories - tournament:', tournament);
        console.log('getCategories - categories:', tournament?.categories);
        return tournament?.categories || [];
      }

      function saveCategories(categories) {
        const tournaments = getTournaments();
        const index = tournaments.findIndex(t => t.tournamentId === tournamentId);
        if (index !== -1) {
          tournaments[index].categories = categories;
          saveTournaments(tournaments);
        }
      }

      // Auto-generate category code
      function generateCategoryCode(name, existingCategories) {
        // Create base code from first letters of words (up to 3 letters)
        const words = name.trim().split(/\s+/);
        let code = words.map(w => w.charAt(0).toUpperCase()).join('').substring(0, 3);
        
        // If code already exists, append a number
        let counter = 1;
        let finalCode = code;
        while (existingCategories.some(cat => cat.code === finalCode)) {
          finalCode = code + counter;
          counter++;
        }
        
        return finalCode;
      }

      // Display tournament name
      const tournament = getTournament();
      if (tournament) {
        document.getElementById('tournament-name').textContent = `Managing categories for: ${tournament.name}`;
      }

      // Get tee display name from tee ID
      function getTeeDisplayName(teeValue) {
        if (!teeValue) return '-';
        
        // Handle format: courseId||teeIndex (e.g., "C001||1")
        if (teeValue.includes('||')) {
          const [courseId, teeIndexStr] = teeValue.split('||');
          const teeIndex = parseInt(teeIndexStr, 10);
          
          const courses = getCourses();
          const course = courses.find(c => c.courseId === courseId || c.fullName === courseId);
          
          if (course && Array.isArray(course.tees) && course.tees[teeIndex]) {
            return course.tees[teeIndex];
          }
        }
        
        // Fallback: return the raw value
        return teeValue;
      }

      // Get tournament course and populate tees
      function loadAvailableTees(selectedGender) {
        const playsFromSelect = document.getElementById('plays-from');
        playsFromSelect.innerHTML = '<option value="">Select tee...</option>';

        const tournament = getTournament();
        if (!tournament || !tournament.meta) return;

        // Get course IDs from tournament
        const courseIds = tournament.meta.roundsData 
          ? tournament.meta.roundsData.map(r => r.course).filter(Boolean)
          : (tournament.meta.courses || []);

        if (courseIds.length === 0) return;

        const courses = getCourses();
        const uniqueTees = new Map(); // Use Map to avoid duplicates

        courseIds.forEach(courseId => {
          const course = courses.find(c => c.courseId === courseId);
          if (!course || !course.tees || !course.genders) return;

          course.tees.forEach((teeName, idx) => {
            const teeGender = course.genders[idx];
            
            // Filter based on selected gender
            if (selectedGender === 'Male' && teeGender !== 'M' && teeGender !== 'B') return;
            if (selectedGender === 'Female' && teeGender !== 'F' && teeGender !== 'B') return;
            
            // Create display name
            const displayName = `${teeName}${course.fullName ? ' - ' + course.fullName : ''}`;
            const teeId = course.teeIds && course.teeIds[idx] 
              ? (typeof course.teeIds[idx] === 'object' 
                  ? (selectedGender === 'Female' ? course.teeIds[idx].women : course.teeIds[idx].men)
                  : course.teeIds[idx])
              : `${courseId}-${teeName}`;
            
            uniqueTees.set(teeId, displayName);
          });
        });

        // Add options
        uniqueTees.forEach((displayName, teeId) => {
          const option = document.createElement('option');
          option.value = teeId;
          option.textContent = displayName;
          playsFromSelect.appendChild(option);
        });
      }

      // Update tees when gender changes
      document.getElementById('gender').addEventListener('change', function() {
        loadAvailableTees(this.value);
      });

      // Initial load
      loadAvailableTees('');

      let selectedCategoryIndex = null;
      let draggedRow = null;

      // Drag and drop handlers
      function handleDragStart(e) {
        draggedRow = this;
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
      }

      function handleDragOver(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        e.dataTransfer.dropEffect = 'move';
        
        if (this !== draggedRow) {
          this.classList.add('drag-over');
        }
        return false;
      }

      function handleDrop(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        
        if (draggedRow !== this) {
          const categories = getCategories();
          const draggedIndex = parseInt(draggedRow.dataset.index);
          const targetIndex = parseInt(this.dataset.index);
          
          // Reorder categories array
          const draggedCategory = categories[draggedIndex];
          categories.splice(draggedIndex, 1);
          categories.splice(targetIndex, 0, draggedCategory);
          
          saveCategories(categories);
          loadCategories();
        }
        
        return false;
      }

      function handleDragEnd(e) {
        this.classList.remove('dragging');
        document.querySelectorAll('#categories-body tr').forEach(row => {
          row.classList.remove('drag-over');
        });
      }

      // Check for overlapping categories
      function checkCategoryOverlaps() {
        const categories = getCategories();
        const admittedPlayers = getAdmittedPlayers();
        
        if (categories.length < 2) return { hasOverlaps: false, overlaps: [] };
        
        const categoryPairMap = new Map(); // Map category pairs to players
        
        admittedPlayers.forEach(player => {
          const matchingCategories = [];
          
          categories.forEach((cat, idx) => {
            // Skip result-only categories from overlap detection
            if (cat.isResultOnly) {
              return;
            }
            
            // Check if player's gender matches category
            const playerGender = (player.gender || '').toLowerCase();
            const catGender = (cat.gender || '').toLowerCase();
            
            let genderMatch = false;
            if (!catGender || catGender === 'any' || catGender === '') {
              genderMatch = true;
            } else if (catGender === 'male' && (playerGender === 'm' || playerGender === 'male')) {
              genderMatch = true;
            } else if (catGender === 'female' && (playerGender === 'f' || playerGender === 'female')) {
              genderMatch = true;
            }
            
            if (genderMatch && playerMatchesCategory(player, cat)) {
              matchingCategories.push({ index: idx, name: cat.name });
            }
          });
          
          // If player fits multiple categories, record the category pairs
          if (matchingCategories.length > 1) {
            const categoryNames = matchingCategories.map(c => c.name).sort().join(' & ');
            if (!categoryPairMap.has(categoryNames)) {
              categoryPairMap.set(categoryNames, []);
            }
            categoryPairMap.get(categoryNames).push(`${player.firstName} ${player.lastName} (${player.reg})`);
          }
        });
        
        const overlaps = [];
        let totalOverlappingPlayers = 0;
        
        categoryPairMap.forEach((players, categoryPair) => {
          overlaps.push({
            categories: categoryPair,
            players: players,
            count: players.length
          });
          totalOverlappingPlayers += players.length;
        });
        
        // Sort by number of players (descending)
        overlaps.sort((a, b) => b.count - a.count);
        
        return { hasOverlaps: overlaps.length > 0, overlaps, count: totalOverlappingPlayers };
      }

      // Update summary table
      function updateSummaryTable() {
        const summaryContent = document.getElementById('summary-content');
        const categories = getCategories();
        
        // Calculate total admitted players by gender
        const admittedPlayers = getAdmittedPlayers();
        const menPlayers = admittedPlayers.filter(p => {
          const gender = (p.gender || '').toLowerCase();
          return gender === 'm' || gender === 'male';
        });
        const womenPlayers = admittedPlayers.filter(p => {
          const gender = (p.gender || '').toLowerCase();
          return gender === 'f' || gender === 'female';
        });
        const totalMen = menPlayers.length;
        const totalWomen = womenPlayers.length;
        const totalPlayers = admittedPlayers.length;
        
        // Check for overlaps only if there are categories
        const overlapCheck = categories.length > 0 ? checkCategoryOverlaps() : { hasOverlaps: false, overlaps: [], count: 0 };
        
        let warningHTML = '';
        if (overlapCheck.hasOverlaps) {
          warningHTML = `
            <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <span style="font-size: 20px;">‚ö†Ô∏è</span>
                <strong style="color: #92400e;">Category Overlap Warning</strong>
              </div>
              <div style="color: #78350f; font-size: 13px; margin-bottom: 8px;">
                ${overlapCheck.count} player(s) fit into multiple categories. Each player should belong to only one category.
              </div>
              <details style="color: #78350f; font-size: 12px;">
                <summary style="cursor: pointer; font-weight: 600; margin-bottom: 4px;">View overlapping categories</summary>
                <div style="margin: 8px 0 0 0;">
                  ${overlapCheck.overlaps.map(o => `
                    <div style="margin-bottom: 12px; padding: 8px; background: white; border-radius: 4px;">
                      <div style="font-weight: 600; margin-bottom: 4px;">${o.categories} (${o.count} player${o.count > 1 ? 's' : ''})</div>
                      <ul style="margin: 4px 0 0 0; padding-left: 20px;">
                        ${o.players.map(p => `<li>${p}</li>`).join('')}
                      </ul>
                    </div>
                  `).join('')}
                </div>
              </details>
            </div>
          `;
        }
        
        let tableHTML = '<table><thead><tr><th>Category</th><th>Men</th><th>Women</th><th>Total</th></tr></thead><tbody>';
        
        let categorizedMen = 0;
        let categorizedWomen = 0;
        
        let totalCategorizedMen = 0;
        let totalCategorizedWomen = 0;
        
        categories.forEach(cat => {
          // Skip result-only categories from summary table
          if (cat.isResultOnly) {
            return;
          }
          
          // Calculate men in category
          let menInCategory = 0;
          let womenInCategory = 0;
          
          if (!cat.gender || cat.gender === 'Any' || cat.gender === '') {
            // Category accepts both genders
            menInCategory = menPlayers.filter(p => playerMatchesCategory(p, cat)).length;
            womenInCategory = womenPlayers.filter(p => playerMatchesCategory(p, cat)).length;
          } else if (cat.gender.toLowerCase() === 'male') {
            menInCategory = menPlayers.filter(p => playerMatchesCategory(p, cat)).length;
          } else if (cat.gender.toLowerCase() === 'female') {
            womenInCategory = womenPlayers.filter(p => playerMatchesCategory(p, cat)).length;
          }
          
          categorizedMen += menInCategory;
          categorizedWomen += womenInCategory;
          totalCategorizedMen += menInCategory;
          totalCategorizedWomen += womenInCategory;
          
          const menPct = totalMen > 0 ? ((menInCategory / totalMen) * 100).toFixed(1) + '%' : '0%';
          const womenPct = totalWomen > 0 ? ((womenInCategory / totalWomen) * 100).toFixed(1) + '%' : '0%';
          const totalInCat = menInCategory + womenInCategory;
          
          const menDisplay = menInCategory > 0 ? `${menInCategory} (${menPct})` : '-';
          const womenDisplay = womenInCategory > 0 ? `${womenInCategory} (${womenPct})` : '-';
          
          tableHTML += `
            <tr>
              <td>${escapeHtml(cat.name)}</td>
              <td>${menDisplay}</td>
              <td>${womenDisplay}</td>
              <td>${totalInCat}</td>
            </tr>
          `;
        });
        
        // Calculate uncategorized players
        const uncategorizedMen = totalMen - categorizedMen;
        const uncategorizedWomen = totalWomen - categorizedWomen;
        const uncategorizedTotal = uncategorizedMen + uncategorizedWomen;
        
        const uncatMenPct = totalMen > 0 ? ((uncategorizedMen / totalMen) * 100).toFixed(1) + '%' : '0%';
        const uncatWomenPct = totalWomen > 0 ? ((uncategorizedWomen / totalWomen) * 100).toFixed(1) + '%' : '0%';
        
        const uncatMenDisplay = uncategorizedMen > 0 ? `${uncategorizedMen} (${uncatMenPct})` : '-';
        const uncatWomenDisplay = uncategorizedWomen > 0 ? `${uncategorizedWomen} (${uncatWomenPct})` : '-';
        
        // Calculate total percentages (may be over 100% if overlaps exist)
        const totalMenPct = totalMen > 0 ? ((totalCategorizedMen / totalMen) * 100).toFixed(1) + '%' : '0%';
        const totalWomenPct = totalWomen > 0 ? ((totalCategorizedWomen / totalWomen) * 100).toFixed(1) + '%' : '0%';
        const totalCategorized = totalCategorizedMen + totalCategorizedWomen;
        
        // Check if there are overlaps (total > actual players)
        const hasMenOverlap = totalCategorizedMen > totalMen;
        const hasWomenOverlap = totalCategorizedWomen > totalWomen;
        const hasOverlap = totalCategorized > totalPlayers;
        
        const menStyle = hasMenOverlap ? 'color: #dc2626; font-weight: 700;' : '';
        const womenStyle = hasWomenOverlap ? 'color: #dc2626; font-weight: 700;' : '';
        const totalStyle = hasOverlap ? 'color: #dc2626; font-weight: 700;' : '';
        
        tableHTML += `
          <tr style="font-weight: 600; background: #f9fafb;">
            <td>Uncategorized</td>
            <td>${uncatMenDisplay}</td>
            <td>${uncatWomenDisplay}</td>
            <td>${uncategorizedTotal}</td>
          </tr>
          <tr style="font-weight: 700; background: #e5e7eb;">
            <td>Total</td>
            <td style="${menStyle}">${totalCategorizedMen} (${totalMenPct})</td>
            <td style="${womenStyle}">${totalCategorizedWomen} (${totalWomenPct})</td>
            <td style="${totalStyle}">${totalCategorized}</td>
          </tr>
        `;
        
        tableHTML += '</tbody></table>';
        summaryContent.innerHTML = warningHTML + tableHTML;
      }
      
      // Helper function to check if player matches category criteria
      function playerMatchesCategory(player, category) {
        // Check handicap
        if (category.handicapMin !== undefined && category.handicapMin !== null && category.handicapMin !== '') {
          if (player.hcp === undefined || player.hcp === null || parseFloat(player.hcp) < parseFloat(category.handicapMin)) return false;
        }
        if (category.handicapMax !== undefined && category.handicapMax !== null && category.handicapMax !== '') {
          if (player.hcp === undefined || player.hcp === null || parseFloat(player.hcp) > parseFloat(category.handicapMax)) return false;
        }
        
        // Check age
        if (category.ageMin !== undefined && category.ageMin !== null && category.ageMin !== '') {
          if (player.age === undefined || player.age === null || parseInt(player.age) < parseInt(category.ageMin)) return false;
        }
        if (category.ageMax !== undefined && category.ageMax !== null && category.ageMax !== '') {
          if (player.age === undefined || player.age === null || parseInt(player.age) > parseInt(category.ageMax)) return false;
        }
        
        return true;
      }

      function loadCategories() {
        const tbody = document.getElementById('categories-body');
        tbody.innerHTML = '';
        const categories = getCategories();
        console.log('loadCategories - loaded categories:', categories.length, categories);

        if (categories.length === 0) {
          const row = tbody.insertRow();
          row.innerHTML = '<td colspan="8" style="text-align: center; color: #6b7280;">No categories yet. Add a category above.</td>';
          return;
        }

        categories.forEach((cat, index) => {
          const row = tbody.insertRow();
          row.draggable = true;
          row.dataset.index = index;
          
          const handicapRange = formatHandicapRange(cat.handicapMin, cat.handicapMax);
          const ageRange = formatAgeRange(cat.ageMin, cat.ageMax);
          const gender = cat.gender || 'Any';
          const tournamentType = cat.tournamentType || 'Any';
          const playsFrom = getTeeDisplayName(cat.playsFrom);
          
          // Calculate player counts
          const playerStats = calculatePlayerStats(cat);
          const noPlayersDisplay = `${playerStats.categoryCount} / ${playerStats.genderTotal}`;
          const percentageDisplay = playerStats.percentage;
          
          const resultOnlyBadge = cat.isResultOnly 
            ? '<span style="display: inline-block; margin-left: 6px; padding: 2px 6px; font-size: 10px; background: #e0e7ff; color: #4338ca; border-radius: 4px; font-weight: 600;">RESULT-ONLY</span>'
            : '';
          
          row.innerHTML = `
            <td class="drag-handle">‚ò∞</td>
            <td>${escapeHtml(cat.name)}${resultOnlyBadge}</td>
            <td>${handicapRange}</td>
            <td>${ageRange}</td>
            <td>${gender}</td>
            <td>${tournamentType}</td>
            <td>${escapeHtml(playsFrom)}</td>
            <td>${noPlayersDisplay}</td>
            <td>${percentageDisplay}</td>
            <td>
              <button class="btn" style="padding: 4px 8px; font-size: 12px; margin-right: 4px;" onclick="editCategory(${index}); event.stopPropagation();">Edit</button>
              <button class="btn btn-delete" style="padding: 4px 8px; font-size: 12px;" onclick="deleteCategory(${index}); event.stopPropagation();">Delete</button>
            </td>
          `;
          
          // Drag and drop event listeners
          row.addEventListener('dragstart', handleDragStart);
          row.addEventListener('dragover', handleDragOver);
          row.addEventListener('drop', handleDrop);
          row.addEventListener('dragend', handleDragEnd);
          row.addEventListener('click', () => selectCategory(index, row));
        });
        
        // Update summary table
        updateSummaryTable();
      }

      function formatHandicapRange(min, max) {
        const formatHcp = (hcp) => {
          if (hcp === undefined || hcp === null || hcp === '') return null;
          const num = parseFloat(hcp);
          if (num < 0) return '+' + Math.abs(num).toFixed(1);
          return num.toFixed(1);
        };
        
        const minFormatted = formatHcp(min);
        const maxFormatted = formatHcp(max);
        
        if (minFormatted !== null && maxFormatted !== null) {
          return `${minFormatted} to ${maxFormatted}`;
        } else if (minFormatted !== null) {
          return `${minFormatted}+`;
        } else if (maxFormatted !== null) {
          return `Up to ${maxFormatted}`;
        }
        return 'Any';
      }

      function formatAgeRange(min, max) {
        if (min !== undefined && min !== null && min !== '' && max !== undefined && max !== null && max !== '') {
          return `${min} - ${max}`;
        } else if (min !== undefined && min !== null && min !== '') {
          return `${min}+`;
        } else if (max !== undefined && max !== null && max !== '') {
          return `Up to ${max}`;
        }
        return 'Any';
      }

      function escapeHtml(str) {
        if (!str) return '';
        return String(str).replace(/[&"'<>]/g, function (s) {
          return ({ '&': '&amp;', '"': '&quot;', "'": '&#39;', '<': '&lt;', '>': '&gt;' })[s];
        });
      }

      // Get admitted players for this tournament
      function getAdmittedPlayers() {
        const tournament = getTournament();
        if (!tournament) {
          console.log('No tournament found');
          return [];
        }
        
        try {
          // Get admitted players from localStorage (stored by round)
          const raw = localStorage.getItem('admittedPlayers');
          const admittedData = raw ? JSON.parse(raw) : {};
          
          console.log('admittedData:', admittedData);
          console.log('tournament.meta:', tournament.meta);
          
          // Collect all admitted players from all rounds of this tournament
          const allAdmittedPlayers = [];
          const roundIds = tournament.meta?.roundIds || [];
          
          console.log('roundIds:', roundIds);
          
          roundIds.forEach(roundId => {
            console.log('Checking roundId:', roundId, 'Has data:', !!admittedData[roundId]);
            if (admittedData[roundId]) {
              console.log('Found admitted players for round:', roundId, admittedData[roundId].length);
              admittedData[roundId].forEach(player => {
                // Avoid duplicates by checking if player is already added
                if (!allAdmittedPlayers.find(p => p.reg === player.reg)) {
                  allAdmittedPlayers.push(player);
                }
              });
            }
          });
          
          console.log('Total admitted players:', allAdmittedPlayers.length);
          return allAdmittedPlayers;
        } catch (err) {
          console.error('Failed to get admitted players', err);
          return [];
        }
      }

      // Calculate player statistics for a category
      function calculatePlayerStats(category) {
        const admittedPlayers = getAdmittedPlayers();
        
        console.log('calculatePlayerStats - admitted players:', admittedPlayers.length);
        console.log('category:', category);
        
        // Filter by gender first to get gender total
        let genderPlayers = admittedPlayers;
        if (category.gender && category.gender !== 'Any' && category.gender !== '') {
          genderPlayers = admittedPlayers.filter(p => {
            const playerGender = (p.gender || '').toLowerCase();
            const catGender = category.gender.toLowerCase();
            
            if (catGender === 'male') return playerGender === 'm' || playerGender === 'male';
            if (catGender === 'female') return playerGender === 'f' || playerGender === 'female';
            return false;
          });
        }
        const genderTotal = genderPlayers.length;
        
        console.log('genderPlayers after filter:', genderTotal);
        
        // Filter by all category criteria
        const categoryPlayers = genderPlayers.filter(p => {
          // Check handicap
          if (category.handicapMin !== undefined && category.handicapMin !== null && category.handicapMin !== '') {
            if (p.hcp === undefined || p.hcp === null || parseFloat(p.hcp) < parseFloat(category.handicapMin)) return false;
          }
          if (category.handicapMax !== undefined && category.handicapMax !== null && category.handicapMax !== '') {
            if (p.hcp === undefined || p.hcp === null || parseFloat(p.hcp) > parseFloat(category.handicapMax)) return false;
          }
          
          // Check age
          if (category.ageMin !== undefined && category.ageMin !== null && category.ageMin !== '') {
            if (p.age === undefined || p.age === null || parseInt(p.age) < parseInt(category.ageMin)) return false;
          }
          if (category.ageMax !== undefined && category.ageMax !== null && category.ageMax !== '') {
            if (p.age === undefined || p.age === null || parseInt(p.age) > parseInt(category.ageMax)) return false;
          }
          
          return true;
        });
        
        const categoryCount = categoryPlayers.length;
        const percentage = genderTotal > 0 ? ((categoryCount / genderTotal) * 100).toFixed(1) + '%' : '0%';
        
        return {
          categoryCount,
          genderTotal,
          percentage
        };
      }

      function selectCategory(index, row) {
        document.querySelectorAll('#categories-body tr').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
        selectedCategoryIndex = index;
      }

      let editingCategoryIndex = null;

      // Edit category function
      function editCategory(index) {
        const categories = getCategories();
        const cat = categories[index];
        
        if (!cat) return;
        
        // Populate form with category data
        document.getElementById('category-name').value = cat.name;
        document.getElementById('handicap-min').value = cat.handicapMin !== undefined ? cat.handicapMin : '';
        document.getElementById('handicap-max').value = cat.handicapMax !== undefined ? cat.handicapMax : '';
        document.getElementById('age-min').value = cat.ageMin !== undefined ? cat.ageMin : '';
        document.getElementById('age-max').value = cat.ageMax !== undefined ? cat.ageMax : '';
        document.getElementById('gender').value = cat.gender || '';
        document.getElementById('tournament-type').value = cat.tournamentType || '';
        document.getElementById('result-only').checked = cat.isResultOnly || false;
        
        // Load tees and set plays from
        loadAvailableTees(cat.gender || '');
        setTimeout(() => {
          document.getElementById('plays-from').value = cat.playsFrom || '';
        }, 100);
        
        // Update form UI
        editingCategoryIndex = index;
        document.getElementById('form-title').textContent = 'Edit Category';
        document.getElementById('btn-submit').textContent = 'Update Category';
        document.getElementById('btn-cancel-edit').style.display = 'inline-block';
        
        // Scroll to form
        document.getElementById('category-form').scrollIntoView({ behavior: 'smooth' });
      }

      // Delete category function
      function deleteCategory(index) {
        const categories = getCategories();
        const cat = categories[index];
        
        if (!cat) return;
        
        if (confirm(`Are you sure you want to delete category "${cat.name}"?`)) {
          categories.splice(index, 1);
          saveCategories(categories);
          updatePlayerTeesAndHandicaps();
          loadCategories();
        }
      }

      // Cancel edit function
      document.getElementById('btn-cancel-edit').addEventListener('click', () => {
        editingCategoryIndex = null;
        document.getElementById('form-title').textContent = 'Add Category';
        document.getElementById('btn-submit').textContent = 'Add Category';
        document.getElementById('btn-cancel-edit').style.display = 'none';
        document.getElementById('category-form').reset();
        loadAvailableTees('');
      });

      // Form submission
      document.getElementById('category-form').addEventListener('submit', (e) => {
        e.preventDefault();
        
        const name = document.getElementById('category-name').value.trim();
        const handicapMin = document.getElementById('handicap-min').value;
        const handicapMax = document.getElementById('handicap-max').value;
        const ageMin = document.getElementById('age-min').value;
        const ageMax = document.getElementById('age-max').value;
        const gender = document.getElementById('gender').value;
        const tournamentType = document.getElementById('tournament-type').value;
        const playsFrom = document.getElementById('plays-from').value;
        const isResultOnly = document.getElementById('result-only').checked;

        if (!name) {
          alert('Please enter a category name.');
          return;
        }

        const categories = getCategories();
        
        if (editingCategoryIndex !== null) {
          // Update existing category
          const existingCategory = categories[editingCategoryIndex];
          categories[editingCategoryIndex] = {
            name,
            code: existingCategory.code, // Keep the same code
            handicapMin: handicapMin !== '' ? parseFloat(handicapMin) : undefined,
            handicapMax: handicapMax !== '' ? parseFloat(handicapMax) : undefined,
            ageMin: ageMin !== '' ? parseInt(ageMin) : undefined,
            ageMax: ageMax !== '' ? parseInt(ageMax) : undefined,
            gender: gender || undefined,
            tournamentType: tournamentType || undefined,
            playsFrom: playsFrom || undefined,
            isResultOnly: isResultOnly
          };
          
          // Reset edit mode
          editingCategoryIndex = null;
          document.getElementById('form-title').textContent = 'Add Category';
          document.getElementById('btn-submit').textContent = 'Add Category';
          document.getElementById('btn-cancel-edit').style.display = 'none';
        } else {
          // Add new category
          const code = generateCategoryCode(name, categories);
          const newCategory = {
            name,
            code,
            handicapMin: handicapMin !== '' ? parseFloat(handicapMin) : undefined,
            handicapMax: handicapMax !== '' ? parseFloat(handicapMax) : undefined,
            ageMin: ageMin !== '' ? parseInt(ageMin) : undefined,
            ageMax: ageMax !== '' ? parseInt(ageMax) : undefined,
            gender: gender || undefined,
            tournamentType: tournamentType || undefined,
            playsFrom: playsFrom || undefined,
            isResultOnly: isResultOnly
          };
          categories.push(newCategory);
        }

        saveCategories(categories);
        updatePlayerTeesAndHandicaps();
        loadCategories();
        
        // Clear form
        document.getElementById('category-form').reset();
        loadAvailableTees('');
      });
      
      // Function to update player tees and playing handicaps based on categories
      function updatePlayerTeesAndHandicaps() {
        try {
          const categories = getCategories();
          const tournament = getTournament();
          
          console.log('Updating player tees and handicaps...');
          console.log('Categories:', categories);
          
          if (!tournament || !tournament.meta) {
            console.log('No tournament or meta data');
            return;
          }
          
          const raw = localStorage.getItem('admittedPlayers');
          if (!raw || raw === '{}' || raw === 'null') {
            console.log('No admitted players yet');
            return;
          }
          
          const admittedData = JSON.parse(raw);
          const roundIds = tournament.meta.roundIds || [];
          
          if (!roundIds || roundIds.length === 0) {
            console.log('No rounds configured');
            return;
          }
          
          console.log('Round IDs:', roundIds);
          
          let updatedCount = 0;
          
          roundIds.forEach(roundId => {
            if (!admittedData[roundId] || !Array.isArray(admittedData[roundId]) || admittedData[roundId].length === 0) {
              console.log('No admitted players for round:', roundId);
              return;
            }
            
            console.log(`Processing ${admittedData[roundId].length} players for round ${roundId}`);
            
            admittedData[roundId].forEach(player => {
              if (!player) return;
              // Find ALL categories this player belongs to
              let teeAssigningCategory = null;
              const allMatchingCategories = [];
              
              console.log(`Checking player: ${player.firstName} ${player.lastName}, gender: ${player.gender}, hcp: ${player.hcp}`);
              
              for (const cat of categories) {
                const playerGender = (player.gender || '').toLowerCase();
                const catGender = (cat.gender || '').toLowerCase();
                
                let genderMatch = false;
                if (!catGender || catGender === 'any' || catGender === '') {
                  genderMatch = true;
                } else if (catGender === 'male' && (playerGender === 'm' || playerGender === 'male')) {
                  genderMatch = true;
                } else if (catGender === 'female' && (playerGender === 'f' || playerGender === 'female')) {
                  genderMatch = true;
                }
                
                console.log(`  Testing category ${cat.name}: genderMatch=${genderMatch}, gender=${catGender}, playsFrom=${cat.playsFrom}, isResultOnly=${cat.isResultOnly}`);
                
                if (genderMatch && playerMatchesCategory(player, cat)) {
                  allMatchingCategories.push(cat.code);
                  console.log(`  ‚úì Matched category: ${cat.name} (${cat.code})`);
                  
                  // For tee assignment, use the first non-result-only category
                  if (!cat.isResultOnly && !teeAssigningCategory) {
                    teeAssigningCategory = cat;
                  }
                }
              }
              
              // Store ALL categories this player belongs to (for results page)
              player.categories = allMatchingCategories;
              
              // For backward compatibility, also store primary category
              if (allMatchingCategories.length > 0) {
                player.category = allMatchingCategories[0];
              }
              
              // If player matches a tee-assigning category, update tee and PHCP
              if (teeAssigningCategory && teeAssigningCategory.playsFrom) {
                const oldTee = player.tee;
                const oldPhcp = player.phcp;
                player.tee = teeAssigningCategory.playsFrom;
                
                // PHCP is already calculated during admission, so we don't recalculate it here
                updatedCount++;
              } else {
                // No category match - reset to default tee based on gender
                const roundIndex = roundIds.indexOf(roundId);
                const roundData = tournament.meta.roundsData?.[roundIndex];
                
                if (roundData) {
                  const playerGender = (player.gender || '').toLowerCase();
                  const oldTee = player.tee;
                  
                  if (playerGender === 'male' || playerGender === 'm') {
                    player.tee = roundData.teeMen || null;
                  } else if (playerGender === 'female' || playerGender === 'f') {
                    player.tee = roundData.teeWomen || null;
                  } else {
                    player.tee = null;
                  }
                  
                  // Recalculate PHCP with default tee
                  if (player.tee) {
                    const phcpString = calculatePlayingHcpForPlayer(player, roundId);
                    player.phcp = phcpString.startsWith('+') ? parseInt(phcpString.substring(1)) * -1 : (phcpString === '' ? null : parseInt(phcpString));
                  } else {
                    player.phcp = null;
                  }
                  
                  console.log(`‚úó Player ${player.firstName} ${player.lastName}: Reset to default tee (oldTee=${oldTee}, newTee=${player.tee})`);
                  updatedCount++;
                }
              }
            });
          });
          
          localStorage.setItem('admittedPlayers', JSON.stringify(admittedData));
          console.log(`Updated ${updatedCount} players with tees and playing handicaps`);
          
          // Verify the data was saved
          const savedData = JSON.parse(localStorage.getItem('admittedPlayers'));
          console.log('Saved admittedPlayers data:', savedData);
          
          // Show sample of updated players
          if (savedData['T0001-1']) {
            console.log('Sample of first 3 players after update:', savedData['T0001-1'].slice(0, 3));
          }
          
          // Update summary table after player updates
          updateSummaryTable();
        } catch (err) {
          console.error('Failed to update player tees and handicaps', err);
          // Don't show alert for errors when no players exist
          if (err.message && !err.message.includes('undefined')) {
            console.error('Unexpected error:', err);
          }
        }
      }
      
      // Add a manual function to check admitted players data
      window.checkAdmittedPlayers = function() {
        const raw = localStorage.getItem('admittedPlayers');
        const data = JSON.parse(raw);
        console.log('Current admittedPlayers data:', data);
        if (data['T0001-1']) {
          console.log('First 5 players in T0001-1:', data['T0001-1'].slice(0, 5));
        }
      };
      
      // Function to calculate playing handicap for a player
      function calculatePlayingHcpForPlayer(player, roundId) {
        const playerHcp = parseFloat(player.hcp);
        if (isNaN(playerHcp) || !player.tee) return '';
        
        const tournament = getTournament();
        if (!tournament || !tournament.meta) return '';
        
        // Find the round index
        const roundIds = tournament.meta.roundIds || [];
        const roundIndex = roundIds.indexOf(roundId);
        if (roundIndex === -1) return '';
        
        const roundData = tournament.meta.roundsData?.[roundIndex];
        if (!roundData) return '';
        
        // Get the tee data - handle "C001||1" format where 1 is the array INDEX
        let teeIndex = -1;
        if (player.tee && player.tee.includes('||')) {
          const parts = player.tee.split('||');
          teeIndex = parseInt(parts[1], 10);
        }
        
        const courses = getCourses();
        const playerGender = (player.gender || '').toLowerCase();
        
        for (const courseId of [roundData.course]) {
          if (!courseId) continue;
          
          const course = courses.find(c => c.courseId === courseId);
          if (!course) continue;
          
          // Use the tee index directly to get slope/rating
          if (teeIndex >= 0 && course.teeData && course.teeData[teeIndex]) {
            let slope, rating;
            const teeGender = course.genders?.[teeIndex];
            const teeData = course.teeData[teeIndex];
            
            // Check if this tee is for both genders (has nested ratings structure)
            if (teeGender === 'B' && teeData?.ratings) {
              // Both genders - use appropriate gender's ratings
              if (playerGender === 'male' || playerGender === 'm') {
                slope = teeData.ratings.men?.slope18;
                rating = teeData.ratings.men?.rating18;
              } else if (playerGender === 'female' || playerGender === 'f') {
                slope = teeData.ratings.women?.slope18;
                rating = teeData.ratings.women?.rating18;
              }
            } else {
              // Single gender tee - use legacy slope/rating or teeData
              slope = course.slopes?.[teeIndex] || teeData?.slope18 || teeData?.slope;
              rating = course.ratings?.[teeIndex] || teeData?.rating18 || teeData?.rating;
            }
            
            const par = course.pars ? course.pars.reduce((sum, p) => sum + (parseInt(p) || 0), 0) : 72;
            const hcpAllowance = parseFloat(tournament.meta?.hcpAllow || 100) / 100;
            
            if (slope && rating) {
              // Formula: (HCP √ó (Slope/113) + (Rating - Par)) √ó HCP_Allowance
              const playingHcp = (playerHcp * (parseFloat(slope) / 113) + (parseFloat(rating) - par)) * hcpAllowance;
              const rounded = Math.round(playingHcp);
              
              // Format with + for negative values (plus handicaps)
              if (rounded < 0) {
                return '+' + Math.abs(rounded);
              }
              return rounded.toString();
            }
          }
        }
        
        return '';
      }

      // Clear button
      document.getElementById('btn-clear').addEventListener('click', () => {
        editingCategoryIndex = null;
        document.getElementById('form-title').textContent = 'Add Category';
        document.getElementById('btn-submit').textContent = 'Add Category';
        document.getElementById('btn-cancel-edit').style.display = 'none';
        document.getElementById('category-form').reset();
        loadAvailableTees('');
      });

      // Show players in categories button
      document.getElementById('btn-show-players').addEventListener('click', () => {
        window.open(`category_players.html?tournamentId=${tournamentId}`, '_blank');
      });

      // Auto Categorize functionality
      const autoCategorizeModal = document.getElementById('auto-categorize-modal');
      const genderSplitSelect = document.getElementById('modal-gender-split');
      const mixedField = document.getElementById('field-mixed-categories');
      const separatedField = document.getElementById('field-separated-categories');
      
      document.getElementById('btn-auto-categorize').addEventListener('click', () => {
        autoCategorizeModal.classList.add('active');
      });
      
      document.getElementById('btn-cancel-auto').addEventListener('click', () => {
        autoCategorizeModal.classList.remove('active');
      });
      
      genderSplitSelect.addEventListener('change', () => {
        if (genderSplitSelect.value === 'mixed') {
          mixedField.style.display = 'block';
          separatedField.style.display = 'none';
        } else {
          mixedField.style.display = 'none';
          separatedField.style.display = 'block';
        }
      });
      
      document.getElementById('btn-generate-categories').addEventListener('click', () => {
        const genderSplit = genderSplitSelect.value;
        const admittedPlayers = getAdmittedPlayers();
        
        if (admittedPlayers.length === 0) {
          alert('No admitted players found. Please admit players first.');
          return;
        }
        
        const categories = getCategories();
        const existingCodes = categories.map(c => c.code);
        
        let newCategories = [];
        
        if (genderSplit === 'mixed') {
          const numCategories = parseInt(document.getElementById('modal-mixed-count').value);
          newCategories = generateMixedCategories(admittedPlayers, numCategories, existingCodes);
        } else {
          const numMen = parseInt(document.getElementById('modal-men-count').value);
          const numWomen = parseInt(document.getElementById('modal-women-count').value);
          newCategories = generateSeparatedCategories(admittedPlayers, numMen, numWomen, existingCodes);
        }
        
        console.log('New categories generated:', newCategories.length);
        newCategories.forEach(cat => console.log(`  ${cat.name}: min=${cat.handicapMin}, max=${cat.handicapMax}`));
        
        // Add new categories to existing ones
        const allCategories = [...categories, ...newCategories];
        console.log('All categories before save:', allCategories.length);
        saveCategories(allCategories);
        console.log('Categories saved, now updating player tees');
        updatePlayerTeesAndHandicaps();
        console.log('Player tees updated, now loading categories');
        loadCategories();
        
        autoCategorizeModal.classList.remove('active');
        alert(`Successfully created ${newCategories.length} categories!`);
      });
      
      function generateMixedCategories(players, numCategories, existingCodes) {
        const categories = [];
        
        // Calculate PHCP for all players and sort by PHCP
        const tournament = getTournament();
        const roundId = tournament.meta?.roundIds?.[0] || '';
        
        const playersWithPhcp = players.map(p => ({
          ...p,
          phcp: calculatePlayingHcpForPlayer(p, roundId)
        })).sort((a, b) => {
          const aPhcp = a.phcp.startsWith('+') ? -parseFloat(a.phcp.substring(1)) : parseFloat(a.phcp);
          const bPhcp = b.phcp.startsWith('+') ? -parseFloat(b.phcp.substring(1)) : parseFloat(b.phcp);
          return aPhcp - bPhcp;
        });
        
        const splits = numCategories === 1 ? [1.0] : numCategories === 2 ? [0.4, 0.6] : [0.25, 0.35, 0.40];
        const categoryGroups = splitPlayersByPhcp(playersWithPhcp, splits);
        
        let previousMaxHcp = null;
        
        for (let i = 0; i < categoryGroups.length; i++) {
          const categoryPlayers = categoryGroups[i];
          if (categoryPlayers.length === 0) continue;
          
          // For first category: no min limit
          // For middle categories: previous max + 0.1
          const minHcp = i === 0 ? undefined : (previousMaxHcp !== null ? previousMaxHcp + 0.1 : undefined);
          
          // For last category: no max limit (54)
          // For other categories: find highest HCP in this category
          let maxHcp;
          if (i === categoryGroups.length - 1) {
            maxHcp = undefined; // No upper limit for last category
          } else {
            // Find the highest HCP in this category
            const maxPlayerHcp = Math.max(...categoryPlayers.map(p => parseFloat(p.hcp) || 0));
            maxHcp = Math.floor(maxPlayerHcp * 10) / 10; // Round down to 1 decimal
            previousMaxHcp = maxHcp;
          }
          
          const catName = numCategories === 1 ? 'Mixed Championship' : `Mixed ${String.fromCharCode(65 + i)}`;
          let code = generateCategoryCode(catName, categories.concat({ code: '' }));
          
          // Mixed categories don't specify playsFrom since players keep their own tees
          categories.push({
            name: catName,
            code: code,
            handicapMin: minHcp,
            handicapMax: maxHcp,
            gender: '',
            playsFrom: undefined,
            isResultOnly: false
          });
        }
        
        return categories;
      }
      
      function generateSeparatedCategories(players, numMen, numWomen, existingCodes) {
        const categories = [];
        
        // Filter and sort men by HCP
        const menPlayers = players.filter(p => {
          const gender = (p.gender || '').toLowerCase();
          return gender === 'm' || gender === 'male';
        }).sort((a, b) => {
          const aHcp = parseFloat(a.hcp) || 0;
          const bHcp = parseFloat(b.hcp) || 0;
          return aHcp - bHcp; // Best HCP first
        });
        
        // Filter and sort women by HCP
        const womenPlayers = players.filter(p => {
          const gender = (p.gender || '').toLowerCase();
          return gender === 'f' || gender === 'female';
        }).sort((a, b) => {
          const aHcp = parseFloat(a.hcp) || 0;
          const bHcp = parseFloat(b.hcp) || 0;
          return aHcp - bHcp; // Best HCP first
        });
        
        // Generate men categories
        if (menPlayers.length > 0 && numMen > 0) {
          const menSplits = numMen === 1 ? [1.0] : numMen === 2 ? [0.4, 0.6] : [0.25, 0.35, 0.40];
          const menGroups = splitPlayersByPhcp(menPlayers, menSplits);
          
          console.log('Men groups returned:', menGroups.map(g => g.length));
          console.log('Group 0 players:', menGroups[0] ? menGroups[0].length : 'none');
          console.log('Group 1 players:', menGroups[1] ? menGroups[1].length : 'none');
          console.log('First player in Group 0:', menGroups[0] && menGroups[0][0]);
          console.log('Last player in Group 0:', menGroups[0] && menGroups[0][menGroups[0].length - 1]);
          
          let previousMaxHcp = null;
          
          for (let i = 0; i < menGroups.length; i++) {
            const groupPlayers = menGroups[i];
            if (groupPlayers.length === 0) continue;
            
            // Min HCP: undefined for first, previous max + 0.1 for others
            const minHcp = i === 0 ? undefined : (previousMaxHcp + 0.1);
            
            // Max HCP: undefined for last, highest HCP in group for others
            let maxHcp = undefined;
            if (i < menGroups.length - 1) {
              const maxPlayerHcp = Math.max(...groupPlayers.map(p => parseFloat(p.hcp) || 0));
              maxHcp = Math.round(maxPlayerHcp * 10) / 10; // Round to 1 decimal
              previousMaxHcp = maxHcp;
            }
            
            const catName = numMen === 1 ? 'Men' : `Men ${String.fromCharCode(65 + i)}`;
            const code = generateCategoryCode(catName, categories);
            const playsFrom = groupPlayers[0]?.tee; // Use first player's tee
            
            categories.push({
              name: catName,
              code: code,
              handicapMin: minHcp,
              handicapMax: maxHcp,
              gender: 'Male',
              playsFrom: playsFrom,
              isResultOnly: false
            });
          }
        }
        
        // Generate women categories
        if (womenPlayers.length > 0 && numWomen > 0) {
          const womenSplits = numWomen === 1 ? [1.0] : numWomen === 2 ? [0.4, 0.6] : [0.25, 0.35, 0.40];
          const womenGroups = splitPlayersByPhcp(womenPlayers, womenSplits);
          
          let previousMaxHcp = null;
          
          for (let i = 0; i < womenGroups.length; i++) {
            const groupPlayers = womenGroups[i];
            if (groupPlayers.length === 0) continue;
            
            // Min HCP: undefined for first, previous max + 0.1 for others
            const minHcp = i === 0 ? undefined : (previousMaxHcp + 0.1);
            
            // Max HCP: undefined for last, highest HCP in group for others
            let maxHcp = undefined;
            if (i < womenGroups.length - 1) {
              const maxPlayerHcp = Math.max(...groupPlayers.map(p => parseFloat(p.hcp) || 0));
              maxHcp = Math.round(maxPlayerHcp * 10) / 10; // Round to 1 decimal
              previousMaxHcp = maxHcp;
            }
            
            const catName = numWomen === 1 ? 'Women' : `Women ${String.fromCharCode(65 + i)}`;
            const code = generateCategoryCode(catName, categories);
            const playsFrom = groupPlayers[0]?.tee; // Use first player's tee
            
            categories.push({
              name: catName,
              code: code,
              handicapMin: minHcp,
              handicapMax: maxHcp,
              gender: 'Female',
              playsFrom: playsFrom,
              isResultOnly: false
            });
          }
        }
        
        return categories;
      }
      
      // Split players by PHCP, keeping same PHCPs together and respecting target splits
      function splitPlayersByPhcp(players, splits) {
        if (!players || players.length === 0) return splits.map(() => []);
        
        console.log('=== SPLIT DEBUG ===');
        console.log('Total players:', players.length);
        console.log('Splits:', splits);
        console.log('First 5 players PHCPs:', players.slice(0, 5).map(p => `${p.firstName} ${p.lastName}: PHCP=${p.phcp} HCP=${p.hcp}`));
        
        const totalPlayers = players.length;
        const result = [];
        let currentIndex = 0;
        
        for (let i = 0; i < splits.length; i++) {
          console.log(`\n--- Category ${i} ---`);
          
          // Last category gets everyone remaining
          if (i === splits.length - 1) {
            console.log('Last category - taking all remaining');
            result.push(players.slice(currentIndex));
            break;
          }
          
          // Calculate how many players this category should have
          const targetCount = Math.round(totalPlayers * splits[i]);
          console.log('Target count:', targetCount, `(${splits[i] * 100}%)`);
          
          // Get the target position
          let targetSplitPoint = currentIndex + targetCount;
          console.log('Initial target split point:', targetSplitPoint);
          
          // Don't go past the array
          if (targetSplitPoint >= players.length) {
            console.log('Split point >= length, capping at', players.length);
            result.push(players.slice(currentIndex));
            currentIndex = players.length;
            continue;
          }
          
          // If target split point is at start, just continue
          if (targetSplitPoint <= currentIndex) {
            console.log('Target split point <= currentIndex, creating empty category');
            result.push([]);
            continue;
          }
          
          // Find the PHCP at the target split point
          const phcpAtTarget = players[targetSplitPoint].phcp;
          const phcpBeforeTarget = players[targetSplitPoint - 1].phcp;
          
          console.log(`PHCP before target [${targetSplitPoint-1}]: ${phcpBeforeTarget}`);
          console.log(`PHCP at target [${targetSplitPoint}]: ${phcpAtTarget}`);
          
          // If the player before and at split point have different PHCP, we can split cleanly
          if (phcpBeforeTarget !== phcpAtTarget) {
            console.log('Clean split - different PHCPs');
            result.push(players.slice(currentIndex, targetSplitPoint));
            currentIndex = targetSplitPoint;
            continue;
          }
          
          // Same PHCP detected - find the boundaries of this PHCP group
          console.log('Same PHCP detected! Finding group boundaries...');
          
          // Find the start of this PHCP group
          let groupStart = targetSplitPoint - 1;
          while (groupStart > currentIndex && players[groupStart - 1].phcp === phcpAtTarget) {
            groupStart--;
          }
          
          // Find the end of this PHCP group
          let groupEnd = targetSplitPoint;
          while (groupEnd < players.length && players[groupEnd].phcp === phcpAtTarget) {
            groupEnd++;
          }
          
          console.log(`Same-PHCP group (${phcpAtTarget}): indices ${groupStart} to ${groupEnd - 1}, count: ${groupEnd - groupStart}`);
          
          // Option 1: Split BEFORE the group (exclude all same-PHCP players from this category)
          const option1SplitPoint = groupStart;
          const option1Count = option1SplitPoint - currentIndex;
          const option1Diff = Math.abs(option1Count - targetCount);
          
          // Option 2: Split AFTER the group (include all same-PHCP players in this category)
          const option2SplitPoint = groupEnd;
          const option2Count = option2SplitPoint - currentIndex;
          const option2Diff = Math.abs(option2Count - targetCount);
          
          console.log(`Option 1 (exclude group, split at ${option1SplitPoint}): count=${option1Count}, diff from target=${option1Diff}`);
          console.log(`Option 2 (include group, split at ${option2SplitPoint}): count=${option2Count}, diff from target=${option2Diff}`);
          
          // Pick the option that keeps us closer to target count
          // If equal, prefer including (option 2) to avoid leaving players out
          let finalSplitPoint;
          if (option1Count === 0) {
            // If excluding would give us 0 players, we must include
            console.log('Option 1 would give 0 players, choosing option 2');
            finalSplitPoint = option2SplitPoint;
          } else if (option2SplitPoint >= players.length && i < splits.length - 2) {
            // If including would take all remaining players but we have more categories to fill
            console.log('Option 2 would take all remaining players, choosing option 1');
            finalSplitPoint = option1SplitPoint;
          } else if (option1Diff < option2Diff) {
            console.log('Choosing option 1 (exclude) - closer to target');
            finalSplitPoint = option1SplitPoint;
          } else {
            console.log('Choosing option 2 (include) - closer to target or equal');
            finalSplitPoint = option2SplitPoint;
          }
          
          console.log('Final split point:', finalSplitPoint);
          console.log('Category will have', finalSplitPoint - currentIndex, 'players');
          
          result.push(players.slice(currentIndex, finalSplitPoint));
          currentIndex = finalSplitPoint;
        }
        
        console.log('\n=== RESULT ===');
        result.forEach((cat, idx) => console.log(`Category ${idx}:`, cat.length, 'players'));
        
        return result;
      }

      // Load categories on page load
      loadCategories();
    </script>
  </body>
</html>
