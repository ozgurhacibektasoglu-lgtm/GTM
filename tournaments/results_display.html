<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Results Display</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      body{padding-top:70px}
      .results-display-container { max-width: 1000px; margin: 36px auto; padding: 24px; }
      .results-header { text-align: center; margin-bottom: 32px; }
      .results-header h1 { margin: 0; font-size: 28px; color: #1e293b; }
      .results-header .category-name { font-size: 20px; color: #64748b; margin-top: 8px; }
      .results-table-wrapper { background: white; border-radius: 12px; box-shadow: 0 10px 30px rgba(2,6,23,0.06); overflow-x: auto; padding: 24px; }
      .results-table { width: auto; border-collapse: collapse; font-size: 14px; }
      .results-table thead th { 
        background: #f8fafc; 
        padding: 10px 12px; 
        text-align: left; 
        font-weight: 600; 
        color: #475569;
        border-bottom: 2px solid #e2e8f0;
        white-space: nowrap;
      }
      .results-table thead th.text-center { text-align: center; }
      .results-table thead th.text-right { text-align: right; }
      .results-table tbody td { 
        padding: 8px 12px; 
        border-bottom: 1px solid #f1f5f9;
        color: #1e293b;
      }
      .results-table tbody td.text-center { text-align: center; }
      .results-table tbody td.text-right { text-align: right; }
      .results-table tbody tr:hover { background: #f8fafc; }
      .results-table tbody tr.status-row { background: #fef2f2; }
      .results-table tbody tr.status-row:hover { background: #fee2e2; }
      .rank-cell { font-weight: 600; color: #0f172a; font-size: 15px; }
      .player-cell { font-weight: 500; color: #0f172a; }
      .total-cell { font-weight: 700; color: #0f172a; font-size: 15px; background: #f1f5f9; }
      /* Team results specific styles */
      .team-results-table { width: 100%; table-layout: fixed; }
      .team-results-table .col-rank { width: 50px; }
      .team-results-table .col-name { width: auto; }
      .team-results-table .col-hcp { width: 80px; }
      .team-results-table .col-phcp { width: 60px; }
      .team-results-table .col-topar { width: 60px; }
      .team-results-table .col-round { width: 50px; }
      .team-results-table .col-score { width: 60px; }
      .team-row { background: #f1f5f9 !important; }
      .team-row:hover { background: #e2e8f0 !important; }
      .player-row td { padding-top: 6px !important; padding-bottom: 6px !important; }
      .warning-message { 
        background: #fef3c7; 
        border: 2px solid #f59e0b; 
        border-radius: 8px; 
        padding: 16px; 
        margin-bottom: 24px;
        text-align: center;
        color: #92400e;
        font-weight: 600;
      }
      .info-message { 
        background: #dbeafe; 
        border: 2px solid #3b82f6; 
        border-radius: 8px; 
        padding: 16px; 
        margin-bottom: 24px;
        text-align: center;
        color: #1e40af;
        font-weight: 600;
      }
      .tiebreaker-info {
        background: #f3e8ff;
        border: 2px solid #a855f7;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
        text-align: center;
        color: #7c3aed;
        font-weight: 500;
        font-size: 13px;
      }
      .action-buttons { 
        display: flex; 
        gap: 10px; 
        margin-top: 24px;
        justify-content: center;
      }
      .btn { 
        background: linear-gradient(180deg, var(--accent), #0a58d1); 
        color: white; 
        border: 0; 
        padding: 10px 20px; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 14px; 
        font-weight: 600;
        transition: transform 0.08s; 
      }
      .btn:active { transform: translateY(1px); }
      .btn-print { background: linear-gradient(180deg, #10b981, #059669); }
      .btn-back { 
        background: white; 
        color: #0b6efd; 
        border: 1px solid #e6e9ef; 
      }
      @media print {
        .action-buttons, .btn { display: none; }
        .results-display-container { margin: 0; padding: 20px; }
        .warning-message { display: none; }
      }
    </style>
  </head>
  <body>
    <div class="top-nav">
      <h1>üèÜ Results Display</h1>
      <a href="#" onclick="window.close(); return false;" class="btn-back-top">‚úï Close</a>
    </div>
    <main class="results-display-container">
      <div class="results-header">
        <h1 id="tournament-name">Tournament Results</h1>
        <div class="category-name" id="category-name"></div>
      </div>

      <div id="warning-container"></div>

      <div class="results-table-wrapper">
        <table class="results-table" id="results-table">
          <thead id="table-head"></thead>
          <tbody id="table-body"></tbody>
        </table>
      </div>

      <div class="action-buttons">
        <button class="btn btn-print" onclick="window.print()">Print Results</button>
        <button class="btn btn-back" onclick="window.close()">Close</button>
      </div>
    </main>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');
      const categoryCode = urlParams.get('categoryCode');
      const categoryName = urlParams.get('categoryName');
      const displayType = urlParams.get('display');
      const showHcp = urlParams.get('hcp') === 'yes';
      const showPhcp = urlParams.get('phcp') === 'yes';
      const showToPar = urlParams.get('topar') === 'yes';

      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function getTournament() {
        const tournaments = getTournaments();
        return tournaments.find(t => t.tournamentId === tournamentId);
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          const tournament = getTournament();
          if (!tournament || !tournament.meta || !tournament.meta.roundIds) return [];
          
          // Get players from all rounds
          const allPlayers = [];
          tournament.meta.roundIds.forEach(roundId => {
            if (data[roundId]) {
              data[roundId].forEach(player => {
                if (!allPlayers.find(p => p.reg === player.reg)) {
                  allPlayers.push(player);
                }
              });
            }
          });
          
          return allPlayers;
        } catch (err) {
          console.error('Error loading admitted players:', err);
          return [];
        }
      }

      function getScores() {
        try {
          const raw = localStorage.getItem('scores');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Error loading scores:', err);
          return {};
        }
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Error loading courses:', err);
          return [];
        }
      }

      function getTeams() {
        try {
          const raw = localStorage.getItem('teams');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Error loading teams:', err);
          return [];
        }
      }

      // Save calculated results to tournament data (localStorage and Firebase)
      function saveCalculatedResults(categoryCode, resultsData) {
        try {
          const tournaments = getTournaments();
          const index = tournaments.findIndex(t => t.tournamentId === tournamentId);
          
          if (index !== -1) {
            // Initialize calculatedResults if not exists
            if (!tournaments[index].calculatedResults) {
              tournaments[index].calculatedResults = {};
            }
            
            // Save the results for this category
            tournaments[index].calculatedResults[categoryCode] = {
              results: resultsData,
              calculatedAt: new Date().toISOString()
            };
            
            // Save to localStorage FIRST
            localStorage.setItem('tournaments', JSON.stringify(tournaments));
            console.log(`Results saved to localStorage for category ${categoryCode}:`, resultsData.length, 'entries');
            
            // Verify it was saved correctly
            const verify = JSON.parse(localStorage.getItem('tournaments'));
            const verifyTournament = verify.find(t => t.tournamentId === tournamentId);
            if (verifyTournament?.calculatedResults?.[categoryCode]) {
              console.log('‚úì Verified: calculatedResults saved in localStorage');
            } else {
              console.error('‚úó ERROR: calculatedResults NOT found in localStorage after save!');
            }
            
            // Sync to Firebase
            if (typeof syncToFirebase !== 'undefined') {
              syncToFirebase('tournaments', tournaments)
                .then(() => console.log('‚úì Results synced to Firebase'))
                .catch(e => console.error('‚úó Firebase sync failed:', e));
            }
          } else {
            console.error('Tournament not found in array, cannot save results');
          }
        } catch (err) {
          console.error('Error saving calculated results:', err);
        }
      }

      function isTeamCategory() {
        const tournament = getTournament();
        // Check if tournament is a team tournament and category is "TEAM"
        return tournament?.meta?.teamsTournament === 'yes' && categoryCode === 'TEAM';
      }

      function getTeeData(player, roundIndex) {
        const tournament = getTournament();
        if (!tournament) return null;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        if (!roundData) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeValue = '';
        
        // Check if player has an assigned tee (from categories)
        if (player.tee) {
          const courses = getCourses();
          const courseId = roundData.course;
          const course = courses.find(c => c.courseId === courseId);
          
          if (course && course.teeIds) {
            const idx = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              teeValue = `${courseId}||${idx}`;
            }
          }
        }
        
        // If no assigned tee, use default from tournament settings
        if (!teeValue) {
          if (playerGender === 'male' || playerGender === 'm') {
            teeValue = roundData.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            teeValue = roundData.teeWomen || '';
          }
        }
        
        if (!teeValue || !teeValue.includes('||')) return null;
        
        const [courseId, teeIndexStr] = teeValue.split('||');
        const teeIndex = parseInt(teeIndexStr, 10);
        
        const courses = getCourses();
        const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
        
        if (!course) return null;
        
        // Calculate total par from pars array (sum of all 18 holes)
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        // Get tee-specific data from teeData array
        const teeData = course.teeData?.[teeIndex];
        if (!teeData) return null;
        
        let slope, rating;
        
        // Check if this tee is for both genders (has nested ratings structure)
        const teeGender = course.genders?.[teeIndex];
        if (teeGender === 'B' && teeData.ratings) {
          // Both genders - use appropriate gender's ratings
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else if (playerGender === 'female' || playerGender === 'f') {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          // Single gender tee
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        return { slope, rating, par, course };
      }

      function calculatePlayingHcp(player, roundIndex = 0) {
        const playerHcp = parseFloat(player.hcp);
        if (isNaN(playerHcp)) {
          return null;
        }
        
        const teeData = getTeeData(player, roundIndex);
        if (!teeData || !teeData.slope || !teeData.rating || !teeData.par) {
          return Math.round(playerHcp); // Fallback to rounded WHS HCP if data missing
        }
        
        const tournament = getTournament();
        const slope = parseFloat(teeData.slope);
        const rating = parseFloat(teeData.rating);
        const par = parseFloat(teeData.par);
        const hcpAllowance = parseFloat(tournament?.meta?.hcpAllow || 100) / 100;
        
        if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
          return Math.round(playerHcp);
        }
        
        // Formula: (HCP √ó (Slope/113) + (Rating - Par)) √ó HCP_Allowance
        const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
        
        // Round to nearest whole number (.5 rounds up)
        return Math.round(playingHcp);
      }

      function getPlayerPhcp(player) {
        // Use stored PHCP or calculate it as fallback
        if (player.phcp !== undefined && player.phcp !== null && player.phcp !== '') {
          return player.phcp;
        }
        // Calculate PHCP if not stored
        const calculatedPhcp = calculatePlayingHcp(player, 0);
        if (calculatedPhcp !== null) {
          player.phcp = calculatedPhcp; // Cache it
          return calculatedPhcp;
        }
        return null;
      }

      function getCategoryPlayers() {
        const allPlayers = getAdmittedPlayers();
        // Filter players who belong to this category
        return allPlayers.filter(player => {
          if (player.categories && Array.isArray(player.categories)) {
            return player.categories.includes(categoryCode);
          }
          return player.category === categoryCode;
        });
      }

      function calculateNetScore(grossScore, hcp) {
        if (typeof grossScore !== 'number' || isNaN(grossScore)) return null;
        if (typeof hcp !== 'number' || isNaN(hcp)) return grossScore;
        return grossScore - hcp;
      }

      function calculateStablefordTotal(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        if (!playerScores || !playerScores.stablefordPoints) return null;
        
        // Check if array is empty or all values are empty/null
        const hasAnyScore = playerScores.stablefordPoints.some(p => p !== null && p !== undefined && p !== '');
        if (!hasAnyScore) return null;
        
        return playerScores.stablefordPoints.reduce((sum, points) => {
          const p = parseInt(points);
          return sum + (isNaN(p) ? 0 : p);
        }, 0);
      }

      function calculateGrossTotal(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        if (!playerScores || !playerScores.holes) return null;
        
        // Check if array is empty or all values are empty/null
        const hasAnyScore = playerScores.holes.some(h => h !== null && h !== undefined && h !== '');
        if (!hasAnyScore) return null;
        
        return playerScores.holes.reduce((sum, strokes) => {
          const s = parseInt(strokes);
          return sum + (isNaN(s) ? 0 : s);
        }, 0);
      }

      function getPlayerRoundScore(player, roundId, tournamentType) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        
        // If no score record exists at all, return null
        if (!playerScores) return null;
        
        // Check for status first
        if (playerScores.status && playerScores.status !== 'OK') {
          return playerScores.status; // DQ, NS, NR
        }
        
        // If status is explicitly 'OK' or undefined, check for actual scores
        const typeUpper = (tournamentType || '').toUpperCase();
        let result = null;
        
        if (typeUpper.includes('STABLEFORD')) {
          result = calculateStablefordTotal(player, roundId);
        } else if (typeUpper.includes('MEDAL NET')) {
          const gross = calculateGrossTotal(player, roundId);
          if (gross === null) {
            result = null;
          } else {
            const phcp = getPlayerPhcp(player) || 0;
            result = calculateNetScore(gross, phcp);
          }
        } else {
          // Stroke Play (gross)
          result = calculateGrossTotal(player, roundId);
        }
        
        // If we have a score record but no actual scores, treat as incomplete
        // This catches the case where scorecard was opened but not filled
        if (result === null && playerScores && !playerScores.status) {
          // Scorecard exists but is empty and has no status - this is incomplete
          return null;
        }
        
        return result;
      }

      // Check if a player has any incomplete holes (0/X scores) in any round
      function playerHasIncompleteHoles(player, roundIds) {
        const scores = getScores();
        
        for (const roundId of roundIds) {
          const playerScores = scores[roundId]?.[player.reg];
          if (!playerScores) continue;
          
          // Check incompleteHoles array
          if (playerScores.incompleteHoles && playerScores.incompleteHoles.length > 0) {
            return true;
          }
          
          // Check isIncompleteHole object
          if (playerScores.isIncompleteHole) {
            const hasIncomplete = Object.values(playerScores.isIncompleteHole).some(v => v === true);
            if (hasIncomplete) return true;
          }
        }
        
        return false;
      }

      function isPlayerRoundComplete(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        
        // No score record at all - incomplete
        if (!playerScores) return false;
        
        // Has a status (DQ, NS, NR) - considered complete
        if (playerScores.status && playerScores.status !== 'OK') return true;
        
        // Check if all 18 holes have scores
        if (playerScores.holes && Array.isArray(playerScores.holes)) {
          const completedHoles = playerScores.holes.filter(s => s !== '' && s !== null && s !== undefined).length;
          return completedHoles === 18;
        }
        
        // No holes array or empty - incomplete
        return false;
      }

      function checkIncompleteScores(players, roundIds, tournamentType) {
        const incomplete = [];
        const tournament = getTournament();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        console.log('=== Checking Incomplete Scores ===');
        console.log('Total players in category:', players.length);
        console.log('All round IDs:', roundIds);
        console.log('Today:', today.toISOString().split('T')[0]);
        
        // Determine which rounds should be completed based on today's date
        const roundsToCheck = [];
        
        if (tournament?.meta?.roundsData) {
          roundIds.forEach((roundId, index) => {
            const roundData = tournament.meta.roundsData[index];
            console.log(`Round ${index + 1} (${roundId}):`, roundData?.date);
            
            if (roundData && roundData.date) {
              const roundDate = new Date(roundData.date);
              roundDate.setHours(0, 0, 0, 0);
              
              console.log(`  Round date: ${roundDate.toISOString().split('T')[0]}, Should check: ${roundDate <= today}`);
              
              // Only check rounds that have already happened (date <= today)
              if (roundDate <= today) {
                roundsToCheck.push(roundId);
              }
            } else {
              // If no date info, check all rounds (backward compatibility)
              console.log('  No date info, checking this round');
              roundsToCheck.push(roundId);
            }
          });
        } else {
          // No date information, check all rounds
          console.log('No round data found, checking all rounds');
          roundsToCheck.push(...roundIds);
        }
        
        console.log('Rounds to check:', roundsToCheck);
        
        // Check only the rounds that should be completed
        players.forEach(player => {
          roundsToCheck.forEach(roundId => {
            const isComplete = isPlayerRoundComplete(player, roundId);
            console.log(`${player.firstName} ${player.lastName} - ${roundId}: ${isComplete ? 'COMPLETE' : 'INCOMPLETE'}`);
            
            if (!isComplete) {
              const roundIndex = roundIds.indexOf(roundId);
              incomplete.push(`${player.firstName} ${player.lastName} - Round ${roundIndex + 1}`);
            }
          });
        });
        
        console.log('Total incomplete scorecards:', incomplete.length);
        console.log('Incomplete list:', incomplete);
        
        return incomplete;
      }

      function getCourseParForRound(roundId) {
        const tournament = getTournament();
        if (!tournament?.meta?.roundIds) return 72;
        
        const roundIndex = tournament.meta.roundIds.indexOf(roundId);
        
        // Get course identifier - first from roundData, then from tournament
        let courseIdentifier = null;
        
        if (roundIndex !== -1) {
          const roundData = tournament.meta.roundsData?.[roundIndex];
          if (roundData && roundData.course) {
            courseIdentifier = roundData.course;
          }
        }
        
        // Fallback to tournament course
        if (!courseIdentifier && tournament.course) {
          courseIdentifier = tournament.course;
        }
        
        if (!courseIdentifier) return 72;
        
        // Get course data
        try {
          const raw = localStorage.getItem('courses');
          const courses = raw ? JSON.parse(raw) : [];
          
          // Try to find by courseId first, then by courseName
          let course = courses.find(c => c.courseId === courseIdentifier);
          if (!course) {
            course = courses.find(c => c.courseName === courseIdentifier);
          }
          
          if (course && course.pars) {
            return course.pars.reduce((sum, p) => sum + (parseInt(p) || 0), 0);
          }
        } catch (err) {
          console.error('Error loading course data:', err);
        }
        
        return 72;
      }

      // ==================== TIEBREAKER FUNCTIONS ====================
      
      // Get the untie criteria from tournament settings
      function getUntieCriteria() {
        const tournament = getTournament();
        return tournament?.untieCriteria || [];
      }

      // Get course data for a round (stroke indexes, pars)
      function getCourseDataForRound(roundId) {
        const tournament = getTournament();
        if (!tournament?.meta?.roundIds) return null;
        
        const roundIndex = tournament.meta.roundIds.indexOf(roundId);
        if (roundIndex === -1) return null;
        
        const roundData = tournament.meta.roundsData?.[roundIndex];
        if (!roundData) return null;
        
        try {
          const raw = localStorage.getItem('courses');
          const courses = raw ? JSON.parse(raw) : [];
          return courses.find(c => c.courseId === roundData.course);
        } catch (err) {
          console.error('Error loading course data:', err);
          return null;
        }
      }

      // Get player's hole scores for a specific round
      function getPlayerHoleScores(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        return playerScores?.holes || [];
      }

      // Get player's stableford points for a specific round
      function getPlayerStablefordPoints(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        return playerScores?.stablefordPoints || [];
      }

      // Tiebreaker: Last Round Score
      function tiebreakLastRound(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        let scoreA, scoreB;
        if (isStableford) {
          scoreA = calculateStablefordTotal(playerA, lastRoundId) || 0;
          scoreB = calculateStablefordTotal(playerB, lastRoundId) || 0;
          return scoreB - scoreA; // Higher is better for Stableford
        } else {
          scoreA = calculateGrossTotal(playerA, lastRoundId) || 999;
          scoreB = calculateGrossTotal(playerB, lastRoundId) || 999;
          return scoreA - scoreB; // Lower is better for Stroke Play
        }
      }

      // Tiebreaker: Back 9 (holes 10-18 of last round)
      function tiebreakBack9(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(9, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(9, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(9, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(9, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last 6 Holes (holes 13-18 of last round)
      function tiebreakLast6(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(12, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(12, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(12, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(12, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last 3 Holes (holes 16-18 of last round)
      function tiebreakLast3(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(15, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(15, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(15, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(15, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last Hole (hole 18 of last round)
      function tiebreakLastHole(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const scoreA = parseInt(pointsA[17]) || 0;
          const scoreB = parseInt(pointsB[17]) || 0;
          return scoreB - scoreA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const scoreA = parseInt(holesA[17]) || 0;
          const scoreB = parseInt(holesB[17]) || 0;
          return scoreA - scoreB; // Lower is better
        }
      }

      // Tiebreaker: Lower Handicap
      function tiebreakLowerHcp(playerA, playerB) {
        const hcpA = parseFloat(playerA.hcp) || 999;
        const hcpB = parseFloat(playerB.hcp) || 999;
        return hcpA - hcpB; // Lower HCP wins
      }

      // Tiebreaker: Score on holes by Stroke Index (starting from SI 1)
      function tiebreakStrokeIndex(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        const courseData = getCourseDataForRound(lastRoundId);
        if (!courseData || !courseData.strokeIndexes) return 0;
        
        const strokeIndexes = courseData.strokeIndexes;
        
        // Create array of hole indices sorted by stroke index (SI 1 first)
        const holesBySI = strokeIndexes
          .map((si, holeIndex) => ({ si: parseInt(si) || 99, holeIndex }))
          .sort((a, b) => a.si - b.si);
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          
          for (const { holeIndex } of holesBySI) {
            const scoreA = parseInt(pointsA[holeIndex]) || 0;
            const scoreB = parseInt(pointsB[holeIndex]) || 0;
            if (scoreA !== scoreB) {
              return scoreB - scoreA; // Higher is better for Stableford
            }
          }
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          
          for (const { holeIndex } of holesBySI) {
            const scoreA = parseInt(holesA[holeIndex]) || 0;
            const scoreB = parseInt(holesB[holeIndex]) || 0;
            if (scoreA !== scoreB) {
              return scoreA - scoreB; // Lower is better for Stroke Play
            }
          }
        }
        
        return 0; // Still tied
      }

      // Tiebreaker: More Eagles, Birdies, Pars (countback)
      function tiebreakEaglesBirdiesPars(playerA, playerB, roundIds) {
        const courseData = roundIds.length > 0 ? getCourseDataForRound(roundIds[roundIds.length - 1]) : null;
        if (!courseData || !courseData.pars) return 0;
        
        const pars = courseData.pars;
        
        // Count eagles, birdies, pars for each player across all rounds
        let countA = { eagles: 0, birdies: 0, pars: 0 };
        let countB = { eagles: 0, birdies: 0, pars: 0 };
        
        roundIds.forEach(roundId => {
          const holesA = getPlayerHoleScores(playerA, roundId);
          const holesB = getPlayerHoleScores(playerB, roundId);
          
          holesA.forEach((score, i) => {
            const s = parseInt(score);
            const par = parseInt(pars[i]) || 4;
            if (!isNaN(s)) {
              const diff = s - par;
              if (diff <= -2) countA.eagles++;
              else if (diff === -1) countA.birdies++;
              else if (diff === 0) countA.pars++;
            }
          });
          
          holesB.forEach((score, i) => {
            const s = parseInt(score);
            const par = parseInt(pars[i]) || 4;
            if (!isNaN(s)) {
              const diff = s - par;
              if (diff <= -2) countB.eagles++;
              else if (diff === -1) countB.birdies++;
              else if (diff === 0) countB.pars++;
            }
          });
        });
        
        // Compare eagles first, then birdies, then pars
        if (countA.eagles !== countB.eagles) return countB.eagles - countA.eagles;
        if (countA.birdies !== countB.birdies) return countB.birdies - countA.birdies;
        if (countA.pars !== countB.pars) return countB.pars - countA.pars;
        
        return 0; // Still tied
      }

      // Tiebreaker: Play Off - checks if a play-off result was recorded
      // Play-off results are stored in tournament.playOffResults[categoryCode] = [{ playerReg, position, tiedScore }]
      // 
      // Important: Supports PARTIAL play-off results. If only the winner is set and others are "Not Set",
      // the winner gets priority, and the remaining players continue to the next tiebreaker criteria.
      // 
      // Example scenario:
      // - 3 players tied for 1st (all scored 70)
      // - Play-off: Player 1 scores 4, Players 2 & 3 score 5
      // - User marks Player 1 as "1st (Winner)", leaves 2 & 3 as "Not Set"
      // - Result: Player 1 ranks 1st, Players 2 & 3 use other criteria
      function tiebreakPlayOff(playerA, playerB) {
        const tournament = getTournament();
        if (!tournament.playOffResults || !tournament.playOffResults[categoryCode]) {
          return 0; // No play-off recorded
        }
        
        const playOffResults = tournament.playOffResults[categoryCode];
        
        // Find positions for both players
        const resultA = playOffResults.find(r => r.playerReg === playerA.reg);
        const resultB = playOffResults.find(r => r.playerReg === playerB.reg);
        
        // Case 1: Neither player has a play-off result - continue to other criteria
        if (!resultA && !resultB) {
          return 0;
        }
        
        // Case 2: Both have play-off results in the same tie group
        if (resultA && resultB && resultA.tiedScore === resultB.tiedScore) {
          // Compare positions (lower position = better, 1st beats 2nd)
          return resultA.position - resultB.position;
        }
        
        // Case 3: Only player A has a play-off result
        // Player A was explicitly marked in play-off, which means they resolved their tie
        // Player B might be in the same tie group but wasn't marked (left as "Not Set")
        if (resultA && !resultB) {
          // A has a play-off position, A ranks better
          return -1;
        }
        
        // Case 4: Only player B has a play-off result  
        if (!resultA && resultB) {
          // B has a play-off position, B ranks better
          return 1;
        }
        
        // Case 5: Both have results but in different tie groups
        // This shouldn't happen in practice, but handle it gracefully
        return 0;
      }

      // Main tiebreaker comparison function
      function compareTiebreakers(prA, prB, roundIds, isStableford) {
        // First, always check for play-off results (fixed at position 2)
        const playOffResult = tiebreakPlayOff(prA.player, prB.player);
        if (playOffResult !== 0) {
          console.log(`Tiebreak resolved by Play Off: ${prA.player.firstName} ${prA.player.lastName} vs ${prB.player.firstName} ${prB.player.lastName} = ${playOffResult}`);
          return playOffResult;
        }
        
        const criteria = getUntieCriteria();
        
        // If no additional tiebreaker criteria defined, return 0 (keep tie)
        if (!criteria || criteria.length === 0) return 0;
        
        for (const criteriaId of criteria) {
          let result = 0;
          
          switch (criteriaId) {
            case 'last_round':
              result = tiebreakLastRound(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'back_9':
              result = tiebreakBack9(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_6':
              result = tiebreakLast6(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_3':
              result = tiebreakLast3(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_hole':
              result = tiebreakLastHole(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'lower_hcp':
              result = tiebreakLowerHcp(prA.player, prB.player);
              break;
            case 'stroke_index':
              result = tiebreakStrokeIndex(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'eagles_birdies_pars':
              result = tiebreakEaglesBirdiesPars(prA.player, prB.player, roundIds);
              break;
          }
          
          if (result !== 0) {
            console.log(`Tiebreak resolved by ${criteriaId}: ${prA.player.firstName} ${prA.player.lastName} vs ${prB.player.firstName} ${prB.player.lastName} = ${result}`);
            return result;
          }
        }
        
        return 0; // All tiebreakers exhausted, still tied
      }

      // ==================== END TIEBREAKER FUNCTIONS ====================

      // ==================== TEAM RESULTS FUNCTIONS ====================

      function generateTeamResults() {
        const tournament = getTournament();
        if (!tournament) {
          alert('Tournament not found');
          return;
        }

        document.getElementById('tournament-name').textContent = tournament.name;
        document.getElementById('category-name').textContent = 'Team Results';

        const teams = getTeams();
        const allPlayers = getAdmittedPlayers();
        const roundIds = tournament.meta?.roundIds || [];
        const teamScoresCount = parseInt(tournament.meta?.teamScoresCount) || 3; // Best N scores count
        const teamMaxPlayers = parseInt(tournament.meta?.teamMaxPlayers) || 4;

        console.log('=== TEAM RESULTS DEBUG ===');
        console.log('Teams loaded:', teams.length, teams);
        console.log('All admitted players:', allPlayers.length);
        console.log('Round IDs:', roundIds);
        console.log('Team scores count:', teamScoresCount);
        console.log('Team max players:', teamMaxPlayers);

        // Filter teams that have players
        const teamsWithPlayers = teams.filter(t => t.players && t.players.length > 0);
        console.log('Teams with players:', teamsWithPlayers.length);

        // Show team scoring info
        const warningDiv = document.getElementById('warning-container');
        warningDiv.innerHTML = `<div class="info-message">üèÜ Team Scoring: Best ${teamScoresCount} out of ${teamMaxPlayers} player scores per team</div>`;

        // Add class to table for team-specific styling
        document.getElementById('results-table').classList.add('team-results-table');

        // Build colgroup for fixed column widths
        let colgroupHTML = '<colgroup>';
        colgroupHTML += '<col class="col-rank">';
        colgroupHTML += '<col class="col-name">';
        if (showHcp) colgroupHTML += '<col class="col-hcp">';
        if (showPhcp) colgroupHTML += '<col class="col-phcp">';
        if (showToPar) colgroupHTML += '<col class="col-topar">';
        if (roundIds.length > 1) {
          roundIds.forEach(() => {
            colgroupHTML += '<col class="col-round">';
          });
        }
        colgroupHTML += '<col class="col-score">';
        colgroupHTML += '</colgroup>';

        // Build table header
        let headerHTML = '<tr>';
        headerHTML += '<th class="text-center">Rank</th>';
        headerHTML += '<th>Team / Player</th>';
        if (showHcp) headerHTML += '<th class="text-center">HCP</th>';
        if (showPhcp) headerHTML += '<th class="text-center">PHCP</th>';
        if (showToPar) headerHTML += '<th class="text-center">To Par</th>';
        
        // Add round columns if multiple rounds
        if (roundIds.length > 1) {
          roundIds.forEach((_, index) => {
            headerHTML += `<th class="text-center">R${index + 1}</th>`;
          });
        }
        
        headerHTML += '<th class="text-center">Scores</th>';
        headerHTML += '</tr>';
        
        // Insert colgroup before thead
        const table = document.getElementById('results-table');
        const existingColgroup = table.querySelector('colgroup');
        if (existingColgroup) existingColgroup.remove();
        table.insertAdjacentHTML('afterbegin', colgroupHTML);
        
        document.getElementById('table-head').innerHTML = headerHTML;

        // Calculate team scores
        const teamResults = teams.map(team => {
          // Get player data for this team
          const teamPlayers = (team.players || []).map(playerId => {
            return allPlayers.find(p => (p.reg === playerId || p.playerId === playerId));
          }).filter(p => p); // Remove undefined

          // Calculate scores for each player across all rounds
          const playerScoresData = teamPlayers.map(player => {
            let totalStableford = 0;
            let hasAnyScore = false;
            const roundScores = [];

            roundIds.forEach(roundId => {
              const stablefordScore = calculateStablefordTotal(player, roundId);
              if (stablefordScore !== null && typeof stablefordScore === 'number') {
                totalStableford += stablefordScore;
                hasAnyScore = true;
                roundScores.push(stablefordScore);
              } else {
                // Check for status
                const scores = getScores();
                const playerScores = scores[roundId]?.[player.reg];
                if (playerScores?.status && playerScores.status !== 'OK') {
                  roundScores.push(playerScores.status);
                } else {
                  roundScores.push(null);
                }
              }
            });

            // Get player HCP and PHCP
            const hcp = player.hcp;
            const phcp = getPlayerPhcp(player);

            return {
              player,
              totalStableford: hasAnyScore ? totalStableford : null,
              roundScores,
              hasScore: hasAnyScore,
              hcp,
              phcp
            };
          });

          // Sort players by total stableford (highest first) for determining best N
          const sortedPlayers = [...playerScoresData].sort((a, b) => (b.totalStableford || 0) - (a.totalStableford || 0));
          
          // Mark which players count toward team score (best N)
          const countingPlayerRegs = new Set();
          let countUsed = 0;
          sortedPlayers.forEach(ps => {
            if (ps.hasScore && countUsed < teamScoresCount) {
              countingPlayerRegs.add(ps.player.reg);
              countUsed++;
            }
          });

          // Calculate team total from best N
          let teamTotal = 0;
          sortedPlayers.forEach(ps => {
            if (countingPlayerRegs.has(ps.player.reg)) {
              teamTotal += ps.totalStableford || 0;
            }
          });

          // Calculate average HCP for team
          const hcpValues = playerScoresData.map(ps => parseFloat(ps.hcp)).filter(h => !isNaN(h));
          const avgHcp = hcpValues.length > 0 ? (hcpValues.reduce((a, b) => a + b, 0) / hcpValues.length).toFixed(1) : null;

          // Calculate round totals for display (sum of best N players per round)
          const roundTotals = roundIds.map((roundId, roundIndex) => {
            const roundPlayerScores = playerScoresData
              .map(ps => ({
                reg: ps.player.reg,
                score: typeof ps.roundScores[roundIndex] === 'number' ? ps.roundScores[roundIndex] : null
              }))
              .filter(s => s.score !== null)
              .sort((a, b) => b.score - a.score);

            // Sum best N for this round
            return roundPlayerScores.slice(0, teamScoresCount).reduce((sum, s) => sum + s.score, 0);
          });

          return {
            team,
            teamTotal,
            avgHcp,
            roundTotals,
            playerScoresData,
            countingPlayerRegs,
            hasValidScore: countingPlayerRegs.size > 0
          };
        });

        // Get team untie criteria - always include play_off as fixed position 1 (after total score which is implicit)
        const savedTeamUntieCriteria = tournament.teamUntieCriteria || [];
        // Ensure team_play_off is always first in the criteria (it's the fixed #2 after total score)
        const teamUntieCriteria = ['team_play_off', ...savedTeamUntieCriteria.filter(c => c !== 'team_play_off' && c !== 'play_off')];
        const hasTeamTiebreakers = true; // Always has at least play_off

        // Helper function to get uncounted scores by round for a team (final round first)
        function getUncountedScoresByRound(teamResult) {
          const uncountedByRound = [];
          const numRounds = roundIds.length;
          
          // Process rounds from last (final) to first
          for (let roundIdx = numRounds - 1; roundIdx >= 0; roundIdx--) {
            // Get scores for this round from non-counting players
            const uncountedScores = teamResult.playerScoresData
              .filter(ps => !teamResult.countingPlayerRegs.has(ps.player.reg)) // Non-counting players
              .map(ps => {
                const score = ps.roundScores[roundIdx];
                return typeof score === 'number' ? score : null;
              })
              .filter(score => score !== null)
              .sort((a, b) => b - a); // Highest first (better for Stableford)
            
            uncountedByRound.push(uncountedScores);
          }
          
          return uncountedByRound; // Array of arrays: [[finalRoundScores], [prevRoundScores], ...]
        }

        // Team tiebreaker comparison function
        function compareTeamTiebreakers(teamA, teamB) {
          for (const criteriaId of teamUntieCriteria) {
            let result = 0;
            
            // Get sorted player scores (highest first) for each team
            const scoresA = teamA.playerScoresData
              .filter(ps => ps.hasScore)
              .map(ps => ps.totalStableford)
              .sort((a, b) => b - a);
            const scoresB = teamB.playerScoresData
              .filter(ps => ps.hasScore)
              .map(ps => ps.totalStableford)
              .sort((a, b) => b - a);
            
            switch (criteriaId) {
              case 'team_best_uncounted':
                // Compare non-counting scores starting from best uncounted of final round
                // Then 2nd uncounted of final round, etc. When exhausted, move to previous round
                const uncountedA = getUncountedScoresByRound(teamA);
                const uncountedB = getUncountedScoresByRound(teamB);
                
                // Iterate through rounds (already ordered from final to first)
                for (let roundIdx = 0; roundIdx < uncountedA.length || roundIdx < uncountedB.length; roundIdx++) {
                  const roundScoresA = uncountedA[roundIdx] || [];
                  const roundScoresB = uncountedB[roundIdx] || [];
                  
                  // Compare scores within this round (best to worst)
                  const maxScores = Math.max(roundScoresA.length, roundScoresB.length);
                  for (let scoreIdx = 0; scoreIdx < maxScores; scoreIdx++) {
                    const scoreA = roundScoresA[scoreIdx];
                    const scoreB = roundScoresB[scoreIdx];
                    
                    // If one team has a score and the other doesn't, the one with score wins
                    if (scoreA !== undefined && scoreB === undefined) {
                      result = -1; // Team A has more uncounted scores, wins
                      break;
                    }
                    if (scoreB !== undefined && scoreA === undefined) {
                      result = 1; // Team B has more uncounted scores, wins
                      break;
                    }
                    
                    // Compare the scores (higher is better for Stableford)
                    if (scoreA !== undefined && scoreB !== undefined) {
                      const diff = scoreA - scoreB;
                      if (diff !== 0) {
                        result = -diff; // Negative if A > B (A wins), positive if B > A (B wins)
                        break;
                      }
                    }
                  }
                  
                  if (result !== 0) break; // Tiebreaker resolved
                }
                break;

              case 'team_best_player':
                // Compare best individual scores
                result = (scoresB[0] || 0) - (scoresA[0] || 0);
                if (result !== 0) result = -result; // Higher is better
                break;
                
              case 'team_2nd_best':
                // Compare 2nd best individual scores
                result = (scoresB[1] || 0) - (scoresA[1] || 0);
                if (result !== 0) result = -result;
                break;
                
              case 'team_3rd_best':
                // Compare 3rd best individual scores
                result = (scoresB[2] || 0) - (scoresA[2] || 0);
                if (result !== 0) result = -result;
                break;
                
              case 'team_4th_best':
                // Compare 4th best individual scores
                result = (scoresB[3] || 0) - (scoresA[3] || 0);
                if (result !== 0) result = -result;
                break;
                
              case 'team_lower_avg_hcp':
                // Lower average HCP wins
                const avgA = parseFloat(teamA.avgHcp) || 999;
                const avgB = parseFloat(teamB.avgHcp) || 999;
                result = avgA - avgB;
                break;
                
              case 'team_countback_best':
                // Compare counting scores one by one
                const countA = scoresA.slice(0, teamScoresCount);
                const countB = scoresB.slice(0, teamScoresCount);
                for (let i = 0; i < Math.max(countA.length, countB.length); i++) {
                  const diff = (countB[i] || 0) - (countA[i] || 0);
                  if (diff !== 0) {
                    result = -diff; // Higher is better
                    break;
                  }
                }
                break;
                
              case 'team_more_birdies':
                // Count total birdies across all team players
                // This would require hole-by-hole data - simplified version
                // Just use as secondary check based on total scores for now
                break;
                
              case 'play_off':
              case 'team_play_off':
                // Team play-off tiebreaker
                const playOffResults = tournament.playOffResults?.[categoryCode] || [];
                const playOffA = playOffResults.find(r => r.teamId === teamA.team.teamId);
                const playOffB = playOffResults.find(r => r.teamId === teamB.team.teamId);
                
                // Neither team has play-off result
                if (!playOffA && !playOffB) {
                  result = 0;
                  break;
                }
                
                // Both have play-off results in the same tie group
                if (playOffA && playOffB && playOffA.tiedScore === playOffB.tiedScore) {
                  result = playOffA.position - playOffB.position;
                  break;
                }
                
                // Only team A has play-off result
                if (playOffA && !playOffB) {
                  result = -1;
                  break;
                }
                
                // Only team B has play-off result
                if (!playOffA && playOffB) {
                  result = 1;
                  break;
                }
                break;
            }
            
            if (result !== 0) {
              console.log(`Team tiebreak resolved by ${criteriaId}: ${teamA.team.name} vs ${teamB.team.name} = ${result}`);
              return result;
            }
          }
          return 0; // Still tied
        }

        // Sort teams by total (higher is better for Stableford), then apply tiebreakers
        teamResults.sort((a, b) => {
          if (!a.hasValidScore && !b.hasValidScore) return 0;
          if (!a.hasValidScore) return 1;
          if (!b.hasValidScore) return -1;
          
          // Primary: team total
          const totalDiff = b.teamTotal - a.teamTotal;
          
          // If tied and tiebreakers are enabled, apply them
          if (totalDiff === 0 && hasTeamTiebreakers) {
            return compareTeamTiebreakers(a, b);
          }
          
          return totalDiff;
        });

        // Assign ranks - consider tiebreakers for unique ranks
        let currentRank = 1;
        let previousTotal = null;
        
        teamResults.forEach((tr, index) => {
          if (!tr.hasValidScore) {
            tr.rank = '-';
          } else if (index === 0) {
            tr.rank = 1;
            currentRank = 1;
            previousTotal = tr.teamTotal;
          } else {
            const prevTeam = teamResults[index - 1];
            
            if (tr.teamTotal === prevTeam.teamTotal) {
              // If tiebreakers resolved it, give next rank
              if (hasTeamTiebreakers && compareTeamTiebreakers(prevTeam, tr) !== 0) {
                currentRank = index + 1;
                tr.rank = currentRank;
              } else {
                // Still tied - same rank
                tr.rank = currentRank;
              }
            } else {
              currentRank = index + 1;
              tr.rank = currentRank;
            }
            previousTotal = tr.teamTotal;
          }
        });

        // Build table body - each team has a header row + player rows
        let bodyHTML = '';
        
        teamResults.forEach(tr => {
          // Team header row
          bodyHTML += '<tr class="team-row">';
          bodyHTML += `<td class="text-center" style="font-weight: 700;">${tr.rank}</td>`;
          bodyHTML += `<td style="font-weight: 700;">${tr.team.name}</td>`;
          if (showHcp) bodyHTML += `<td class="text-center" style="font-weight: 600;">AVG (${tr.avgHcp || '-'})</td>`;
          if (showPhcp) bodyHTML += `<td class="text-center"></td>`;
          if (showToPar) bodyHTML += `<td class="text-center"></td>`;
          
          // Round totals for team (if multiple rounds)
          if (roundIds.length > 1) {
            tr.roundTotals.forEach(roundTotal => {
              bodyHTML += `<td class="text-center" style="font-weight: 600;">${roundTotal || '-'}</td>`;
            });
          }
          
          bodyHTML += `<td class="text-center" style="font-weight: 700;">${tr.teamTotal || '-'}</td>`;
          bodyHTML += '</tr>';

          // Player rows (sorted by score descending)
          const sortedPlayers = [...tr.playerScoresData].sort((a, b) => (b.totalStableford || 0) - (a.totalStableford || 0));
          
          sortedPlayers.forEach(ps => {
            const isCounting = tr.countingPlayerRegs.has(ps.player.reg);
            const scoreColor = isCounting ? 'color: #16a34a; font-weight: 600;' : '';
            const playerName = `${ps.player.firstName} ${ps.player.lastName}`;
            
            bodyHTML += '<tr class="player-row">';
            bodyHTML += `<td></td>`; // Empty rank for player rows
            bodyHTML += `<td style="padding-left: 20px;">${playerName}</td>`;
            
            if (showHcp) {
              const hcpDisplay = ps.hcp !== null && ps.hcp !== undefined ? ps.hcp : '-';
              bodyHTML += `<td class="text-center">${hcpDisplay}</td>`;
            }
            
            if (showPhcp) {
              const phcpDisplay = ps.phcp !== null && ps.phcp !== undefined ? (ps.phcp < 0 ? '+' + Math.abs(ps.phcp) : ps.phcp) : '-';
              bodyHTML += `<td class="text-center">${phcpDisplay}</td>`;
            }
            
            if (showToPar) {
              // Calculate to par for this player
              const toPar = calculateToParForPlayer(ps.player, roundIds);
              const toParDisplay = toPar !== null ? (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar)) : '-';
              bodyHTML += `<td class="text-center">${toParDisplay}</td>`;
            }
            
            // Round scores (if multiple rounds)
            if (roundIds.length > 1) {
              ps.roundScores.forEach(score => {
                if (typeof score === 'string') {
                  bodyHTML += `<td class="text-center">${score}</td>`;
                } else if (score !== null) {
                  bodyHTML += `<td class="text-center" style="${scoreColor}">${score}</td>`;
                } else {
                  bodyHTML += `<td class="text-center">-</td>`;
                }
              });
            }
            
            // Total score
            const scoreDisplay = ps.hasScore ? ps.totalStableford : '-';
            bodyHTML += `<td class="text-center" style="${scoreColor}">${scoreDisplay}</td>`;
            
            bodyHTML += '</tr>';
          });
        });

        document.getElementById('table-body').innerHTML = bodyHTML;
        
        // Save calculated team results to Firebase
        console.log('Preparing to save team results for category:', categoryCode);
        const teamResultsToSave = teamResults.map(tr => ({
          type: 'team',
          teamId: tr.team.teamId,
          teamName: tr.team.name,
          rank: tr.rank,
          total: tr.teamTotal,
          roundTotals: tr.roundTotals,
          avgHcp: tr.avgHcp,
          players: tr.playerScoresData.map(ps => ({
            reg: ps.player.reg,
            firstName: ps.player.firstName,
            lastName: ps.player.lastName,
            club: ps.player.club || ps.player.homeClub
          }))
        }));
        console.log('Team results to save:', teamResultsToSave.length, 'teams');
        saveCalculatedResults(categoryCode, teamResultsToSave);
      }

      // ==================== END TEAM RESULTS FUNCTIONS ====================

      function calculateToParForPlayer(player, roundIds) {
        // To Par is ALWAYS based on gross scores, regardless of tournament format
        const tournament = getTournament();
        
        let totalToPar = 0;
        let hasAnyScore = false;
        
        roundIds.forEach((roundId, index) => {
          // Get gross score for this round
          const grossScore = calculateGrossTotal(player, roundId);
          
          if (grossScore !== null && typeof grossScore === 'number') {
            const par = getCourseParForRound(roundId);
            totalToPar += (grossScore - par);
            hasAnyScore = true;
          }
        });
        
        return hasAnyScore ? totalToPar : null;
      }

      function generateResults() {
        const tournament = getTournament();
        if (!tournament) {
          alert('Tournament not found');
          return;
        }

        document.getElementById('tournament-name').textContent = tournament.name;
        document.getElementById('category-name').textContent = categoryName;

        const category = tournament.categories?.find(c => c.code === categoryCode);
        if (!category) {
          alert('Category not found');
          return;
        }

        const players = getCategoryPlayers();
        const roundIds = tournament.meta?.roundIds || [];
        const tournamentType = category.tournamentType || 'Stroke Play';

        // Check for incomplete scores
        const incompleteScores = checkIncompleteScores(players, roundIds, tournamentType);
        if (incompleteScores.length > 0) {
          const proceed = confirm(`Warning: There are ${incompleteScores.length} incomplete scorecard(s) for this category:\n\n${incompleteScores.slice(0, 5).join('\n')}${incompleteScores.length > 5 ? `\n... and ${incompleteScores.length - 5} more` : ''}\n\nAre you sure you want to continue?`);
          if (!proceed) {
            window.close();
            return;
          }
          
          // Show warning on page
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML = `<div class="warning-message">‚ö†Ô∏è Warning: ${incompleteScores.length} incomplete scorecard(s) detected</div>`;
        }

        // Show tiebreaker criteria if configured
        const untieCriteriaList = getUntieCriteria();
        if (untieCriteriaList && untieCriteriaList.length > 0) {
          const criteriaNames = {
            'last_round': 'Last Round Score',
            'back_9': 'Back 9 Score',
            'last_6': 'Last 6 Holes',
            'last_3': 'Last 3 Holes',
            'last_hole': 'Last Hole',
            'lower_hcp': 'Lower Handicap',
            'stroke_index': 'Score on Lower S.I. Holes',
            'eagles_birdies_pars': 'More Eagles, Birdies, Pars'
          };
          const criteriaDisplay = untieCriteriaList.map(c => criteriaNames[c] || c).join(' ‚Üí ');
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML += `<div class="tiebreaker-info">‚öñÔ∏è Tiebreaker: Total Score ‚Üí Play Off (if played) ‚Üí ${criteriaDisplay}</div>`;
        } else {
          // Show default tiebreaker info even if no additional criteria selected
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML += `<div class="tiebreaker-info">‚öñÔ∏è Tiebreaker: Total Score ‚Üí Play Off (if played)</div>`;
        }

        // Build table header
        let headerHTML = '<tr>';
        headerHTML += '<th class="text-center">Rank</th>';
        headerHTML += '<th>Player</th>';
        if (displayType === 'club') headerHTML += '<th>Club</th>';
        if (displayType === 'country') headerHTML += '<th>Country</th>';
        if (showHcp) headerHTML += '<th class="text-center">HCP</th>';
        if (showPhcp) headerHTML += '<th class="text-center">PHCP</th>';
        if (showToPar) headerHTML += '<th class="text-center">To Par</th>';
        
        // Add round columns
        if (roundIds.length === 1) {
          headerHTML += '<th class="text-center">Score</th>';
        } else {
          roundIds.forEach((_, index) => {
            headerHTML += `<th class="text-center">D${index + 1}</th>`;
          });
          headerHTML += '<th class="text-center total-cell">Total</th>';
        }
        
        headerHTML += '</tr>';
        document.getElementById('table-head').innerHTML = headerHTML;

        // Determine tournament type
        const typeUpper = (tournamentType || '').toUpperCase();
        const isStableford = typeUpper.includes('STABLEFORD');
        const isStrokePlay = typeUpper.includes('STROKE') || typeUpper.includes('GROSS') || (!isStableford && !typeUpper.includes('MEDAL NET'));
        
        // Filter players: For Stroke Play (gross), exclude players with incomplete holes (0/X scores)
        let eligiblePlayers = players;
        let excludedPlayers = [];
        
        if (isStrokePlay) {
          eligiblePlayers = players.filter(player => !playerHasIncompleteHoles(player, roundIds));
          excludedPlayers = players.filter(player => playerHasIncompleteHoles(player, roundIds));
          
          if (excludedPlayers.length > 0) {
            console.log(`Stroke Play: Excluding ${excludedPlayers.length} player(s) with incomplete holes (0/X scores)`);
            excludedPlayers.forEach(p => console.log(`  - ${p.firstName} ${p.lastName}`));
            
            // Show info message on page
            const warningDiv = document.getElementById('warning-container');
            const existingContent = warningDiv.innerHTML;
            warningDiv.innerHTML = existingContent + `<div class="info-message">‚ÑπÔ∏è ${excludedPlayers.length} player(s) excluded from Stroke Play results due to incomplete holes (0/X scores)</div>`;
          }
        }

        // Calculate scores for all eligible players
        const playerResults = eligiblePlayers.map(player => {
          const roundScores = roundIds.map(roundId => getPlayerRoundScore(player, roundId, tournamentType));
          
          // Check if player has status
          const hasStatus = roundScores.some(score => typeof score === 'string' && ['DQ', 'NS', 'NR'].includes(score));
          const statusValue = hasStatus ? roundScores.find(score => typeof score === 'string') : null;
          
          let total = null;
          if (!hasStatus) {
            total = roundScores.reduce((sum, score) => {
              if (typeof score === 'number') return sum + score;
              return sum;
            }, 0);
          }
          
          return {
            player,
            roundScores,
            total,
            status: statusValue,
            hasStatus
          };
        });

        // Sort players
        // (typeUpper and isStableford already declared above)
        
        // Separate normal players and status players
        const normalPlayers = playerResults.filter(pr => !pr.hasStatus);
        const statusPlayers = playerResults.filter(pr => pr.hasStatus);
        
        // Get untie criteria to check if tiebreakers are enabled
        const untieCriteria = getUntieCriteria();
        const hasUntieCriteria = untieCriteria && untieCriteria.length > 0;
        
        // Check if play-off results exist for this category (tournament already declared above)
        const hasPlayOffResults = tournament?.playOffResults?.[categoryCode]?.length > 0;
        
        // Tiebreakers are active if either play-off results exist OR untie criteria are set
        const hasTiebreakers = hasPlayOffResults || hasUntieCriteria;
        
        // Sort normal players by total, then apply tiebreakers if enabled
        normalPlayers.sort((a, b) => {
          if (a.total === null && b.total === null) return 0;
          if (a.total === null) return 1;
          if (b.total === null) return -1;
          
          // Primary comparison: total score
          let comparison;
          if (isStableford) {
            comparison = b.total - a.total; // Higher is better
          } else {
            comparison = a.total - b.total; // Lower is better
          }
          
          // If tied and tiebreakers are enabled, apply them
          if (comparison === 0 && hasTiebreakers) {
            return compareTiebreakers(a, b, roundIds, isStableford);
          }
          
          return comparison;
        });

        // Assign ranks - now each player should have unique rank if tiebreakers resolved the tie
        let currentRank = 1;
        let previousTotal = null;
        let previousTiebreakerResult = null;
        
        normalPlayers.forEach((pr, index) => {
          if (pr.total === null) {
            pr.rank = '-';
          } else if (index === 0) {
            // First player
            pr.rank = 1;
            currentRank = 1;
            previousTotal = pr.total;
          } else {
            const prevPlayer = normalPlayers[index - 1];
            
            // Check if this player has the same total as previous
            if (pr.total === prevPlayer.total) {
              // If tiebreakers are enabled, check if they're actually still tied
              if (hasTiebreakers) {
                const tiebreakerResult = compareTiebreakers(prevPlayer, pr, roundIds, isStableford);
                if (tiebreakerResult !== 0) {
                  // Tiebreaker resolved - give next rank
                  currentRank = index + 1;
                  pr.rank = currentRank;
                } else {
                  // Still tied after tiebreakers
                  pr.rank = currentRank;
                }
              } else {
                // No tiebreakers - same rank
                pr.rank = currentRank;
              }
            } else {
              // Different total - new rank
              currentRank = index + 1;
              pr.rank = currentRank;
            }
            
            previousTotal = pr.total;
          }
        });

        // Build table body
        const allResults = [...normalPlayers, ...statusPlayers];
        let bodyHTML = '';
        
        allResults.forEach(pr => {
          const isStatusRow = pr.hasStatus;
          bodyHTML += `<tr${isStatusRow ? ' class="status-row"' : ''}>`;
          
          // Rank
          bodyHTML += `<td class="text-center rank-cell">${pr.rank || '-'}</td>`;
          
          // Player
          bodyHTML += `<td class="player-cell">${pr.player.firstName} ${pr.player.lastName}</td>`;
          
          // Club/Country
          if (displayType === 'club') {
            bodyHTML += `<td>${pr.player.club || pr.player.homeClub || '-'}</td>`;
          }
          if (displayType === 'country') {
            bodyHTML += `<td>${pr.player.nationality || pr.player.country || '-'}</td>`;
          }
          
          // HCP
          if (showHcp) {
            const hcp = pr.player.hcp || '-';
            bodyHTML += `<td class="text-center">${hcp}</td>`;
          }
          
          // PHCP
          if (showPhcp) {
            const phcp = getPlayerPhcp(pr.player);
            const phcpDisplay = phcp !== null ? (phcp < 0 ? '+' + Math.abs(phcp) : phcp) : '-';
            bodyHTML += `<td class="text-center">${phcpDisplay}</td>`;
          }
          
          // To Par
          if (showToPar) {
            if (pr.hasStatus) {
              bodyHTML += `<td class="text-center">-</td>`;
            } else {
              const toPar = calculateToParForPlayer(pr.player, roundIds);
              if (toPar !== null) {
                const toParStr = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar.toString());
                bodyHTML += `<td class="text-center">${toParStr}</td>`;
              } else {
                bodyHTML += `<td class="text-center">-</td>`;
              }
            }
          }
          
          // Round scores
          pr.roundScores.forEach(score => {
            if (typeof score === 'string') {
              bodyHTML += `<td class="text-center">${score}</td>`;
            } else if (score !== null) {
              bodyHTML += `<td class="text-center">${score}</td>`;
            } else {
              bodyHTML += `<td class="text-center">-</td>`;
            }
          });
          
          // Total (only for multi-round)
          if (roundIds.length > 1) {
            if (pr.hasStatus) {
              bodyHTML += `<td class="text-center total-cell">${pr.status}</td>`;
            } else if (pr.total !== null) {
              bodyHTML += `<td class="text-center total-cell">${pr.total}</td>`;
            } else {
              bodyHTML += `<td class="text-center total-cell">-</td>`;
            }
          }
          
          bodyHTML += '</tr>';
        });

        document.getElementById('table-body').innerHTML = bodyHTML;
        
        // Save calculated individual results to Firebase
        const allPlayerResults = [...normalPlayers, ...statusPlayers];
        const individualResultsToSave = allPlayerResults.map(pr => ({
          type: 'individual',
          reg: pr.player.reg,
          firstName: pr.player.firstName,
          lastName: pr.player.lastName,
          club: pr.player.club || pr.player.homeClub,
          nationality: pr.player.nationality || pr.player.country,
          rank: pr.rank,
          total: pr.total,
          roundScores: pr.roundScores,
          status: pr.status || null,
          hcp: pr.player.hcp,
          phcp: pr.player.phcp
        }));
        saveCalculatedResults(categoryCode, individualResultsToSave);
      }

      // Generate results on page load
      if (!tournamentId || !categoryCode) {
        alert('Missing parameters');
        window.close();
      } else {
        // Check if this is a team category in a team tournament
        if (isTeamCategory()) {
          generateTeamResults();
        } else {
          generateResults();
        }
      }
    </script>
  </body>
</html>
