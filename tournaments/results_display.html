<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Results Display</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      body { 
        background: #f8fafc; 
        font-family: system-ui,-apple-system,sans-serif; 
        color: #1e293b; 
        margin: 0; 
        padding: 0;
        padding-top: 0;
      }
      .container { 
        max-width: 1200px; 
        margin: 0 auto; 
        padding: 20px; 
      }
      .header {
        background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
        color: white;
        padding: 30px 20px;
        text-align: center;
        margin-bottom: 24px;
        border-radius: 12px;
      }
      .header h1 {
        margin: 0 0 8px 0;
        font-size: 28px;
        font-weight: 700;
      }
      .header .subtitle {
        opacity: 0.9;
        font-size: 16px;
      }
      .results-card {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(2,6,23,0.08);
        overflow: hidden;
        margin-bottom: 24px;
      }
      .results-card-header {
        background: #f8fafc;
        padding: 16px 20px;
        border-bottom: 1px solid #e2e8f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .results-card-header h2 {
        margin: 0;
        font-size: 18px;
        color: #1e293b;
      }
      .results-table-wrapper { 
        background: white; 
        overflow-x: auto; 
        padding: 16px; 
      }
      .results-table { width: 100%; border-collapse: collapse; font-size: 14px; }
      .results-table thead th { 
        background: #f8fafc; 
        padding: 12px 16px; 
        text-align: left; 
        font-weight: 600; 
        font-size: 13px;
        color: #475569;
        border-bottom: 2px solid #e2e8f0;
        white-space: nowrap;
      }
      .results-table thead th.text-center { text-align: center; }
      .results-table thead th.text-right { text-align: right; }
      .results-table tbody tr {
        cursor: pointer;
        transition: background 0.15s;
      }
      .results-table tbody tr:hover { background: #f0f9ff; }
      .results-table tbody td { 
        padding: 12px 16px; 
        border-bottom: 1px solid #f1f5f9;
        color: #1e293b;
        font-size: 14px;
      }
      .results-table tbody td.text-center { text-align: center; }
      .results-table tbody td.text-right { text-align: right; }
      .results-table tbody tr.status-row { background: #fef2f2; opacity: 0.8; }
      .results-table tbody tr.status-row:hover { background: #fee2e2; }
      .rank-cell { font-weight: 700; color: #0f172a; font-size: 16px; text-align: center; width: 50px; }
      .rank-1 { color: #eab308; }
      .rank-2 { color: #94a3b8; }
      .rank-3 { color: #b45309; }
      .player-cell { font-weight: 600; color: #1e293b; }
      .total-cell { font-weight: 700; color: #0f172a; font-size: 16px; background: #f1f5f9; text-align: center; }
      .status-indicator { color: #dc2626 !important; font-weight: 700; font-size: 13px; }
      /* Team results specific styles */
      .team-results-table { width: 100%; table-layout: fixed; }
      .team-results-table .col-rank { width: 50px; }
      .team-results-table .col-name { width: auto; }
      .team-results-table .col-hcp { width: 80px; }
      .team-results-table .col-phcp { width: 60px; }
      .team-results-table .col-topar { width: 60px; }
      .team-results-table .col-round { width: 50px; }
      .team-results-table .col-score { width: 60px; }
      .team-row { background: #f1f5f9 !important; }
      .team-row:hover { background: #e2e8f0 !important; }
      .player-row td { padding-top: 6px !important; padding-bottom: 6px !important; }
      .warning-message { 
        background: #fef3c7; 
        border: 2px solid #f59e0b; 
        border-radius: 8px; 
        padding: 16px; 
        margin-bottom: 24px;
        text-align: center;
        color: #92400e;
        font-weight: 600;
      }
      .info-message { 
        background: #dbeafe; 
        border: 2px solid #3b82f6; 
        border-radius: 8px; 
        padding: 16px; 
        margin-bottom: 24px;
        text-align: center;
        color: #1e40af;
        font-weight: 600;
      }
      .tiebreaker-info {
        background: #f3e8ff;
        border: 2px solid #a855f7;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
        text-align: center;
        color: #7c3aed;
        font-weight: 500;
        font-size: 13px;
      }
      .action-buttons { 
        display: flex; 
        gap: 10px; 
        margin-top: 24px;
        justify-content: center;
      }
      .btn { 
        background: linear-gradient(180deg, var(--accent), #0a58d1); 
        color: white; 
        border: 0; 
        padding: 10px 20px; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 14px; 
        font-weight: 600;
        transition: transform 0.08s; 
      }
      .btn:active { transform: translateY(1px); }
      .btn-print { background: linear-gradient(180deg, #10b981, #059669); }
      .btn-back { 
        background: white; 
        color: #0b6efd; 
        border: 1px solid #e6e9ef; 
      }
      
      /* Scorecard Modal */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        z-index: 1000;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      .modal-overlay.active {
        display: flex;
      }
      .modal-content {
        background: white;
        border-radius: 16px;
        max-width: 900px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      }
      .modal-header {
        background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
        color: white;
        padding: 20px 24px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: sticky;
        top: 0;
      }
      .modal-header h3 {
        margin: 0;
        font-size: 20px;
      }
      .modal-close {
        background: rgba(255,255,255,0.2);
        border: none;
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .modal-close:hover {
        background: rgba(255,255,255,0.3);
      }
      .modal-body {
        padding: 24px;
      }
      .scorecard-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }
      .scorecard-info-item {
        background: #f8fafc;
        padding: 12px 16px;
        border-radius: 8px;
      }
      .scorecard-info-item label {
        font-size: 12px;
        color: #64748b;
        display: block;
        margin-bottom: 4px;
      }
      .scorecard-info-item span {
        font-size: 16px;
        font-weight: 600;
        color: #1e293b;
      }
      .scorecard-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
      }
      .scorecard-table th, .scorecard-table td {
        padding: 8px 6px;
        text-align: center;
        border: 1px solid #e2e8f0;
      }
      .scorecard-table thead th {
        background: #f1f5f9;
        font-weight: 600;
        color: #475569;
      }
      .scorecard-table .hole-row th {
        background: #1e3a8a;
        color: white;
      }
      .scorecard-table .par-row td {
        background: #f8fafc;
        font-weight: 500;
      }
      .scorecard-table .score-row td {
        font-weight: 600;
      }
      .scorecard-table .total-cell {
        background: #f1f5f9;
        font-weight: 700;
      }
      /* Standard golf scorecard colors */
      .score-eagle { background: #fbbf24; color: #78350f; }
      .score-birdie { background: #fecaca; color: #b91c1c; }
      .score-bogey { background: #bfdbfe; color: #1e40af; }
      .score-double { background: #1e293b; color: white; }
      .score-worse { background: #0f172a; color: white; }
      
      /* Mobile responsiveness */
      @media (max-width: 640px) {
        .container { padding: 12px; }
        .header { padding: 20px 16px; border-radius: 0; margin: -12px -12px 16px -12px; }
        .header h1 { font-size: 22px; }
        .results-table thead th, .results-table tbody td { padding: 10px 8px; font-size: 13px; }
        .modal-content { border-radius: 12px; max-height: 95vh; }
        .modal-header { padding: 16px; }
        .modal-body { padding: 16px; }
        .scorecard-table { font-size: 11px; }
        .scorecard-table th, .scorecard-table td { padding: 6px 3px; }
        .action-buttons { flex-wrap: wrap; }
      }
      
      @media print {
        .action-buttons, .btn, .modal-overlay { display: none !important; }
        .container { margin: 0; padding: 20px; }
        .warning-message { display: none; }
        .results-card { box-shadow: none; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 id="tournament-name">Tournament Results</h1>
        <div class="subtitle" id="category-name"></div>
      </div>

      <div id="warning-container"></div>

      <div class="results-card">
        <div class="results-card-header">
          <h2 id="results-title">Results</h2>
        </div>
        <div class="results-table-wrapper">
          <table class="results-table" id="results-table">
            <thead id="table-head"></thead>
            <tbody id="table-body"></tbody>
          </table>
        </div>
      </div>

      <div id="save-status" style="display: none; padding: 12px 20px; border-radius: 8px; margin-bottom: 16px; font-weight: 500; text-align: center;"></div>
      
      <div class="action-buttons">
        <button class="btn" id="save-btn" style="background: linear-gradient(180deg, #10b981, #059669);" onclick="manualSaveResults()">üíæ Save Results to Firebase</button>
        <button class="btn btn-print" onclick="window.print()">üñ®Ô∏è Print Results</button>
        <button class="btn btn-back" onclick="window.close()">‚úï Close</button>
      </div>
    </div>
    
    <!-- Scorecard Modal -->
    <div class="modal-overlay" id="scorecard-modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="modal-player-name">Player Scorecard</h3>
          <button class="modal-close" onclick="closeScorecardModal()">√ó</button>
        </div>
        <div class="modal-body" id="modal-body">
          <!-- Scorecard content -->
        </div>
      </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    <script>
      // Firebase config
      const firebaseConfig = {
        apiKey: "AIzaSyBppPEZ0dSEqMQlPDyvaZb5luol51_7qNM",
        authDomain: "gtm-management-6350e.firebaseapp.com",
        databaseURL: "https://gtm-management-6350e-default-rtdb.firebaseio.com",
        projectId: "gtm-management-6350e",
        storageBucket: "gtm-management-6350e.firebasestorage.app",
        messagingSenderId: "461806742170",
        appId: "1:461806742170:web:9a2af43d50c0a26718cd23"
      };
      
      // Initialize Firebase
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      const db = firebase.database();
      
      // Load data from Firebase to localStorage
      async function loadFromFirebase() {
        try {
          const [tournamentsSnap, scoresSnap, admittedSnap, coursesSnap] = await Promise.all([
            db.ref('tournaments').once('value'),
            db.ref('scores').once('value'),
            db.ref('admittedPlayers').once('value'),
            db.ref('courses').once('value')
          ]);
          
          if (tournamentsSnap.val()) {
            const data = tournamentsSnap.val();
            const arr = Array.isArray(data) ? data.filter(t => t) : Object.values(data).filter(t => t);
            localStorage.setItem('tournaments', JSON.stringify(arr));
          }
          if (scoresSnap.val()) {
            localStorage.setItem('scores', JSON.stringify(scoresSnap.val()));
          }
          if (admittedSnap.val()) {
            localStorage.setItem('admittedPlayers', JSON.stringify(admittedSnap.val()));
          }
          if (coursesSnap.val()) {
            const data = coursesSnap.val();
            const arr = Array.isArray(data) ? data.filter(c => c) : Object.values(data).filter(c => c);
            localStorage.setItem('courses', JSON.stringify(arr));
          }
          console.log('‚úì Data loaded from Firebase');
        } catch (e) {
          console.error('Firebase load error:', e);
        }
      }
    </script>
    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');
      const categoryCode = urlParams.get('categoryCode');
      const categoryName = urlParams.get('categoryName');
      const displayType = urlParams.get('display');
      const showHcp = urlParams.get('hcp') === 'yes';
      const showPhcp = urlParams.get('phcp') === 'yes';
      const showToPar = urlParams.get('topar') === 'yes';
      
      // Store current calculated results for manual save
      let currentCalculatedResults = null;

      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function getTournament() {
        const tournaments = getTournaments();
        return tournaments.find(t => t.tournamentId === tournamentId);
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          const tournament = getTournament();
          if (!tournament || !tournament.meta || !tournament.meta.roundIds) return [];
          
          // Get players from all rounds
          const allPlayers = [];
          tournament.meta.roundIds.forEach(roundId => {
            if (data[roundId]) {
              data[roundId].forEach(player => {
                if (!allPlayers.find(p => p.reg === player.reg)) {
                  allPlayers.push(player);
                }
              });
            }
          });
          
          return allPlayers;
        } catch (err) {
          console.error('Error loading admitted players:', err);
          return [];
        }
      }

      function getScores() {
        try {
          const raw = localStorage.getItem('scores');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Error loading scores:', err);
          return {};
        }
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Error loading courses:', err);
          return [];
        }
      }

      function getTeams() {
        try {
          const tournament = getTournament();
          if (!tournament) return [];
          
          // Teams are stored in tournament.teamsByRound
          // Get teams from round 0 (or first available round)
          const teamsByRound = tournament.teamsByRound || {};
          const roundKeys = Object.keys(teamsByRound);
          
          if (roundKeys.length > 0) {
            // Return teams from the first round (usually round 0)
            const firstRoundTeams = teamsByRound[roundKeys[0]] || [];
            console.log('Teams loaded from teamsByRound:', firstRoundTeams);
            return firstRoundTeams;
          }
          
          // Fallback to legacy teams array
          if (tournament.teams && tournament.teams.length > 0) {
            console.log('Teams loaded from legacy teams array:', tournament.teams);
            return tournament.teams;
          }
          
          console.log('No teams found in tournament');
          return [];
        } catch (err) {
          console.error('Error loading teams:', err);
          return [];
        }
      }

      // Save calculated results to tournament data (localStorage and Firebase)
      async function saveCalculatedResults(categoryCode, resultsData) {
        try {
          const tournaments = getTournaments();
          const index = tournaments.findIndex(t => t.tournamentId === tournamentId);
          
          if (index !== -1) {
            // Initialize calculatedResults if not exists
            if (!tournaments[index].calculatedResults) {
              tournaments[index].calculatedResults = {};
            }
            
            // Save the results for this category
            tournaments[index].calculatedResults[categoryCode] = {
              results: resultsData,
              calculatedAt: new Date().toISOString()
            };
            
            // Save to localStorage FIRST
            localStorage.setItem('tournaments', JSON.stringify(tournaments));
            console.log(`Results saved to localStorage for category ${categoryCode}:`, resultsData.length, 'entries');
            
            // Verify it was saved correctly
            const verify = JSON.parse(localStorage.getItem('tournaments'));
            const verifyTournament = verify.find(t => t.tournamentId === tournamentId);
            if (verifyTournament?.calculatedResults?.[categoryCode]) {
              console.log('‚úì Verified: calculatedResults saved in localStorage');
            } else {
              console.error('‚úó ERROR: calculatedResults NOT found in localStorage after save!');
            }
            
            // Save directly to Firebase
            try {
              // Find the Firebase key for this tournament
              const tournamentsSnap = await db.ref('tournaments').once('value');
              const tournamentsData = tournamentsSnap.val();
              
              if (tournamentsData) {
                // Find the key for our tournament
                let firebaseKey = null;
                for (const key in tournamentsData) {
                  if (tournamentsData[key] && tournamentsData[key].tournamentId === tournamentId) {
                    firebaseKey = key;
                    break;
                  }
                }
                
                if (firebaseKey) {
                  // Save calculatedResults for this category
                  await db.ref(`tournaments/${firebaseKey}/calculatedResults/${categoryCode}`).set({
                    results: resultsData,
                    calculatedAt: new Date().toISOString()
                  });
                  console.log(`‚úì Results synced to Firebase for category ${categoryCode}`);
                } else {
                  console.error('‚úó Could not find tournament key in Firebase');
                }
              }
            } catch (firebaseError) {
              console.error('‚úó Firebase sync failed:', firebaseError);
              throw firebaseError;
            }
          } else {
            console.error('Tournament not found in array, cannot save results');
            throw new Error('Tournament not found');
          }
        } catch (err) {
          console.error('Error saving calculated results:', err);
          throw err;
        }
      }

      // Manual save button handler
      async function manualSaveResults() {
        const saveBtn = document.getElementById('save-btn');
        const statusDiv = document.getElementById('save-status');
        
        if (!currentCalculatedResults || currentCalculatedResults.length === 0) {
          statusDiv.style.display = 'block';
          statusDiv.style.background = '#fef2f2';
          statusDiv.style.color = '#dc2626';
          statusDiv.innerHTML = '‚ùå No results to save. Please refresh the page.';
          setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
          return;
        }
        
        // Show loading state
        saveBtn.disabled = true;
        saveBtn.innerHTML = '‚è≥ Saving...';
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#fef3cd';
        statusDiv.style.color = '#856404';
        statusDiv.innerHTML = '‚è≥ Saving results to Firebase...';
        
        try {
          await saveCalculatedResults(categoryCode, currentCalculatedResults);
          
          // Success
          statusDiv.style.background = '#d4edda';
          statusDiv.style.color = '#155724';
          statusDiv.innerHTML = `‚úÖ Results saved to Firebase for category "${categoryCode}"!`;
          saveBtn.innerHTML = '‚úÖ Saved!';
          saveBtn.style.background = 'linear-gradient(180deg, #10b981, #059669)';
          
          setTimeout(() => {
            saveBtn.innerHTML = 'üíæ Save Results to Firebase';
            saveBtn.disabled = false;
            statusDiv.style.display = 'none';
          }, 3000);
        } catch (err) {
          // Error
          statusDiv.style.background = '#f8d7da';
          statusDiv.style.color = '#721c24';
          statusDiv.innerHTML = `‚ùå Failed to save: ${err.message}`;
          saveBtn.innerHTML = '‚ùå Save Failed';
          saveBtn.disabled = false;
          
          setTimeout(() => {
            saveBtn.innerHTML = 'üíæ Save Results to Firebase';
            statusDiv.style.display = 'none';
          }, 5000);
        }
      }

      function isTeamCategory() {
        const tournament = getTournament();
        // Check if tournament is a team tournament and category is "TEAM"
        return tournament?.meta?.teamsTournament === 'yes' && categoryCode === 'TEAM';
      }

      function getTeeData(player, roundIndex) {
        const tournament = getTournament();
        if (!tournament) return null;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        if (!roundData) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeValue = '';
        
        // Check if player has an assigned tee (from categories)
        if (player.tee) {
          const courses = getCourses();
          const courseId = roundData.course;
          const course = courses.find(c => c.courseId === courseId);
          
          if (course && course.teeIds) {
            const idx = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              teeValue = `${courseId}||${idx}`;
            }
          }
        }
        
        // If no assigned tee, use default from tournament settings
        if (!teeValue) {
          if (playerGender === 'male' || playerGender === 'm') {
            teeValue = roundData.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            teeValue = roundData.teeWomen || '';
          }
        }
        
        if (!teeValue || !teeValue.includes('||')) return null;
        
        const [courseId, teeIndexStr] = teeValue.split('||');
        const teeIndex = parseInt(teeIndexStr, 10);
        
        const courses = getCourses();
        const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
        
        if (!course) return null;
        
        // Calculate total par from pars array (sum of all 18 holes)
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        // Get tee-specific data from teeData array
        const teeData = course.teeData?.[teeIndex];
        if (!teeData) return null;
        
        let slope, rating;
        
        // Check if this tee is for both genders (has nested ratings structure)
        const teeGender = course.genders?.[teeIndex];
        if (teeGender === 'B' && teeData.ratings) {
          // Both genders - use appropriate gender's ratings
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else if (playerGender === 'female' || playerGender === 'f') {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          // Single gender tee
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        return { slope, rating, par, course };
      }

      function calculatePlayingHcp(player, roundIndex = 0) {
        const playerHcp = parseFloat(player.hcp);
        if (isNaN(playerHcp)) {
          return null;
        }
        
        const teeData = getTeeData(player, roundIndex);
        if (!teeData || !teeData.slope || !teeData.rating || !teeData.par) {
          return Math.round(playerHcp); // Fallback to rounded WHS HCP if data missing
        }
        
        const tournament = getTournament();
        const slope = parseFloat(teeData.slope);
        const rating = parseFloat(teeData.rating);
        const par = parseFloat(teeData.par);
        const hcpAllowance = parseFloat(tournament?.meta?.hcpAllow || 100) / 100;
        
        if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
          return Math.round(playerHcp);
        }
        
        // Formula: (HCP √ó (Slope/113) + (Rating - Par)) √ó HCP_Allowance
        const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
        
        // Round to nearest whole number (.5 rounds up)
        return Math.round(playingHcp);
      }

      function getPlayerPhcp(player) {
        // Use stored PHCP or calculate it as fallback
        if (player.phcp !== undefined && player.phcp !== null && player.phcp !== '') {
          return player.phcp;
        }
        // Calculate PHCP if not stored
        const calculatedPhcp = calculatePlayingHcp(player, 0);
        if (calculatedPhcp !== null) {
          player.phcp = calculatedPhcp; // Cache it
          return calculatedPhcp;
        }
        return null;
      }

      function getCategoryPlayers() {
        const allPlayers = getAdmittedPlayers();
        const tournament = getTournament();
        const isTeamTournament = tournament?.meta?.teamsTournament === 'yes';
        const isTeamCategory = categoryCode === 'TEAM';
        
        // Debug: Log tournament categoryAssignments
        console.log('Tournament categoryAssignments:', tournament?.categoryAssignments);
        console.log('Looking for category:', categoryCode);
        
        // PRIORITY 1: Use stored categoryAssignments (single source of truth)
        let storedPlayerIds = tournament?.categoryAssignments?.[categoryCode];
        
        // Firebase may return arrays as objects with numeric keys - convert back to array
        if (storedPlayerIds && !Array.isArray(storedPlayerIds)) {
          console.log('Converting Firebase object to array:', storedPlayerIds);
          storedPlayerIds = Object.values(storedPlayerIds);
        }
        
        console.log('Stored player IDs for this category:', storedPlayerIds);
        
        if (storedPlayerIds && storedPlayerIds.length > 0) {
          console.log(`Category ${categoryCode}: Using stored assignments (${storedPlayerIds.length} player IDs)`);
          return allPlayers.filter(player => {
            const playerId = player.reg || player.id;
            // In team tournaments, all players belong to TEAM category
            if (isTeamTournament && isTeamCategory) {
              return true;
            }
            return storedPlayerIds.includes(playerId);
          });
        }
        
        // FALLBACK: Check player-level categories (for backward compatibility)
        console.log(`Category ${categoryCode}: Falling back to player-level categories (no stored assignments found)`);
        console.log('All players count:', allPlayers.length);
        
        const filteredPlayers = allPlayers.filter(player => {
          // In team tournaments, all players belong to TEAM category
          if (isTeamTournament && isTeamCategory) {
            return true;
          }
          if (player.categories && Array.isArray(player.categories)) {
            return player.categories.includes(categoryCode);
          }
          return player.category === categoryCode;
        });
        
        console.log('Filtered players (fallback):', filteredPlayers.length);
        return filteredPlayers;
      }

      function calculateNetScore(grossScore, hcp) {
        if (typeof grossScore !== 'number' || isNaN(grossScore)) return null;
        if (typeof hcp !== 'number' || isNaN(hcp)) return grossScore;
        return grossScore - hcp;
      }

      function calculateStablefordTotal(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        if (!playerScores || !playerScores.stablefordPoints) return null;
        
        // Check if array is empty or all values are empty/null
        const hasAnyScore = playerScores.stablefordPoints.some(p => p !== null && p !== undefined && p !== '');
        if (!hasAnyScore) return null;
        
        return playerScores.stablefordPoints.reduce((sum, points) => {
          const p = parseInt(points);
          return sum + (isNaN(p) ? 0 : p);
        }, 0);
      }

      function calculateGrossTotal(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        if (!playerScores || !playerScores.holes) return null;
        
        // Check if array is empty or all values are empty/null
        const hasAnyScore = playerScores.holes.some(h => h !== null && h !== undefined && h !== '');
        if (!hasAnyScore) return null;
        
        return playerScores.holes.reduce((sum, strokes) => {
          const s = parseInt(strokes);
          return sum + (isNaN(s) ? 0 : s);
        }, 0);
      }

      function getPlayerRoundScore(player, roundId, tournamentType) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        
        // If no score record exists at all, return null
        if (!playerScores) return null;
        
        // Check for status first
        if (playerScores.status && playerScores.status !== 'OK') {
          return playerScores.status; // DQ, NS, NR
        }
        
        // If status is explicitly 'OK' or undefined, check for actual scores
        const typeUpper = (tournamentType || '').toUpperCase();
        let result = null;
        
        if (typeUpper.includes('STABLEFORD')) {
          result = calculateStablefordTotal(player, roundId);
        } else if (typeUpper.includes('MEDAL NET')) {
          const gross = calculateGrossTotal(player, roundId);
          if (gross === null) {
            result = null;
          } else {
            const phcp = getPlayerPhcp(player) || 0;
            result = calculateNetScore(gross, phcp);
          }
        } else {
          // Stroke Play (gross)
          result = calculateGrossTotal(player, roundId);
        }
        
        // If we have a score record but no actual scores, treat as incomplete
        // This catches the case where scorecard was opened but not filled
        if (result === null && playerScores && !playerScores.status) {
          // Scorecard exists but is empty and has no status - this is incomplete
          return null;
        }
        
        return result;
      }

      // Check if a player has any incomplete holes (0/X scores) in any round
      function playerHasIncompleteHoles(player, roundIds) {
        const scores = getScores();
        
        for (const roundId of roundIds) {
          const playerScores = scores[roundId]?.[player.reg];
          if (!playerScores) continue;
          
          // Check incompleteHoles array
          if (playerScores.incompleteHoles && playerScores.incompleteHoles.length > 0) {
            return true;
          }
          
          // Check isIncompleteHole object
          if (playerScores.isIncompleteHole) {
            const hasIncomplete = Object.values(playerScores.isIncompleteHole).some(v => v === true);
            if (hasIncomplete) return true;
          }
        }
        
        return false;
      }

      function isPlayerRoundComplete(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        
        // No score record at all - incomplete
        if (!playerScores) return false;
        
        // Has a status (DQ, NS, NR) - considered complete
        if (playerScores.status && playerScores.status !== 'OK') return true;
        
        // Check if all 18 holes have scores
        if (playerScores.holes && Array.isArray(playerScores.holes)) {
          const completedHoles = playerScores.holes.filter(s => s !== '' && s !== null && s !== undefined).length;
          return completedHoles === 18;
        }
        
        // No holes array or empty - incomplete
        return false;
      }

      function checkIncompleteScores(players, roundIds, tournamentType) {
        const incomplete = [];
        const tournament = getTournament();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        console.log('=== Checking Incomplete Scores ===');
        console.log('Total players in category:', players.length);
        console.log('All round IDs:', roundIds);
        console.log('Today:', today.toISOString().split('T')[0]);
        
        // Determine which rounds should be completed based on today's date
        const roundsToCheck = [];
        
        if (tournament?.meta?.roundsData) {
          roundIds.forEach((roundId, index) => {
            const roundData = tournament.meta.roundsData[index];
            console.log(`Round ${index + 1} (${roundId}):`, roundData?.date);
            
            if (roundData && roundData.date) {
              const roundDate = new Date(roundData.date);
              roundDate.setHours(0, 0, 0, 0);
              
              console.log(`  Round date: ${roundDate.toISOString().split('T')[0]}, Should check: ${roundDate <= today}`);
              
              // Only check rounds that have already happened (date <= today)
              if (roundDate <= today) {
                roundsToCheck.push(roundId);
              }
            } else {
              // If no date info, check all rounds (backward compatibility)
              console.log('  No date info, checking this round');
              roundsToCheck.push(roundId);
            }
          });
        } else {
          // No date information, check all rounds
          console.log('No round data found, checking all rounds');
          roundsToCheck.push(...roundIds);
        }
        
        console.log('Rounds to check:', roundsToCheck);
        
        // Check only the rounds that should be completed
        players.forEach(player => {
          roundsToCheck.forEach(roundId => {
            const isComplete = isPlayerRoundComplete(player, roundId);
            console.log(`${player.firstName} ${player.lastName} - ${roundId}: ${isComplete ? 'COMPLETE' : 'INCOMPLETE'}`);
            
            if (!isComplete) {
              const roundIndex = roundIds.indexOf(roundId);
              incomplete.push(`${player.firstName} ${player.lastName} - Round ${roundIndex + 1}`);
            }
          });
        });
        
        console.log('Total incomplete scorecards:', incomplete.length);
        console.log('Incomplete list:', incomplete);
        
        return incomplete;
      }

      function getCourseParForRound(roundId) {
        const tournament = getTournament();
        if (!tournament?.meta?.roundIds) return 72;
        
        const roundIndex = tournament.meta.roundIds.indexOf(roundId);
        
        // Get course identifier - first from roundData, then from tournament
        let courseIdentifier = null;
        
        if (roundIndex !== -1) {
          const roundData = tournament.meta.roundsData?.[roundIndex];
          if (roundData && roundData.course) {
            courseIdentifier = roundData.course;
          }
        }
        
        // Fallback to tournament course
        if (!courseIdentifier && tournament.course) {
          courseIdentifier = tournament.course;
        }
        
        if (!courseIdentifier) return 72;
        
        // Get course data
        try {
          const raw = localStorage.getItem('courses');
          const courses = raw ? JSON.parse(raw) : [];
          
          // Try to find by courseId first, then by courseName
          let course = courses.find(c => c.courseId === courseIdentifier);
          if (!course) {
            course = courses.find(c => c.courseName === courseIdentifier);
          }
          
          if (course && course.pars) {
            return course.pars.reduce((sum, p) => sum + (parseInt(p) || 0), 0);
          }
        } catch (err) {
          console.error('Error loading course data:', err);
        }
        
        return 72;
      }

      // ==================== TIEBREAKER FUNCTIONS ====================
      
      // Get the untie criteria from tournament settings
      function getUntieCriteria() {
        const tournament = getTournament();
        return tournament?.untieCriteria || [];
      }

      // Get course data for a round (stroke indexes, pars)
      function getCourseDataForRound(roundId) {
        const tournament = getTournament();
        if (!tournament?.meta?.roundIds) return null;
        
        const roundIndex = tournament.meta.roundIds.indexOf(roundId);
        if (roundIndex === -1) return null;
        
        const roundData = tournament.meta.roundsData?.[roundIndex];
        if (!roundData) return null;
        
        try {
          const raw = localStorage.getItem('courses');
          const courses = raw ? JSON.parse(raw) : [];
          return courses.find(c => c.courseId === roundData.course);
        } catch (err) {
          console.error('Error loading course data:', err);
          return null;
        }
      }

      // Get player's hole scores for a specific round
      function getPlayerHoleScores(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        return playerScores?.holes || [];
      }

      // Get player's stableford points for a specific round
      function getPlayerStablefordPoints(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        return playerScores?.stablefordPoints || [];
      }

      // Tiebreaker: Last Round Score
      function tiebreakLastRound(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        let scoreA, scoreB;
        if (isStableford) {
          scoreA = calculateStablefordTotal(playerA, lastRoundId) || 0;
          scoreB = calculateStablefordTotal(playerB, lastRoundId) || 0;
          return scoreB - scoreA; // Higher is better for Stableford
        } else {
          scoreA = calculateGrossTotal(playerA, lastRoundId) || 999;
          scoreB = calculateGrossTotal(playerB, lastRoundId) || 999;
          return scoreA - scoreB; // Lower is better for Stroke Play
        }
      }

      // Tiebreaker: Back 9 (holes 10-18 of last round)
      function tiebreakBack9(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(9, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(9, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(9, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(9, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last 6 Holes (holes 13-18 of last round)
      function tiebreakLast6(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(12, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(12, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(12, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(12, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last 3 Holes (holes 16-18 of last round)
      function tiebreakLast3(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(15, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(15, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(15, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(15, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last Hole (hole 18 of last round)
      function tiebreakLastHole(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const scoreA = parseInt(pointsA[17]) || 0;
          const scoreB = parseInt(pointsB[17]) || 0;
          return scoreB - scoreA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const scoreA = parseInt(holesA[17]) || 0;
          const scoreB = parseInt(holesB[17]) || 0;
          return scoreA - scoreB; // Lower is better
        }
      }

      // Tiebreaker: Lower Handicap
      function tiebreakLowerHcp(playerA, playerB) {
        const hcpA = parseFloat(playerA.hcp) || 999;
        const hcpB = parseFloat(playerB.hcp) || 999;
        return hcpA - hcpB; // Lower HCP wins
      }

      // Tiebreaker: Score on holes by Stroke Index (starting from SI 1)
      function tiebreakStrokeIndex(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        const courseData = getCourseDataForRound(lastRoundId);
        if (!courseData || !courseData.strokeIndexes) return 0;
        
        const strokeIndexes = courseData.strokeIndexes;
        
        // Create array of hole indices sorted by stroke index (SI 1 first)
        const holesBySI = strokeIndexes
          .map((si, holeIndex) => ({ si: parseInt(si) || 99, holeIndex }))
          .sort((a, b) => a.si - b.si);
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          
          for (const { holeIndex } of holesBySI) {
            const scoreA = parseInt(pointsA[holeIndex]) || 0;
            const scoreB = parseInt(pointsB[holeIndex]) || 0;
            if (scoreA !== scoreB) {
              return scoreB - scoreA; // Higher is better for Stableford
            }
          }
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          
          for (const { holeIndex } of holesBySI) {
            const scoreA = parseInt(holesA[holeIndex]) || 0;
            const scoreB = parseInt(holesB[holeIndex]) || 0;
            if (scoreA !== scoreB) {
              return scoreA - scoreB; // Lower is better for Stroke Play
            }
          }
        }
        
        return 0; // Still tied
      }

      // Tiebreaker: More Eagles, Birdies, Pars (countback)
      function tiebreakEaglesBirdiesPars(playerA, playerB, roundIds) {
        const courseData = roundIds.length > 0 ? getCourseDataForRound(roundIds[roundIds.length - 1]) : null;
        if (!courseData || !courseData.pars) return 0;
        
        const pars = courseData.pars;
        
        // Count eagles, birdies, pars for each player across all rounds
        let countA = { eagles: 0, birdies: 0, pars: 0 };
        let countB = { eagles: 0, birdies: 0, pars: 0 };
        
        roundIds.forEach(roundId => {
          const holesA = getPlayerHoleScores(playerA, roundId);
          const holesB = getPlayerHoleScores(playerB, roundId);
          
          holesA.forEach((score, i) => {
            const s = parseInt(score);
            const par = parseInt(pars[i]) || 4;
            if (!isNaN(s)) {
              const diff = s - par;
              if (diff <= -2) countA.eagles++;
              else if (diff === -1) countA.birdies++;
              else if (diff === 0) countA.pars++;
            }
          });
          
          holesB.forEach((score, i) => {
            const s = parseInt(score);
            const par = parseInt(pars[i]) || 4;
            if (!isNaN(s)) {
              const diff = s - par;
              if (diff <= -2) countB.eagles++;
              else if (diff === -1) countB.birdies++;
              else if (diff === 0) countB.pars++;
            }
          });
        });
        
        // Compare eagles first, then birdies, then pars
        if (countA.eagles !== countB.eagles) return countB.eagles - countA.eagles;
        if (countA.birdies !== countB.birdies) return countB.birdies - countA.birdies;
        if (countA.pars !== countB.pars) return countB.pars - countA.pars;
        
        return 0; // Still tied
      }

      // Tiebreaker: Play Off - checks if a play-off result was recorded
      // Play-off results are stored in tournament.playOffResults[categoryCode] = [{ playerReg, position, tiedScore }]
      // 
      // Important: Supports PARTIAL play-off results. If only the winner is set and others are "Not Set",
      // the winner gets priority, and the remaining players continue to the next tiebreaker criteria.
      // 
      // Example scenario:
      // - 3 players tied for 1st (all scored 70)
      // - Play-off: Player 1 scores 4, Players 2 & 3 score 5
      // - User marks Player 1 as "1st (Winner)", leaves 2 & 3 as "Not Set"
      // - Result: Player 1 ranks 1st, Players 2 & 3 use other criteria
      function tiebreakPlayOff(playerA, playerB) {
        const tournament = getTournament();
        if (!tournament.playOffResults || !tournament.playOffResults[categoryCode]) {
          return 0; // No play-off recorded
        }
        
        const playOffResults = tournament.playOffResults[categoryCode];
        
        // Find positions for both players
        const resultA = playOffResults.find(r => r.playerReg === playerA.reg);
        const resultB = playOffResults.find(r => r.playerReg === playerB.reg);
        
        // Case 1: Neither player has a play-off result - continue to other criteria
        if (!resultA && !resultB) {
          return 0;
        }
        
        // Case 2: Both have play-off results in the same tie group
        if (resultA && resultB && resultA.tiedScore === resultB.tiedScore) {
          // Compare positions (lower position = better, 1st beats 2nd)
          return resultA.position - resultB.position;
        }
        
        // Case 3: Only player A has a play-off result
        // Player A was explicitly marked in play-off, which means they resolved their tie
        // Player B might be in the same tie group but wasn't marked (left as "Not Set")
        if (resultA && !resultB) {
          // A has a play-off position, A ranks better
          return -1;
        }
        
        // Case 4: Only player B has a play-off result  
        if (!resultA && resultB) {
          // B has a play-off position, B ranks better
          return 1;
        }
        
        // Case 5: Both have results but in different tie groups
        // This shouldn't happen in practice, but handle it gracefully
        return 0;
      }

      // Main tiebreaker comparison function
      function compareTiebreakers(prA, prB, roundIds, isStableford) {
        // First, always check for play-off results (fixed at position 2)
        const playOffResult = tiebreakPlayOff(prA.player, prB.player);
        if (playOffResult !== 0) {
          console.log(`Tiebreak resolved by Play Off: ${prA.player.firstName} ${prA.player.lastName} vs ${prB.player.firstName} ${prB.player.lastName} = ${playOffResult}`);
          return playOffResult;
        }
        
        const criteria = getUntieCriteria();
        
        // If no additional tiebreaker criteria defined, return 0 (keep tie)
        if (!criteria || criteria.length === 0) return 0;
        
        for (const criteriaId of criteria) {
          let result = 0;
          
          switch (criteriaId) {
            case 'last_round':
              result = tiebreakLastRound(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'back_9':
              result = tiebreakBack9(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_6':
              result = tiebreakLast6(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_3':
              result = tiebreakLast3(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_hole':
              result = tiebreakLastHole(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'lower_hcp':
              result = tiebreakLowerHcp(prA.player, prB.player);
              break;
            case 'stroke_index':
              result = tiebreakStrokeIndex(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'eagles_birdies_pars':
              result = tiebreakEaglesBirdiesPars(prA.player, prB.player, roundIds);
              break;
          }
          
          if (result !== 0) {
            console.log(`Tiebreak resolved by ${criteriaId}: ${prA.player.firstName} ${prA.player.lastName} vs ${prB.player.firstName} ${prB.player.lastName} = ${result}`);
            return result;
          }
        }
        
        return 0; // All tiebreakers exhausted, still tied
      }

      // ==================== END TIEBREAKER FUNCTIONS ====================

      // ==================== TEAM RESULTS FUNCTIONS ====================

      async function generateTeamResults() {
        const tournament = getTournament();
        if (!tournament) {
          alert('Tournament not found');
          return;
        }

        document.getElementById('tournament-name').textContent = tournament.name;
        document.getElementById('category-name').textContent = 'Team Results';

        const teams = getTeams();
        const allPlayers = getAdmittedPlayers();
        const roundIds = tournament.meta?.roundIds || [];
        const teamScoresCount = parseInt(tournament.meta?.teamScoresCount) || 3; // Best N scores count
        const teamMaxPlayers = parseInt(tournament.meta?.teamMaxPlayers) || 4;

        console.log('=== TEAM RESULTS DEBUG ===');
        console.log('Teams loaded:', teams.length, teams);
        console.log('All admitted players:', allPlayers.length);
        console.log('Round IDs:', roundIds);
        console.log('Team scores count:', teamScoresCount);
        console.log('Team max players:', teamMaxPlayers);

        // Filter teams that have players
        const teamsWithPlayers = teams.filter(t => t.players && t.players.length > 0);
        console.log('Teams with players:', teamsWithPlayers.length);

        // Show team scoring info
        const warningDiv = document.getElementById('warning-container');
        warningDiv.innerHTML = `<div class="info-message">üèÜ Team Scoring: Best ${teamScoresCount} out of ${teamMaxPlayers} player scores per team</div>`;

        // Add class to table for team-specific styling
        document.getElementById('results-table').classList.add('team-results-table');

        // Build colgroup for fixed column widths
        let colgroupHTML = '<colgroup>';
        colgroupHTML += '<col class="col-rank">';
        colgroupHTML += '<col class="col-name">';
        if (showHcp) colgroupHTML += '<col class="col-hcp">';
        if (showPhcp) colgroupHTML += '<col class="col-phcp">';
        if (showToPar) colgroupHTML += '<col class="col-topar">';
        if (roundIds.length > 1) {
          roundIds.forEach(() => {
            colgroupHTML += '<col class="col-round">';
          });
        }
        colgroupHTML += '<col class="col-score">';
        colgroupHTML += '</colgroup>';

        // Build table header
        let headerHTML = '<tr>';
        headerHTML += '<th class="text-center">Rank</th>';
        headerHTML += '<th>Team / Player</th>';
        if (showHcp) headerHTML += '<th class="text-center">HCP</th>';
        if (showPhcp) headerHTML += '<th class="text-center">PHCP</th>';
        if (showToPar) headerHTML += '<th class="text-center">To Par</th>';
        
        // Add round columns if multiple rounds
        if (roundIds.length > 1) {
          roundIds.forEach((_, index) => {
            headerHTML += `<th class="text-center">R${index + 1}</th>`;
          });
        }
        
        headerHTML += '<th class="text-center">Scores</th>';
        headerHTML += '</tr>';
        
        // Insert colgroup before thead
        const table = document.getElementById('results-table');
        const existingColgroup = table.querySelector('colgroup');
        if (existingColgroup) existingColgroup.remove();
        table.insertAdjacentHTML('afterbegin', colgroupHTML);
        
        document.getElementById('table-head').innerHTML = headerHTML;

        // Calculate team scores
        const teamResults = teams.map(team => {
          // Get player data for this team
          const teamPlayers = (team.players || []).map(playerId => {
            return allPlayers.find(p => (p.reg === playerId || p.playerId === playerId));
          }).filter(p => p); // Remove undefined

          // Calculate scores for each player across all rounds
          const playerScoresData = teamPlayers.map(player => {
            let totalStableford = 0;
            let hasAnyScore = false;
            const roundScores = [];

            roundIds.forEach(roundId => {
              const stablefordScore = calculateStablefordTotal(player, roundId);
              if (stablefordScore !== null && typeof stablefordScore === 'number') {
                totalStableford += stablefordScore;
                hasAnyScore = true;
                roundScores.push(stablefordScore);
              } else {
                // Check for status
                const scores = getScores();
                const playerScores = scores[roundId]?.[player.reg];
                if (playerScores?.status && playerScores.status !== 'OK') {
                  roundScores.push(playerScores.status);
                } else {
                  roundScores.push(null);
                }
              }
            });

            // Get player HCP and PHCP
            const hcp = player.hcp;
            const phcp = getPlayerPhcp(player);

            return {
              player,
              totalStableford: hasAnyScore ? totalStableford : null,
              roundScores,
              hasScore: hasAnyScore,
              hcp,
              phcp
            };
          });

          // Sort players by total stableford (highest first) for determining best N
          const sortedPlayers = [...playerScoresData].sort((a, b) => (b.totalStableford || 0) - (a.totalStableford || 0));
          
          // Mark which players count toward team score (best N)
          const countingPlayerRegs = new Set();
          let countUsed = 0;
          sortedPlayers.forEach(ps => {
            if (ps.hasScore && countUsed < teamScoresCount) {
              countingPlayerRegs.add(ps.player.reg);
              countUsed++;
            }
          });

          // Calculate team total from best N
          let teamTotal = 0;
          sortedPlayers.forEach(ps => {
            if (countingPlayerRegs.has(ps.player.reg)) {
              teamTotal += ps.totalStableford || 0;
            }
          });

          // Calculate average HCP for team
          const hcpValues = playerScoresData.map(ps => parseFloat(ps.hcp)).filter(h => !isNaN(h));
          const avgHcp = hcpValues.length > 0 ? (hcpValues.reduce((a, b) => a + b, 0) / hcpValues.length).toFixed(1) : null;

          // Calculate round totals for display (sum of best N players per round)
          const roundTotals = roundIds.map((roundId, roundIndex) => {
            const roundPlayerScores = playerScoresData
              .map(ps => ({
                reg: ps.player.reg,
                score: typeof ps.roundScores[roundIndex] === 'number' ? ps.roundScores[roundIndex] : null
              }))
              .filter(s => s.score !== null)
              .sort((a, b) => b.score - a.score);

            // Sum best N for this round
            return roundPlayerScores.slice(0, teamScoresCount).reduce((sum, s) => sum + s.score, 0);
          });

          return {
            team,
            teamTotal,
            avgHcp,
            roundTotals,
            playerScoresData,
            countingPlayerRegs,
            hasValidScore: countingPlayerRegs.size > 0
          };
        });

        // Get team untie criteria - always include play_off as fixed position 1 (after total score which is implicit)
        const savedTeamUntieCriteria = tournament.teamUntieCriteria || [];
        // Ensure team_play_off is always first in the criteria (it's the fixed #2 after total score)
        const teamUntieCriteria = ['team_play_off', ...savedTeamUntieCriteria.filter(c => c !== 'team_play_off' && c !== 'play_off')];
        const hasTeamTiebreakers = true; // Always has at least play_off

        // Helper function to get uncounted scores by round for a team (final round first)
        function getUncountedScoresByRound(teamResult) {
          const uncountedByRound = [];
          const numRounds = roundIds.length;
          
          // Process rounds from last (final) to first
          for (let roundIdx = numRounds - 1; roundIdx >= 0; roundIdx--) {
            // Get scores for this round from non-counting players
            const uncountedScores = teamResult.playerScoresData
              .filter(ps => !teamResult.countingPlayerRegs.has(ps.player.reg)) // Non-counting players
              .map(ps => {
                const score = ps.roundScores[roundIdx];
                return typeof score === 'number' ? score : null;
              })
              .filter(score => score !== null)
              .sort((a, b) => b - a); // Highest first (better for Stableford)
            
            uncountedByRound.push(uncountedScores);
          }
          
          return uncountedByRound; // Array of arrays: [[finalRoundScores], [prevRoundScores], ...]
        }

        // Team tiebreaker comparison function
        function compareTeamTiebreakers(teamA, teamB) {
          for (const criteriaId of teamUntieCriteria) {
            let result = 0;
            
            // Get sorted player scores (highest first) for each team
            const scoresA = teamA.playerScoresData
              .filter(ps => ps.hasScore)
              .map(ps => ps.totalStableford)
              .sort((a, b) => b - a);
            const scoresB = teamB.playerScoresData
              .filter(ps => ps.hasScore)
              .map(ps => ps.totalStableford)
              .sort((a, b) => b - a);
            
            switch (criteriaId) {
              case 'team_best_uncounted':
                // Compare non-counting scores starting from best uncounted of final round
                // Then 2nd uncounted of final round, etc. When exhausted, move to previous round
                const uncountedA = getUncountedScoresByRound(teamA);
                const uncountedB = getUncountedScoresByRound(teamB);
                
                // Iterate through rounds (already ordered from final to first)
                for (let roundIdx = 0; roundIdx < uncountedA.length || roundIdx < uncountedB.length; roundIdx++) {
                  const roundScoresA = uncountedA[roundIdx] || [];
                  const roundScoresB = uncountedB[roundIdx] || [];
                  
                  // Compare scores within this round (best to worst)
                  const maxScores = Math.max(roundScoresA.length, roundScoresB.length);
                  for (let scoreIdx = 0; scoreIdx < maxScores; scoreIdx++) {
                    const scoreA = roundScoresA[scoreIdx];
                    const scoreB = roundScoresB[scoreIdx];
                    
                    // If one team has a score and the other doesn't, the one with score wins
                    if (scoreA !== undefined && scoreB === undefined) {
                      result = -1; // Team A has more uncounted scores, wins
                      break;
                    }
                    if (scoreB !== undefined && scoreA === undefined) {
                      result = 1; // Team B has more uncounted scores, wins
                      break;
                    }
                    
                    // Compare the scores (higher is better for Stableford)
                    if (scoreA !== undefined && scoreB !== undefined) {
                      const diff = scoreA - scoreB;
                      if (diff !== 0) {
                        result = -diff; // Negative if A > B (A wins), positive if B > A (B wins)
                        break;
                      }
                    }
                  }
                  
                  if (result !== 0) break; // Tiebreaker resolved
                }
                break;

              case 'team_best_player':
                // Compare best individual scores
                result = (scoresB[0] || 0) - (scoresA[0] || 0);
                if (result !== 0) result = -result; // Higher is better
                break;
                
              case 'team_2nd_best':
                // Compare 2nd best individual scores
                result = (scoresB[1] || 0) - (scoresA[1] || 0);
                if (result !== 0) result = -result;
                break;
                
              case 'team_3rd_best':
                // Compare 3rd best individual scores
                result = (scoresB[2] || 0) - (scoresA[2] || 0);
                if (result !== 0) result = -result;
                break;
                
              case 'team_4th_best':
                // Compare 4th best individual scores
                result = (scoresB[3] || 0) - (scoresA[3] || 0);
                if (result !== 0) result = -result;
                break;
                
              case 'team_lower_avg_hcp':
                // Lower average HCP wins
                const avgA = parseFloat(teamA.avgHcp) || 999;
                const avgB = parseFloat(teamB.avgHcp) || 999;
                result = avgA - avgB;
                break;
                
              case 'team_countback_best':
                // Compare counting scores one by one
                const countA = scoresA.slice(0, teamScoresCount);
                const countB = scoresB.slice(0, teamScoresCount);
                for (let i = 0; i < Math.max(countA.length, countB.length); i++) {
                  const diff = (countB[i] || 0) - (countA[i] || 0);
                  if (diff !== 0) {
                    result = -diff; // Higher is better
                    break;
                  }
                }
                break;
                
              case 'team_more_birdies':
                // Count total birdies across all team players
                // This would require hole-by-hole data - simplified version
                // Just use as secondary check based on total scores for now
                break;
                
              case 'play_off':
              case 'team_play_off':
                // Team play-off tiebreaker
                const playOffResults = tournament.playOffResults?.[categoryCode] || [];
                const playOffA = playOffResults.find(r => r.teamId === teamA.team.teamId);
                const playOffB = playOffResults.find(r => r.teamId === teamB.team.teamId);
                
                // Neither team has play-off result
                if (!playOffA && !playOffB) {
                  result = 0;
                  break;
                }
                
                // Both have play-off results in the same tie group
                if (playOffA && playOffB && playOffA.tiedScore === playOffB.tiedScore) {
                  result = playOffA.position - playOffB.position;
                  break;
                }
                
                // Only team A has play-off result
                if (playOffA && !playOffB) {
                  result = -1;
                  break;
                }
                
                // Only team B has play-off result
                if (!playOffA && playOffB) {
                  result = 1;
                  break;
                }
                break;
            }
            
            if (result !== 0) {
              console.log(`Team tiebreak resolved by ${criteriaId}: ${teamA.team.name} vs ${teamB.team.name} = ${result}`);
              return result;
            }
          }
          return 0; // Still tied
        }

        // Sort teams by total (higher is better for Stableford), then apply tiebreakers
        teamResults.sort((a, b) => {
          if (!a.hasValidScore && !b.hasValidScore) return 0;
          if (!a.hasValidScore) return 1;
          if (!b.hasValidScore) return -1;
          
          // Primary: team total
          const totalDiff = b.teamTotal - a.teamTotal;
          
          // If tied and tiebreakers are enabled, apply them
          if (totalDiff === 0 && hasTeamTiebreakers) {
            return compareTeamTiebreakers(a, b);
          }
          
          return totalDiff;
        });

        // Assign ranks - consider tiebreakers for unique ranks
        let currentRank = 1;
        let previousTotal = null;
        
        teamResults.forEach((tr, index) => {
          if (!tr.hasValidScore) {
            tr.rank = '-';
          } else if (index === 0) {
            tr.rank = 1;
            currentRank = 1;
            previousTotal = tr.teamTotal;
          } else {
            const prevTeam = teamResults[index - 1];
            
            if (tr.teamTotal === prevTeam.teamTotal) {
              // If tiebreakers resolved it, give next rank
              if (hasTeamTiebreakers && compareTeamTiebreakers(prevTeam, tr) !== 0) {
                currentRank = index + 1;
                tr.rank = currentRank;
              } else {
                // Still tied - same rank
                tr.rank = currentRank;
              }
            } else {
              currentRank = index + 1;
              tr.rank = currentRank;
            }
            previousTotal = tr.teamTotal;
          }
        });

        // Build table body - each team has a header row + player rows
        let bodyHTML = '';
        
        teamResults.forEach(tr => {
          // Team header row
          bodyHTML += '<tr class="team-row">';
          bodyHTML += `<td class="text-center" style="font-weight: 700;">${tr.rank}</td>`;
          bodyHTML += `<td style="font-weight: 700;">${tr.team.name}</td>`;
          if (showHcp) bodyHTML += `<td class="text-center" style="font-weight: 600;">AVG (${tr.avgHcp || '-'})</td>`;
          if (showPhcp) bodyHTML += `<td class="text-center"></td>`;
          if (showToPar) bodyHTML += `<td class="text-center"></td>`;
          
          // Round totals for team (if multiple rounds)
          if (roundIds.length > 1) {
            tr.roundTotals.forEach(roundTotal => {
              bodyHTML += `<td class="text-center" style="font-weight: 600;">${roundTotal || '-'}</td>`;
            });
          }
          
          bodyHTML += `<td class="text-center" style="font-weight: 700;">${tr.teamTotal || '-'}</td>`;
          bodyHTML += '</tr>';

          // Player rows (sorted by score descending)
          const sortedPlayers = [...tr.playerScoresData].sort((a, b) => (b.totalStableford || 0) - (a.totalStableford || 0));
          
          sortedPlayers.forEach(ps => {
            const isCounting = tr.countingPlayerRegs.has(ps.player.reg);
            const scoreColor = isCounting ? 'color: #16a34a; font-weight: 600;' : '';
            const playerName = `${ps.player.firstName} ${ps.player.lastName}`;
            
            bodyHTML += '<tr class="player-row">';
            bodyHTML += `<td></td>`; // Empty rank for player rows
            bodyHTML += `<td style="padding-left: 20px;">${playerName}</td>`;
            
            if (showHcp) {
              const hcpDisplay = ps.hcp !== null && ps.hcp !== undefined ? ps.hcp : '-';
              bodyHTML += `<td class="text-center">${hcpDisplay}</td>`;
            }
            
            if (showPhcp) {
              const phcpDisplay = ps.phcp !== null && ps.phcp !== undefined ? (ps.phcp < 0 ? '+' + Math.abs(ps.phcp) : ps.phcp) : '-';
              bodyHTML += `<td class="text-center">${phcpDisplay}</td>`;
            }
            
            if (showToPar) {
              // Calculate to par for this player
              const toPar = calculateToParForPlayer(ps.player, roundIds);
              const toParDisplay = toPar !== null ? (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar)) : '-';
              bodyHTML += `<td class="text-center">${toParDisplay}</td>`;
            }
            
            // Round scores (if multiple rounds)
            if (roundIds.length > 1) {
              ps.roundScores.forEach(score => {
                if (typeof score === 'string') {
                  bodyHTML += `<td class="text-center">${score}</td>`;
                } else if (score !== null) {
                  bodyHTML += `<td class="text-center" style="${scoreColor}">${score}</td>`;
                } else {
                  bodyHTML += `<td class="text-center">-</td>`;
                }
              });
            }
            
            // Total score
            const scoreDisplay = ps.hasScore ? ps.totalStableford : '-';
            bodyHTML += `<td class="text-center" style="${scoreColor}">${scoreDisplay}</td>`;
            
            bodyHTML += '</tr>';
          });
        });

        document.getElementById('table-body').innerHTML = bodyHTML;
        
        // Save calculated team results to Firebase
        console.log('Preparing to save team results for category:', categoryCode);
        // Note: Firebase doesn't accept undefined values, so we convert them to null
        const teamResultsToSave = teamResults.map(tr => ({
          type: 'team',
          teamId: tr.team.teamId || null,
          teamName: tr.team.name || '',
          rank: tr.rank !== undefined ? tr.rank : null,
          total: tr.teamTotal !== undefined ? tr.teamTotal : null,
          roundTotals: tr.roundTotals || [],
          avgHcp: tr.avgHcp !== undefined ? tr.avgHcp : null,
          players: (tr.playerScoresData || []).map(ps => ({
            reg: ps.player.reg || null,
            firstName: ps.player.firstName || '',
            lastName: ps.player.lastName || '',
            club: ps.player.club || ps.player.homeClub || null
          }))
        }));
        console.log('Team results to save:', teamResultsToSave.length, 'teams');
        
        // Store in global variable for manual save button
        currentCalculatedResults = teamResultsToSave;
        console.log(`‚úì Stored ${currentCalculatedResults.length} team results for category ${categoryCode}`);
        
        // Try to auto-save to Firebase
        try {
          await saveCalculatedResults(categoryCode, teamResultsToSave);
        } catch (err) {
          console.error('Auto-save failed, use manual save button:', err);
        }
      }

      // ==================== END TEAM RESULTS FUNCTIONS ====================

      function calculateToParForPlayer(player, roundIds) {
        // To Par is ALWAYS based on gross scores, regardless of tournament format
        const tournament = getTournament();
        
        let totalToPar = 0;
        let hasAnyScore = false;
        
        roundIds.forEach((roundId, index) => {
          // Get gross score for this round
          const grossScore = calculateGrossTotal(player, roundId);
          
          if (grossScore !== null && typeof grossScore === 'number') {
            const par = getCourseParForRound(roundId);
            totalToPar += (grossScore - par);
            hasAnyScore = true;
          }
        });
        
        return hasAnyScore ? totalToPar : null;
      }

      async function generateResults() {
        const tournament = getTournament();
        if (!tournament) {
          alert('Tournament not found');
          return;
        }

        document.getElementById('tournament-name').textContent = tournament.name;
        document.getElementById('category-name').textContent = categoryName;

        const category = tournament.categories?.find(c => c.code === categoryCode);
        if (!category) {
          alert('Category not found');
          return;
        }

        const players = getCategoryPlayers();
        const roundIds = tournament.meta?.roundIds || [];
        const tournamentType = category.tournamentType || 'Stroke Play';

        // Check for incomplete scores
        const incompleteScores = checkIncompleteScores(players, roundIds, tournamentType);
        if (incompleteScores.length > 0) {
          const proceed = confirm(`Warning: There are ${incompleteScores.length} incomplete scorecard(s) for this category:\n\n${incompleteScores.slice(0, 5).join('\n')}${incompleteScores.length > 5 ? `\n... and ${incompleteScores.length - 5} more` : ''}\n\nAre you sure you want to continue?`);
          if (!proceed) {
            window.close();
            return;
          }
          
          // Show warning on page
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML = `<div class="warning-message">‚ö†Ô∏è Warning: ${incompleteScores.length} incomplete scorecard(s) detected</div>`;
        }

        // Show tiebreaker criteria if configured
        const untieCriteriaList = getUntieCriteria();
        if (untieCriteriaList && untieCriteriaList.length > 0) {
          const criteriaNames = {
            'last_round': 'Last Round Score',
            'back_9': 'Back 9 Score',
            'last_6': 'Last 6 Holes',
            'last_3': 'Last 3 Holes',
            'last_hole': 'Last Hole',
            'lower_hcp': 'Lower Handicap',
            'stroke_index': 'Score on Lower S.I. Holes',
            'eagles_birdies_pars': 'More Eagles, Birdies, Pars'
          };
          const criteriaDisplay = untieCriteriaList.map(c => criteriaNames[c] || c).join(' ‚Üí ');
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML += `<div class="tiebreaker-info">‚öñÔ∏è Tiebreaker: Total Score ‚Üí Play Off (if played) ‚Üí ${criteriaDisplay}</div>`;
        } else {
          // Show default tiebreaker info even if no additional criteria selected
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML += `<div class="tiebreaker-info">‚öñÔ∏è Tiebreaker: Total Score ‚Üí Play Off (if played)</div>`;
        }

        // Build table header
        let headerHTML = '<tr>';
        headerHTML += '<th class="text-center">Rank</th>';
        headerHTML += '<th>Player</th>';
        if (displayType === 'club') headerHTML += '<th>Club</th>';
        if (displayType === 'country') headerHTML += '<th>Country</th>';
        if (showHcp) headerHTML += '<th class="text-center">HCP</th>';
        if (showPhcp) headerHTML += '<th class="text-center">PHCP</th>';
        if (showToPar) headerHTML += '<th class="text-center">To Par</th>';
        
        // Add round columns
        if (roundIds.length === 1) {
          headerHTML += '<th class="text-center">Score</th>';
        } else {
          roundIds.forEach((_, index) => {
            headerHTML += `<th class="text-center">D${index + 1}</th>`;
          });
          headerHTML += '<th class="text-center total-cell">Total</th>';
        }
        
        headerHTML += '</tr>';
        document.getElementById('table-head').innerHTML = headerHTML;

        // Determine tournament type
        const typeUpper = (tournamentType || '').toUpperCase();
        const isStableford = typeUpper.includes('STABLEFORD');
        const isStrokePlay = typeUpper.includes('STROKE') || typeUpper.includes('GROSS') || (!isStableford && !typeUpper.includes('MEDAL NET'));
        
        // Filter players: For Stroke Play (gross), exclude players with incomplete holes (0/X scores)
        let eligiblePlayers = players;
        let excludedPlayers = [];
        
        if (isStrokePlay) {
          eligiblePlayers = players.filter(player => !playerHasIncompleteHoles(player, roundIds));
          excludedPlayers = players.filter(player => playerHasIncompleteHoles(player, roundIds));
          
          if (excludedPlayers.length > 0) {
            console.log(`Stroke Play: Excluding ${excludedPlayers.length} player(s) with incomplete holes (0/X scores)`);
            excludedPlayers.forEach(p => console.log(`  - ${p.firstName} ${p.lastName}`));
            
            // Show info message on page
            const warningDiv = document.getElementById('warning-container');
            const existingContent = warningDiv.innerHTML;
            warningDiv.innerHTML = existingContent + `<div class="info-message">‚ÑπÔ∏è ${excludedPlayers.length} player(s) excluded from Stroke Play results due to incomplete holes (0/X scores)</div>`;
          }
        }

        // Calculate scores for all eligible players
        const playerResults = eligiblePlayers.map(player => {
          const roundScores = roundIds.map(roundId => getPlayerRoundScore(player, roundId, tournamentType));
          
          // Check if player has status
          const hasStatus = roundScores.some(score => typeof score === 'string' && ['DQ', 'NS', 'NR'].includes(score));
          const statusValue = hasStatus ? roundScores.find(score => typeof score === 'string') : null;
          
          let total = null;
          if (!hasStatus) {
            total = roundScores.reduce((sum, score) => {
              if (typeof score === 'number') return sum + score;
              return sum;
            }, 0);
          }
          
          return {
            player,
            roundScores,
            total,
            status: statusValue,
            hasStatus
          };
        });

        // Sort players
        // (typeUpper and isStableford already declared above)
        
        // Separate normal players and status players
        const normalPlayers = playerResults.filter(pr => !pr.hasStatus);
        const statusPlayers = playerResults.filter(pr => pr.hasStatus);
        
        // Get untie criteria to check if tiebreakers are enabled
        const untieCriteria = getUntieCriteria();
        const hasUntieCriteria = untieCriteria && untieCriteria.length > 0;
        
        // Check if play-off results exist for this category (tournament already declared above)
        const hasPlayOffResults = tournament?.playOffResults?.[categoryCode]?.length > 0;
        
        // Tiebreakers are active if either play-off results exist OR untie criteria are set
        const hasTiebreakers = hasPlayOffResults || hasUntieCriteria;
        
        // Sort normal players by total, then apply tiebreakers if enabled
        normalPlayers.sort((a, b) => {
          if (a.total === null && b.total === null) return 0;
          if (a.total === null) return 1;
          if (b.total === null) return -1;
          
          // Primary comparison: total score
          let comparison;
          if (isStableford) {
            comparison = b.total - a.total; // Higher is better
          } else {
            comparison = a.total - b.total; // Lower is better
          }
          
          // If tied and tiebreakers are enabled, apply them
          if (comparison === 0 && hasTiebreakers) {
            return compareTiebreakers(a, b, roundIds, isStableford);
          }
          
          return comparison;
        });

        // Assign ranks - now each player should have unique rank if tiebreakers resolved the tie
        let currentRank = 1;
        let previousTotal = null;
        let previousTiebreakerResult = null;
        
        normalPlayers.forEach((pr, index) => {
          if (pr.total === null) {
            pr.rank = '-';
          } else if (index === 0) {
            // First player
            pr.rank = 1;
            currentRank = 1;
            previousTotal = pr.total;
          } else {
            const prevPlayer = normalPlayers[index - 1];
            
            // Check if this player has the same total as previous
            if (pr.total === prevPlayer.total) {
              // If tiebreakers are enabled, check if they're actually still tied
              if (hasTiebreakers) {
                const tiebreakerResult = compareTiebreakers(prevPlayer, pr, roundIds, isStableford);
                if (tiebreakerResult !== 0) {
                  // Tiebreaker resolved - give next rank
                  currentRank = index + 1;
                  pr.rank = currentRank;
                } else {
                  // Still tied after tiebreakers
                  pr.rank = currentRank;
                }
              } else {
                // No tiebreakers - same rank
                pr.rank = currentRank;
              }
            } else {
              // Different total - new rank
              currentRank = index + 1;
              pr.rank = currentRank;
            }
            
            previousTotal = pr.total;
          }
        });

        // Build table body
        const allResults = [...normalPlayers, ...statusPlayers];
        let bodyHTML = '';
        
        allResults.forEach(pr => {
          const isStatusRow = pr.hasStatus;
          const playerId = pr.player.reg || pr.player.id || pr.player.odaNo || `${pr.player.firstName}_${pr.player.lastName}`;
          const rankClass = !isStatusRow && pr.rank && pr.rank <= 3 ? `rank-${pr.rank}` : '';
          bodyHTML += `<tr${isStatusRow ? ' class="status-row"' : ''} onclick="showScorecard('${playerId}')">`;
          
          // Rank - with special class for top 3
          if (isStatusRow) {
            bodyHTML += `<td class="text-center rank-cell status-indicator">${pr.status}</td>`;
          } else {
            bodyHTML += `<td class="text-center rank-cell ${rankClass}">${pr.rank || '-'}</td>`;
          }
          
          // Player
          bodyHTML += `<td class="player-cell">${pr.player.firstName} ${pr.player.lastName}</td>`;
          
          // Club/Country
          if (displayType === 'club') {
            bodyHTML += `<td>${pr.player.club || pr.player.homeClub || '-'}</td>`;
          }
          if (displayType === 'country') {
            bodyHTML += `<td>${pr.player.nationality || pr.player.country || '-'}</td>`;
          }
          
          // HCP
          if (showHcp) {
            const hcp = pr.player.hcp || '-';
            bodyHTML += `<td class="text-center">${hcp}</td>`;
          }
          
          // PHCP
          if (showPhcp) {
            const phcp = getPlayerPhcp(pr.player);
            const phcpDisplay = phcp !== null ? (phcp < 0 ? '+' + Math.abs(phcp) : phcp) : '-';
            bodyHTML += `<td class="text-center">${phcpDisplay}</td>`;
          }
          
          // To Par
          if (showToPar) {
            if (pr.hasStatus) {
              bodyHTML += `<td class="text-center">-</td>`;
            } else {
              const toPar = calculateToParForPlayer(pr.player, roundIds);
              if (toPar !== null) {
                const toParStr = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar.toString());
                bodyHTML += `<td class="text-center">${toParStr}</td>`;
              } else {
                bodyHTML += `<td class="text-center">-</td>`;
              }
            }
          }
          
          // Round scores
          pr.roundScores.forEach(score => {
            if (typeof score === 'string') {
              bodyHTML += `<td class="text-center">${score}</td>`;
            } else if (score !== null) {
              bodyHTML += `<td class="text-center">${score}</td>`;
            } else {
              bodyHTML += `<td class="text-center">-</td>`;
            }
          });
          
          // Total (only for multi-round)
          if (roundIds.length > 1) {
            if (pr.hasStatus) {
              bodyHTML += `<td class="text-center total-cell">${pr.status}</td>`;
            } else if (pr.total !== null) {
              bodyHTML += `<td class="text-center total-cell">${pr.total}</td>`;
            } else {
              bodyHTML += `<td class="text-center total-cell">-</td>`;
            }
          }
          
          bodyHTML += '</tr>';
        });

        document.getElementById('table-body').innerHTML = bodyHTML;
        
        // Save calculated individual results to Firebase
        // Note: Firebase doesn't accept undefined values, so we convert them to null
        const allPlayerResults = [...normalPlayers, ...statusPlayers];
        const individualResultsToSave = allPlayerResults.map(pr => ({
          type: 'individual',
          reg: pr.player.reg || null,
          firstName: pr.player.firstName || '',
          lastName: pr.player.lastName || '',
          club: pr.player.club || pr.player.homeClub || null,
          nationality: pr.player.nationality || pr.player.country || null,
          rank: pr.rank !== undefined ? pr.rank : null,
          total: pr.total !== undefined ? pr.total : null,
          roundScores: pr.roundScores || [],
          status: pr.status || null,
          hcp: pr.player.hcp !== undefined ? pr.player.hcp : null,
          phcp: pr.player.phcp !== undefined ? pr.player.phcp : null
        }));
        
        // Store in global variable for manual save button
        currentCalculatedResults = individualResultsToSave;
        console.log(`‚úì Stored ${currentCalculatedResults.length} results for category ${categoryCode}`);
        
        // Try to auto-save to Firebase
        try {
          await saveCalculatedResults(categoryCode, individualResultsToSave);
        } catch (err) {
          console.error('Auto-save failed, use manual save button:', err);
        }
      }

      // ==================== SCORECARD MODAL FUNCTIONS ====================
      
      function showScorecard(playerId) {
        const modal = document.getElementById('scorecard-modal');
        const modalBody = document.getElementById('modal-body');
        const modalTitle = document.getElementById('modal-player-name');
        
        // Find player from admitted players
        const tournament = getTournament();
        const roundIds = tournament?.meta?.roundIds || [];
        
        let player = null;
        const admitted = JSON.parse(localStorage.getItem('admittedPlayers') || '{}');
        
        for (const roundId of roundIds) {
          const roundPlayers = admitted[roundId] || [];
          player = roundPlayers.find(p => p.reg === playerId || p.id === playerId || p.odaNo === playerId || `${p.firstName}_${p.lastName}` === playerId);
          if (player) break;
        }
        
        if (!player) {
          modalTitle.textContent = 'Player Not Found';
          modalBody.innerHTML = '<p>Could not find player details.</p>';
          modal.classList.add('active');
          return;
        }
        
        modalTitle.textContent = `${player.firstName} ${player.lastName}`;
        
        // Build scorecard content
        let html = '<div class="scorecard-info">';
        html += `<div class="scorecard-info-item"><label>Club</label><span>${player.club || player.homeClub || '-'}</span></div>`;
        html += `<div class="scorecard-info-item"><label>HCP</label><span>${player.hcp !== undefined ? player.hcp : '-'}</span></div>`;
        if (player.phcp !== undefined) {
          html += `<div class="scorecard-info-item"><label>Playing HCP</label><span>${player.phcp}</span></div>`;
        }
        html += '</div>';
        
        // Get courses
        const courses = JSON.parse(localStorage.getItem('courses') || '[]');
        const scores = getScores();
        
        // Get hole-by-hole scores for each round
        roundIds.forEach((roundId, roundIdx) => {
          const roundScores = scores[roundId] || {};
          const playerScore = roundScores[playerId];
          
          // Get course info
          const roundData = tournament.meta?.roundsData?.[roundIdx];
          const courseId = roundData?.course || '';
          const course = courses.find(c => c.courseId === courseId || c.courseName === courseId || c.id === courseId || c.name === courseId);
          
          html += `<h4 style="margin: 24px 0 12px 0;">Round ${roundIdx + 1}${course?.courseName || course?.name ? ': ' + (course.courseName || course.name) : ''}</h4>`;
          
          if (playerScore && playerScore.holes && Array.isArray(playerScore.holes)) {
            html += renderHoleByHoleTable(playerScore, course);
          } else {
            html += '<p style="color:#64748b;">No scorecard available for this round</p>';
          }
        });
        
        modalBody.innerHTML = html;
        modal.classList.add('active');
      }
      
      function renderHoleByHoleTable(playerScore, course) {
        const holes = playerScore.holes;
        if (!Array.isArray(holes) || holes.length === 0) {
          return '<p style="color:#64748b;">No hole-by-hole scores available</p>';
        }
        
        // Get stableford points if available
        const stbPoints = playerScore.stablefordPoints || [];
        const hasStableford = stbPoints.length > 0;
        
        // Get par values from course or default
        let pars = [];
        if (course && course.pars && Array.isArray(course.pars)) {
          pars = course.pars.map(p => parseInt(p) || 4);
        } else if (course && course.holes) {
          pars = course.holes.map(h => h.par || 4);
        } else {
          pars = Array(18).fill(4);
        }
        
        let html = '<table class="scorecard-table">';
        
        // Front 9
        html += '<tr class="hole-row"><th>Hole</th>';
        for (let i = 1; i <= 9; i++) html += `<th>${i}</th>`;
        html += '<th>Out</th></tr>';
        
        html += '<tr class="par-row"><td>Par</td>';
        let frontPar = 0;
        for (let i = 0; i < 9; i++) {
          const par = pars[i] || 4;
          frontPar += par;
          html += `<td>${par}</td>`;
        }
        html += `<td class="total-cell">${frontPar}</td></tr>`;
        
        html += '<tr class="score-row"><td>Gross</td>';
        let frontScore = 0;
        for (let i = 0; i < 9; i++) {
          const score = parseInt(holes[i]) || 0;
          const par = pars[i] || 4;
          const scoreClass = getScoreClass(score, par);
          frontScore += score;
          html += `<td class="${scoreClass}">${score || '-'}</td>`;
        }
        html += `<td class="total-cell">${frontScore || '-'}</td></tr>`;
        
        // Stableford points row for front 9
        if (hasStableford) {
          html += '<tr class="score-row"><td>Points</td>';
          let frontStb = 0;
          for (let i = 0; i < 9; i++) {
            const pts = parseInt(stbPoints[i]) || 0;
            frontStb += pts;
            html += `<td>${pts}</td>`;
          }
          html += `<td class="total-cell">${frontStb}</td></tr>`;
        }
        
        // Back 9
        if (holes.length > 9) {
          html += '<tr class="hole-row"><th>Hole</th>';
          for (let i = 10; i <= 18; i++) html += `<th>${i}</th>`;
          html += '<th>In</th></tr>';
          
          html += '<tr class="par-row"><td>Par</td>';
          let backPar = 0;
          for (let i = 9; i < 18; i++) {
            const par = pars[i] || 4;
            backPar += par;
            html += `<td>${par}</td>`;
          }
          html += `<td class="total-cell">${backPar}</td></tr>`;
          
          html += '<tr class="score-row"><td>Gross</td>';
          let backScore = 0;
          for (let i = 9; i < 18; i++) {
            const score = parseInt(holes[i]) || 0;
            const par = pars[i] || 4;
            const scoreClass = getScoreClass(score, par);
            backScore += score;
            html += `<td class="${scoreClass}">${score || '-'}</td>`;
          }
          html += `<td class="total-cell">${backScore || '-'}</td></tr>`;
          
          // Stableford points row for back 9
          if (hasStableford) {
            html += '<tr class="score-row"><td>Points</td>';
            let backStb = 0;
            for (let i = 9; i < 18; i++) {
              const pts = parseInt(stbPoints[i]) || 0;
              backStb += pts;
              html += `<td>${pts}</td>`;
            }
            html += `<td class="total-cell">${backStb}</td></tr>`;
          }
          
          // Total row
          html += '<tr style="height: 8px;"><td colspan="11"></td></tr>';
          html += '<tr class="score-row"><td><strong>Total</strong></td>';
          html += `<td colspan="9" style="text-align: right;"><strong>Gross: ${frontScore + backScore}</strong></td>`;
          if (hasStableford) {
            const totalStb = stbPoints.reduce((sum, p) => sum + (parseInt(p) || 0), 0);
            html += `<td class="total-cell"><strong>${totalStb} pts</strong></td></tr>`;
          } else {
            html += `<td class="total-cell"><strong>${frontScore + backScore}</strong></td></tr>`;
          }
        }
        
        html += '</table>';
        return html;
      }
      
      function getScoreClass(score, par) {
        if (!score || !par) return '';
        const diff = score - par;
        if (diff <= -2) return 'score-eagle';
        if (diff === -1) return 'score-birdie';
        if (diff === 1) return 'score-bogey';
        if (diff === 2) return 'score-double';
        if (diff > 2) return 'score-worse';
        return '';
      }
      
      function closeScorecardModal() {
        document.getElementById('scorecard-modal').classList.remove('active');
      }
      
      // Close modal on overlay click
      document.getElementById('scorecard-modal').addEventListener('click', (e) => {
        if (e.target.id === 'scorecard-modal') closeScorecardModal();
      });
      
      // Close modal on escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeScorecardModal();
      });
      
      // ==================== END SCORECARD MODAL FUNCTIONS ====================

      // Generate results on page load
      async function initPage() {
        if (!tournamentId || !categoryCode) {
          alert('Missing parameters');
          window.close();
          return;
        }
        
        // Load from Firebase first
        await loadFromFirebase();
        
        // Check if this is a team category in a team tournament
        if (isTeamCategory()) {
          generateTeamResults();
        } else {
          generateResults();
        }
      }
      
      initPage();
    </script>
  </body>
</html>
