<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Results Display</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      .results-display-container { max-width: 1400px; margin: 36px auto; padding: 24px; }
      .results-header { text-align: center; margin-bottom: 32px; }
      .results-header h1 { margin: 0; font-size: 28px; color: #1e293b; }
      .results-header .category-name { font-size: 20px; color: #64748b; margin-top: 8px; }
      .results-table-wrapper { background: white; border-radius: 12px; box-shadow: 0 10px 30px rgba(2,6,23,0.06); overflow-x: auto; padding: 24px; }
      .results-table { width: 100%; border-collapse: collapse; font-size: 14px; }
      .results-table thead th { 
        background: #f8fafc; 
        padding: 12px 16px; 
        text-align: left; 
        font-weight: 600; 
        color: #475569;
        border-bottom: 2px solid #e2e8f0;
        white-space: nowrap;
      }
      .results-table thead th.text-center { text-align: center; }
      .results-table thead th.text-right { text-align: right; }
      .results-table tbody td { 
        padding: 10px 16px; 
        border-bottom: 1px solid #f1f5f9;
        color: #1e293b;
      }
      .results-table tbody td.text-center { text-align: center; }
      .results-table tbody td.text-right { text-align: right; }
      .results-table tbody tr:hover { background: #f8fafc; }
      .results-table tbody tr.status-row { background: #fef2f2; }
      .results-table tbody tr.status-row:hover { background: #fee2e2; }
      .rank-cell { font-weight: 600; color: #0f172a; font-size: 15px; }
      .player-cell { font-weight: 500; color: #0f172a; }
      .total-cell { font-weight: 700; color: #0f172a; font-size: 15px; background: #f1f5f9; }
      .warning-message { 
        background: #fef3c7; 
        border: 2px solid #f59e0b; 
        border-radius: 8px; 
        padding: 16px; 
        margin-bottom: 24px;
        text-align: center;
        color: #92400e;
        font-weight: 600;
      }
      .info-message { 
        background: #dbeafe; 
        border: 2px solid #3b82f6; 
        border-radius: 8px; 
        padding: 16px; 
        margin-bottom: 24px;
        text-align: center;
        color: #1e40af;
        font-weight: 600;
      }
      .tiebreaker-info {
        background: #f3e8ff;
        border: 2px solid #a855f7;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
        text-align: center;
        color: #7c3aed;
        font-weight: 500;
        font-size: 13px;
      }
      .action-buttons { 
        display: flex; 
        gap: 10px; 
        margin-top: 24px;
        justify-content: center;
      }
      .btn { 
        background: linear-gradient(180deg, var(--accent), #0a58d1); 
        color: white; 
        border: 0; 
        padding: 10px 20px; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 14px; 
        font-weight: 600;
        transition: transform 0.08s; 
      }
      .btn:active { transform: translateY(1px); }
      .btn-print { background: linear-gradient(180deg, #10b981, #059669); }
      .btn-back { 
        background: white; 
        color: #0b6efd; 
        border: 1px solid #e6e9ef; 
      }
      @media print {
        .action-buttons, .btn { display: none; }
        .results-display-container { margin: 0; padding: 20px; }
        .warning-message { display: none; }
      }
    </style>
  </head>
  <body>
    <main class="results-display-container">
      <div class="results-header">
        <h1 id="tournament-name">Tournament Results</h1>
        <div class="category-name" id="category-name"></div>
      </div>

      <div id="warning-container"></div>

      <div class="results-table-wrapper">
        <table class="results-table" id="results-table">
          <thead id="table-head"></thead>
          <tbody id="table-body"></tbody>
        </table>
      </div>

      <div class="action-buttons">
        <button class="btn btn-print" onclick="window.print()">Print Results</button>
        <button class="btn btn-back" onclick="window.close()">Close</button>
      </div>
    </main>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');
      const categoryCode = urlParams.get('categoryCode');
      const categoryName = urlParams.get('categoryName');
      const displayType = urlParams.get('display');
      const showHcp = urlParams.get('hcp') === 'yes';
      const showPhcp = urlParams.get('phcp') === 'yes';
      const showToPar = urlParams.get('topar') === 'yes';

      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function getTournament() {
        const tournaments = getTournaments();
        return tournaments.find(t => t.tournamentId === tournamentId);
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          const tournament = getTournament();
          if (!tournament || !tournament.meta || !tournament.meta.roundIds) return [];
          
          // Get players from all rounds
          const allPlayers = [];
          tournament.meta.roundIds.forEach(roundId => {
            if (data[roundId]) {
              data[roundId].forEach(player => {
                if (!allPlayers.find(p => p.reg === player.reg)) {
                  allPlayers.push(player);
                }
              });
            }
          });
          
          return allPlayers;
        } catch (err) {
          console.error('Error loading admitted players:', err);
          return [];
        }
      }

      function getScores() {
        try {
          const raw = localStorage.getItem('scores');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Error loading scores:', err);
          return {};
        }
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Error loading courses:', err);
          return [];
        }
      }

      function getTeeData(player, roundIndex) {
        const tournament = getTournament();
        if (!tournament) return null;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        if (!roundData) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeValue = '';
        
        // Check if player has an assigned tee (from categories)
        if (player.tee) {
          const courses = getCourses();
          const courseId = roundData.course;
          const course = courses.find(c => c.courseId === courseId);
          
          if (course && course.teeIds) {
            const idx = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              teeValue = `${courseId}||${idx}`;
            }
          }
        }
        
        // If no assigned tee, use default from tournament settings
        if (!teeValue) {
          if (playerGender === 'male' || playerGender === 'm') {
            teeValue = roundData.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            teeValue = roundData.teeWomen || '';
          }
        }
        
        if (!teeValue || !teeValue.includes('||')) return null;
        
        const [courseId, teeIndexStr] = teeValue.split('||');
        const teeIndex = parseInt(teeIndexStr, 10);
        
        const courses = getCourses();
        const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
        
        if (!course) return null;
        
        // Calculate total par from pars array (sum of all 18 holes)
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        // Get tee-specific data from teeData array
        const teeData = course.teeData?.[teeIndex];
        if (!teeData) return null;
        
        let slope, rating;
        
        // Check if this tee is for both genders (has nested ratings structure)
        const teeGender = course.genders?.[teeIndex];
        if (teeGender === 'B' && teeData.ratings) {
          // Both genders - use appropriate gender's ratings
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else if (playerGender === 'female' || playerGender === 'f') {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          // Single gender tee
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        return { slope, rating, par, course };
      }

      function calculatePlayingHcp(player, roundIndex = 0) {
        const playerHcp = parseFloat(player.hcp);
        if (isNaN(playerHcp)) {
          return null;
        }
        
        const teeData = getTeeData(player, roundIndex);
        if (!teeData || !teeData.slope || !teeData.rating || !teeData.par) {
          return Math.round(playerHcp); // Fallback to rounded WHS HCP if data missing
        }
        
        const tournament = getTournament();
        const slope = parseFloat(teeData.slope);
        const rating = parseFloat(teeData.rating);
        const par = parseFloat(teeData.par);
        const hcpAllowance = parseFloat(tournament?.meta?.hcpAllow || 100) / 100;
        
        if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
          return Math.round(playerHcp);
        }
        
        // Formula: (HCP × (Slope/113) + (Rating - Par)) × HCP_Allowance
        const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
        
        // Round to nearest whole number (.5 rounds up)
        return Math.round(playingHcp);
      }

      function getPlayerPhcp(player) {
        // Use stored PHCP or calculate it as fallback
        if (player.phcp !== undefined && player.phcp !== null && player.phcp !== '') {
          return player.phcp;
        }
        // Calculate PHCP if not stored
        const calculatedPhcp = calculatePlayingHcp(player, 0);
        if (calculatedPhcp !== null) {
          player.phcp = calculatedPhcp; // Cache it
          return calculatedPhcp;
        }
        return null;
      }

      function getCategoryPlayers() {
        const allPlayers = getAdmittedPlayers();
        // Filter players who belong to this category
        return allPlayers.filter(player => {
          if (player.categories && Array.isArray(player.categories)) {
            return player.categories.includes(categoryCode);
          }
          return player.category === categoryCode;
        });
      }

      function calculateNetScore(grossScore, hcp) {
        if (typeof grossScore !== 'number' || isNaN(grossScore)) return null;
        if (typeof hcp !== 'number' || isNaN(hcp)) return grossScore;
        return grossScore - hcp;
      }

      function calculateStablefordTotal(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        if (!playerScores || !playerScores.stablefordPoints) return null;
        
        // Check if array is empty or all values are empty/null
        const hasAnyScore = playerScores.stablefordPoints.some(p => p !== null && p !== undefined && p !== '');
        if (!hasAnyScore) return null;
        
        return playerScores.stablefordPoints.reduce((sum, points) => {
          const p = parseInt(points);
          return sum + (isNaN(p) ? 0 : p);
        }, 0);
      }

      function calculateGrossTotal(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        if (!playerScores || !playerScores.holes) return null;
        
        // Check if array is empty or all values are empty/null
        const hasAnyScore = playerScores.holes.some(h => h !== null && h !== undefined && h !== '');
        if (!hasAnyScore) return null;
        
        return playerScores.holes.reduce((sum, strokes) => {
          const s = parseInt(strokes);
          return sum + (isNaN(s) ? 0 : s);
        }, 0);
      }

      function getPlayerRoundScore(player, roundId, tournamentType) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        
        // If no score record exists at all, return null
        if (!playerScores) return null;
        
        // Check for status first
        if (playerScores.status && playerScores.status !== 'OK') {
          return playerScores.status; // DQ, NS, NR
        }
        
        // If status is explicitly 'OK' or undefined, check for actual scores
        const typeUpper = (tournamentType || '').toUpperCase();
        let result = null;
        
        if (typeUpper.includes('STABLEFORD')) {
          result = calculateStablefordTotal(player, roundId);
        } else if (typeUpper.includes('MEDAL NET')) {
          const gross = calculateGrossTotal(player, roundId);
          if (gross === null) {
            result = null;
          } else {
            const phcp = getPlayerPhcp(player) || 0;
            result = calculateNetScore(gross, phcp);
          }
        } else {
          // Stroke Play (gross)
          result = calculateGrossTotal(player, roundId);
        }
        
        // If we have a score record but no actual scores, treat as incomplete
        // This catches the case where scorecard was opened but not filled
        if (result === null && playerScores && !playerScores.status) {
          // Scorecard exists but is empty and has no status - this is incomplete
          return null;
        }
        
        return result;
      }

      // Check if a player has any incomplete holes (0/X scores) in any round
      function playerHasIncompleteHoles(player, roundIds) {
        const scores = getScores();
        
        for (const roundId of roundIds) {
          const playerScores = scores[roundId]?.[player.reg];
          if (!playerScores) continue;
          
          // Check incompleteHoles array
          if (playerScores.incompleteHoles && playerScores.incompleteHoles.length > 0) {
            return true;
          }
          
          // Check isIncompleteHole object
          if (playerScores.isIncompleteHole) {
            const hasIncomplete = Object.values(playerScores.isIncompleteHole).some(v => v === true);
            if (hasIncomplete) return true;
          }
        }
        
        return false;
      }

      function isPlayerRoundComplete(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        
        // No score record at all - incomplete
        if (!playerScores) return false;
        
        // Has a status (DQ, NS, NR) - considered complete
        if (playerScores.status && playerScores.status !== 'OK') return true;
        
        // Check if all 18 holes have scores
        if (playerScores.holes && Array.isArray(playerScores.holes)) {
          const completedHoles = playerScores.holes.filter(s => s !== '' && s !== null && s !== undefined).length;
          return completedHoles === 18;
        }
        
        // No holes array or empty - incomplete
        return false;
      }

      function checkIncompleteScores(players, roundIds, tournamentType) {
        const incomplete = [];
        const tournament = getTournament();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        console.log('=== Checking Incomplete Scores ===');
        console.log('Total players in category:', players.length);
        console.log('All round IDs:', roundIds);
        console.log('Today:', today.toISOString().split('T')[0]);
        
        // Determine which rounds should be completed based on today's date
        const roundsToCheck = [];
        
        if (tournament?.meta?.roundsData) {
          roundIds.forEach((roundId, index) => {
            const roundData = tournament.meta.roundsData[index];
            console.log(`Round ${index + 1} (${roundId}):`, roundData?.date);
            
            if (roundData && roundData.date) {
              const roundDate = new Date(roundData.date);
              roundDate.setHours(0, 0, 0, 0);
              
              console.log(`  Round date: ${roundDate.toISOString().split('T')[0]}, Should check: ${roundDate <= today}`);
              
              // Only check rounds that have already happened (date <= today)
              if (roundDate <= today) {
                roundsToCheck.push(roundId);
              }
            } else {
              // If no date info, check all rounds (backward compatibility)
              console.log('  No date info, checking this round');
              roundsToCheck.push(roundId);
            }
          });
        } else {
          // No date information, check all rounds
          console.log('No round data found, checking all rounds');
          roundsToCheck.push(...roundIds);
        }
        
        console.log('Rounds to check:', roundsToCheck);
        
        // Check only the rounds that should be completed
        players.forEach(player => {
          roundsToCheck.forEach(roundId => {
            const isComplete = isPlayerRoundComplete(player, roundId);
            console.log(`${player.firstName} ${player.lastName} - ${roundId}: ${isComplete ? 'COMPLETE' : 'INCOMPLETE'}`);
            
            if (!isComplete) {
              const roundIndex = roundIds.indexOf(roundId);
              incomplete.push(`${player.firstName} ${player.lastName} - Round ${roundIndex + 1}`);
            }
          });
        });
        
        console.log('Total incomplete scorecards:', incomplete.length);
        console.log('Incomplete list:', incomplete);
        
        return incomplete;
      }

      function getCourseParForRound(roundId) {
        const tournament = getTournament();
        if (!tournament?.meta?.roundIds) return 72;
        
        const roundIndex = tournament.meta.roundIds.indexOf(roundId);
        
        // Get course identifier - first from roundData, then from tournament
        let courseIdentifier = null;
        
        if (roundIndex !== -1) {
          const roundData = tournament.meta.roundsData?.[roundIndex];
          if (roundData && roundData.course) {
            courseIdentifier = roundData.course;
          }
        }
        
        // Fallback to tournament course
        if (!courseIdentifier && tournament.course) {
          courseIdentifier = tournament.course;
        }
        
        if (!courseIdentifier) return 72;
        
        // Get course data
        try {
          const raw = localStorage.getItem('courses');
          const courses = raw ? JSON.parse(raw) : [];
          
          // Try to find by courseId first, then by courseName
          let course = courses.find(c => c.courseId === courseIdentifier);
          if (!course) {
            course = courses.find(c => c.courseName === courseIdentifier);
          }
          
          if (course && course.pars) {
            return course.pars.reduce((sum, p) => sum + (parseInt(p) || 0), 0);
          }
        } catch (err) {
          console.error('Error loading course data:', err);
        }
        
        return 72;
      }

      // ==================== TIEBREAKER FUNCTIONS ====================
      
      // Get the untie criteria from tournament settings
      function getUntieCriteria() {
        const tournament = getTournament();
        return tournament?.untieCriteria || [];
      }

      // Get course data for a round (stroke indexes, pars)
      function getCourseDataForRound(roundId) {
        const tournament = getTournament();
        if (!tournament?.meta?.roundIds) return null;
        
        const roundIndex = tournament.meta.roundIds.indexOf(roundId);
        if (roundIndex === -1) return null;
        
        const roundData = tournament.meta.roundsData?.[roundIndex];
        if (!roundData) return null;
        
        try {
          const raw = localStorage.getItem('courses');
          const courses = raw ? JSON.parse(raw) : [];
          return courses.find(c => c.courseId === roundData.course);
        } catch (err) {
          console.error('Error loading course data:', err);
          return null;
        }
      }

      // Get player's hole scores for a specific round
      function getPlayerHoleScores(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        return playerScores?.holes || [];
      }

      // Get player's stableford points for a specific round
      function getPlayerStablefordPoints(player, roundId) {
        const scores = getScores();
        const playerScores = scores[roundId]?.[player.reg];
        return playerScores?.stablefordPoints || [];
      }

      // Tiebreaker: Last Round Score
      function tiebreakLastRound(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        let scoreA, scoreB;
        if (isStableford) {
          scoreA = calculateStablefordTotal(playerA, lastRoundId) || 0;
          scoreB = calculateStablefordTotal(playerB, lastRoundId) || 0;
          return scoreB - scoreA; // Higher is better for Stableford
        } else {
          scoreA = calculateGrossTotal(playerA, lastRoundId) || 999;
          scoreB = calculateGrossTotal(playerB, lastRoundId) || 999;
          return scoreA - scoreB; // Lower is better for Stroke Play
        }
      }

      // Tiebreaker: Back 9 (holes 10-18 of last round)
      function tiebreakBack9(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(9, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(9, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(9, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(9, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last 6 Holes (holes 13-18 of last round)
      function tiebreakLast6(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(12, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(12, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(12, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(12, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last 3 Holes (holes 16-18 of last round)
      function tiebreakLast3(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const sumA = pointsA.slice(15, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          const sumB = pointsB.slice(15, 18).reduce((s, p) => s + (parseInt(p) || 0), 0);
          return sumB - sumA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const sumA = holesA.slice(15, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          const sumB = holesB.slice(15, 18).reduce((s, h) => s + (parseInt(h) || 0), 0);
          return sumA - sumB; // Lower is better
        }
      }

      // Tiebreaker: Last Hole (hole 18 of last round)
      function tiebreakLastHole(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          const scoreA = parseInt(pointsA[17]) || 0;
          const scoreB = parseInt(pointsB[17]) || 0;
          return scoreB - scoreA; // Higher is better
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          const scoreA = parseInt(holesA[17]) || 0;
          const scoreB = parseInt(holesB[17]) || 0;
          return scoreA - scoreB; // Lower is better
        }
      }

      // Tiebreaker: Lower Handicap
      function tiebreakLowerHcp(playerA, playerB) {
        const hcpA = parseFloat(playerA.hcp) || 999;
        const hcpB = parseFloat(playerB.hcp) || 999;
        return hcpA - hcpB; // Lower HCP wins
      }

      // Tiebreaker: Score on holes by Stroke Index (starting from SI 1)
      function tiebreakStrokeIndex(playerA, playerB, roundIds, isStableford) {
        if (roundIds.length === 0) return 0;
        const lastRoundId = roundIds[roundIds.length - 1];
        
        const courseData = getCourseDataForRound(lastRoundId);
        if (!courseData || !courseData.strokeIndexes) return 0;
        
        const strokeIndexes = courseData.strokeIndexes;
        
        // Create array of hole indices sorted by stroke index (SI 1 first)
        const holesBySI = strokeIndexes
          .map((si, holeIndex) => ({ si: parseInt(si) || 99, holeIndex }))
          .sort((a, b) => a.si - b.si);
        
        if (isStableford) {
          const pointsA = getPlayerStablefordPoints(playerA, lastRoundId);
          const pointsB = getPlayerStablefordPoints(playerB, lastRoundId);
          
          for (const { holeIndex } of holesBySI) {
            const scoreA = parseInt(pointsA[holeIndex]) || 0;
            const scoreB = parseInt(pointsB[holeIndex]) || 0;
            if (scoreA !== scoreB) {
              return scoreB - scoreA; // Higher is better for Stableford
            }
          }
        } else {
          const holesA = getPlayerHoleScores(playerA, lastRoundId);
          const holesB = getPlayerHoleScores(playerB, lastRoundId);
          
          for (const { holeIndex } of holesBySI) {
            const scoreA = parseInt(holesA[holeIndex]) || 0;
            const scoreB = parseInt(holesB[holeIndex]) || 0;
            if (scoreA !== scoreB) {
              return scoreA - scoreB; // Lower is better for Stroke Play
            }
          }
        }
        
        return 0; // Still tied
      }

      // Tiebreaker: More Eagles, Birdies, Pars (countback)
      function tiebreakEaglesBirdiesPars(playerA, playerB, roundIds) {
        const courseData = roundIds.length > 0 ? getCourseDataForRound(roundIds[roundIds.length - 1]) : null;
        if (!courseData || !courseData.pars) return 0;
        
        const pars = courseData.pars;
        
        // Count eagles, birdies, pars for each player across all rounds
        let countA = { eagles: 0, birdies: 0, pars: 0 };
        let countB = { eagles: 0, birdies: 0, pars: 0 };
        
        roundIds.forEach(roundId => {
          const holesA = getPlayerHoleScores(playerA, roundId);
          const holesB = getPlayerHoleScores(playerB, roundId);
          
          holesA.forEach((score, i) => {
            const s = parseInt(score);
            const par = parseInt(pars[i]) || 4;
            if (!isNaN(s)) {
              const diff = s - par;
              if (diff <= -2) countA.eagles++;
              else if (diff === -1) countA.birdies++;
              else if (diff === 0) countA.pars++;
            }
          });
          
          holesB.forEach((score, i) => {
            const s = parseInt(score);
            const par = parseInt(pars[i]) || 4;
            if (!isNaN(s)) {
              const diff = s - par;
              if (diff <= -2) countB.eagles++;
              else if (diff === -1) countB.birdies++;
              else if (diff === 0) countB.pars++;
            }
          });
        });
        
        // Compare eagles first, then birdies, then pars
        if (countA.eagles !== countB.eagles) return countB.eagles - countA.eagles;
        if (countA.birdies !== countB.birdies) return countB.birdies - countA.birdies;
        if (countA.pars !== countB.pars) return countB.pars - countA.pars;
        
        return 0; // Still tied
      }

      // Tiebreaker: Play Off - checks if a play-off result was recorded
      // Play-off results are stored in tournament.playOffResults[categoryCode] = [{ playerReg, position, tiedScore }]
      // 
      // Important: Supports PARTIAL play-off results. If only the winner is set and others are "Not Set",
      // the winner gets priority, and the remaining players continue to the next tiebreaker criteria.
      // 
      // Example scenario:
      // - 3 players tied for 1st (all scored 70)
      // - Play-off: Player 1 scores 4, Players 2 & 3 score 5
      // - User marks Player 1 as "1st (Winner)", leaves 2 & 3 as "Not Set"
      // - Result: Player 1 ranks 1st, Players 2 & 3 use other criteria
      function tiebreakPlayOff(playerA, playerB) {
        const tournament = getTournament();
        if (!tournament.playOffResults || !tournament.playOffResults[categoryCode]) {
          return 0; // No play-off recorded
        }
        
        const playOffResults = tournament.playOffResults[categoryCode];
        
        // Find positions for both players
        const resultA = playOffResults.find(r => r.playerReg === playerA.reg);
        const resultB = playOffResults.find(r => r.playerReg === playerB.reg);
        
        // Case 1: Neither player has a play-off result - continue to other criteria
        if (!resultA && !resultB) {
          return 0;
        }
        
        // Case 2: Both have play-off results in the same tie group
        if (resultA && resultB && resultA.tiedScore === resultB.tiedScore) {
          // Compare positions (lower position = better, 1st beats 2nd)
          return resultA.position - resultB.position;
        }
        
        // Case 3: Only player A has a play-off result
        // Player A was explicitly marked in play-off, which means they resolved their tie
        // Player B might be in the same tie group but wasn't marked (left as "Not Set")
        if (resultA && !resultB) {
          // A has a play-off position, A ranks better
          return -1;
        }
        
        // Case 4: Only player B has a play-off result  
        if (!resultA && resultB) {
          // B has a play-off position, B ranks better
          return 1;
        }
        
        // Case 5: Both have results but in different tie groups
        // This shouldn't happen in practice, but handle it gracefully
        return 0;
      }

      // Main tiebreaker comparison function
      function compareTiebreakers(prA, prB, roundIds, isStableford) {
        // First, always check for play-off results (fixed at position 2)
        const playOffResult = tiebreakPlayOff(prA.player, prB.player);
        if (playOffResult !== 0) {
          console.log(`Tiebreak resolved by Play Off: ${prA.player.firstName} ${prA.player.lastName} vs ${prB.player.firstName} ${prB.player.lastName} = ${playOffResult}`);
          return playOffResult;
        }
        
        const criteria = getUntieCriteria();
        
        // If no additional tiebreaker criteria defined, return 0 (keep tie)
        if (!criteria || criteria.length === 0) return 0;
        
        for (const criteriaId of criteria) {
          let result = 0;
          
          switch (criteriaId) {
            case 'last_round':
              result = tiebreakLastRound(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'back_9':
              result = tiebreakBack9(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_6':
              result = tiebreakLast6(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_3':
              result = tiebreakLast3(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'last_hole':
              result = tiebreakLastHole(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'lower_hcp':
              result = tiebreakLowerHcp(prA.player, prB.player);
              break;
            case 'stroke_index':
              result = tiebreakStrokeIndex(prA.player, prB.player, roundIds, isStableford);
              break;
            case 'eagles_birdies_pars':
              result = tiebreakEaglesBirdiesPars(prA.player, prB.player, roundIds);
              break;
          }
          
          if (result !== 0) {
            console.log(`Tiebreak resolved by ${criteriaId}: ${prA.player.firstName} ${prA.player.lastName} vs ${prB.player.firstName} ${prB.player.lastName} = ${result}`);
            return result;
          }
        }
        
        return 0; // All tiebreakers exhausted, still tied
      }

      // ==================== END TIEBREAKER FUNCTIONS ====================

      function calculateToParForPlayer(player, roundIds) {
        // To Par is ALWAYS based on gross scores, regardless of tournament format
        const tournament = getTournament();
        
        let totalToPar = 0;
        let hasAnyScore = false;
        
        roundIds.forEach((roundId, index) => {
          // Get gross score for this round
          const grossScore = calculateGrossTotal(player, roundId);
          
          if (grossScore !== null && typeof grossScore === 'number') {
            const par = getCourseParForRound(roundId);
            totalToPar += (grossScore - par);
            hasAnyScore = true;
          }
        });
        
        return hasAnyScore ? totalToPar : null;
      }

      function generateResults() {
        const tournament = getTournament();
        if (!tournament) {
          alert('Tournament not found');
          return;
        }

        document.getElementById('tournament-name').textContent = tournament.name;
        document.getElementById('category-name').textContent = categoryName;

        const category = tournament.categories?.find(c => c.code === categoryCode);
        if (!category) {
          alert('Category not found');
          return;
        }

        const players = getCategoryPlayers();
        const roundIds = tournament.meta?.roundIds || [];
        const tournamentType = category.tournamentType || 'Stroke Play';

        // Check for incomplete scores
        const incompleteScores = checkIncompleteScores(players, roundIds, tournamentType);
        if (incompleteScores.length > 0) {
          const proceed = confirm(`Warning: There are ${incompleteScores.length} incomplete scorecard(s) for this category:\n\n${incompleteScores.slice(0, 5).join('\n')}${incompleteScores.length > 5 ? `\n... and ${incompleteScores.length - 5} more` : ''}\n\nAre you sure you want to continue?`);
          if (!proceed) {
            window.close();
            return;
          }
          
          // Show warning on page
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML = `<div class="warning-message">⚠️ Warning: ${incompleteScores.length} incomplete scorecard(s) detected</div>`;
        }

        // Show tiebreaker criteria if configured
        const untieCriteriaList = getUntieCriteria();
        if (untieCriteriaList && untieCriteriaList.length > 0) {
          const criteriaNames = {
            'last_round': 'Last Round Score',
            'back_9': 'Back 9 Score',
            'last_6': 'Last 6 Holes',
            'last_3': 'Last 3 Holes',
            'last_hole': 'Last Hole',
            'lower_hcp': 'Lower Handicap',
            'stroke_index': 'Score on Lower S.I. Holes',
            'eagles_birdies_pars': 'More Eagles, Birdies, Pars'
          };
          const criteriaDisplay = untieCriteriaList.map(c => criteriaNames[c] || c).join(' → ');
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML += `<div class="tiebreaker-info">⚖️ Tiebreaker: Total Score → Play Off (if played) → ${criteriaDisplay}</div>`;
        } else {
          // Show default tiebreaker info even if no additional criteria selected
          const warningDiv = document.getElementById('warning-container');
          warningDiv.innerHTML += `<div class="tiebreaker-info">⚖️ Tiebreaker: Total Score → Play Off (if played)</div>`;
        }

        // Build table header
        let headerHTML = '<tr>';
        headerHTML += '<th class="text-center">Rank</th>';
        headerHTML += '<th>Player</th>';
        if (displayType === 'club') headerHTML += '<th>Club</th>';
        if (displayType === 'country') headerHTML += '<th>Country</th>';
        if (showHcp) headerHTML += '<th class="text-center">HCP</th>';
        if (showPhcp) headerHTML += '<th class="text-center">PHCP</th>';
        if (showToPar) headerHTML += '<th class="text-center">To Par</th>';
        
        // Add round columns
        if (roundIds.length === 1) {
          headerHTML += '<th class="text-center">Score</th>';
        } else {
          roundIds.forEach((_, index) => {
            headerHTML += `<th class="text-center">D${index + 1}</th>`;
          });
          headerHTML += '<th class="text-center total-cell">Total</th>';
        }
        
        headerHTML += '</tr>';
        document.getElementById('table-head').innerHTML = headerHTML;

        // Determine tournament type
        const typeUpper = (tournamentType || '').toUpperCase();
        const isStableford = typeUpper.includes('STABLEFORD');
        const isStrokePlay = typeUpper.includes('STROKE') || typeUpper.includes('GROSS') || (!isStableford && !typeUpper.includes('MEDAL NET'));
        
        // Filter players: For Stroke Play (gross), exclude players with incomplete holes (0/X scores)
        let eligiblePlayers = players;
        let excludedPlayers = [];
        
        if (isStrokePlay) {
          eligiblePlayers = players.filter(player => !playerHasIncompleteHoles(player, roundIds));
          excludedPlayers = players.filter(player => playerHasIncompleteHoles(player, roundIds));
          
          if (excludedPlayers.length > 0) {
            console.log(`Stroke Play: Excluding ${excludedPlayers.length} player(s) with incomplete holes (0/X scores)`);
            excludedPlayers.forEach(p => console.log(`  - ${p.firstName} ${p.lastName}`));
            
            // Show info message on page
            const warningDiv = document.getElementById('warning-container');
            const existingContent = warningDiv.innerHTML;
            warningDiv.innerHTML = existingContent + `<div class="info-message">ℹ️ ${excludedPlayers.length} player(s) excluded from Stroke Play results due to incomplete holes (0/X scores)</div>`;
          }
        }

        // Calculate scores for all eligible players
        const playerResults = eligiblePlayers.map(player => {
          const roundScores = roundIds.map(roundId => getPlayerRoundScore(player, roundId, tournamentType));
          
          // Check if player has status
          const hasStatus = roundScores.some(score => typeof score === 'string' && ['DQ', 'NS', 'NR'].includes(score));
          const statusValue = hasStatus ? roundScores.find(score => typeof score === 'string') : null;
          
          let total = null;
          if (!hasStatus) {
            total = roundScores.reduce((sum, score) => {
              if (typeof score === 'number') return sum + score;
              return sum;
            }, 0);
          }
          
          return {
            player,
            roundScores,
            total,
            status: statusValue,
            hasStatus
          };
        });

        // Sort players
        // (typeUpper and isStableford already declared above)
        
        // Separate normal players and status players
        const normalPlayers = playerResults.filter(pr => !pr.hasStatus);
        const statusPlayers = playerResults.filter(pr => pr.hasStatus);
        
        // Get untie criteria to check if tiebreakers are enabled
        const untieCriteria = getUntieCriteria();
        const hasUntieCriteria = untieCriteria && untieCriteria.length > 0;
        
        // Check if play-off results exist for this category (tournament already declared above)
        const hasPlayOffResults = tournament?.playOffResults?.[categoryCode]?.length > 0;
        
        // Tiebreakers are active if either play-off results exist OR untie criteria are set
        const hasTiebreakers = hasPlayOffResults || hasUntieCriteria;
        
        // Sort normal players by total, then apply tiebreakers if enabled
        normalPlayers.sort((a, b) => {
          if (a.total === null && b.total === null) return 0;
          if (a.total === null) return 1;
          if (b.total === null) return -1;
          
          // Primary comparison: total score
          let comparison;
          if (isStableford) {
            comparison = b.total - a.total; // Higher is better
          } else {
            comparison = a.total - b.total; // Lower is better
          }
          
          // If tied and tiebreakers are enabled, apply them
          if (comparison === 0 && hasTiebreakers) {
            return compareTiebreakers(a, b, roundIds, isStableford);
          }
          
          return comparison;
        });

        // Assign ranks - now each player should have unique rank if tiebreakers resolved the tie
        let currentRank = 1;
        let previousTotal = null;
        let previousTiebreakerResult = null;
        
        normalPlayers.forEach((pr, index) => {
          if (pr.total === null) {
            pr.rank = '-';
          } else if (index === 0) {
            // First player
            pr.rank = 1;
            currentRank = 1;
            previousTotal = pr.total;
          } else {
            const prevPlayer = normalPlayers[index - 1];
            
            // Check if this player has the same total as previous
            if (pr.total === prevPlayer.total) {
              // If tiebreakers are enabled, check if they're actually still tied
              if (hasTiebreakers) {
                const tiebreakerResult = compareTiebreakers(prevPlayer, pr, roundIds, isStableford);
                if (tiebreakerResult !== 0) {
                  // Tiebreaker resolved - give next rank
                  currentRank = index + 1;
                  pr.rank = currentRank;
                } else {
                  // Still tied after tiebreakers
                  pr.rank = currentRank;
                }
              } else {
                // No tiebreakers - same rank
                pr.rank = currentRank;
              }
            } else {
              // Different total - new rank
              currentRank = index + 1;
              pr.rank = currentRank;
            }
            
            previousTotal = pr.total;
          }
        });

        // Build table body
        const allResults = [...normalPlayers, ...statusPlayers];
        let bodyHTML = '';
        
        allResults.forEach(pr => {
          const isStatusRow = pr.hasStatus;
          bodyHTML += `<tr${isStatusRow ? ' class="status-row"' : ''}>`;
          
          // Rank
          bodyHTML += `<td class="text-center rank-cell">${pr.rank || '-'}</td>`;
          
          // Player
          bodyHTML += `<td class="player-cell">${pr.player.firstName} ${pr.player.lastName}</td>`;
          
          // Club/Country
          if (displayType === 'club') {
            bodyHTML += `<td>${pr.player.club || pr.player.homeClub || '-'}</td>`;
          }
          if (displayType === 'country') {
            bodyHTML += `<td>${pr.player.nationality || pr.player.country || '-'}</td>`;
          }
          
          // HCP
          if (showHcp) {
            const hcp = pr.player.hcp || '-';
            bodyHTML += `<td class="text-center">${hcp}</td>`;
          }
          
          // PHCP
          if (showPhcp) {
            const phcp = getPlayerPhcp(pr.player);
            const phcpDisplay = phcp !== null ? (phcp < 0 ? '+' + Math.abs(phcp) : phcp) : '-';
            bodyHTML += `<td class="text-center">${phcpDisplay}</td>`;
          }
          
          // To Par
          if (showToPar) {
            if (pr.hasStatus) {
              bodyHTML += `<td class="text-center">-</td>`;
            } else {
              const toPar = calculateToParForPlayer(pr.player, roundIds);
              if (toPar !== null) {
                const toParStr = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar.toString());
                bodyHTML += `<td class="text-center">${toParStr}</td>`;
              } else {
                bodyHTML += `<td class="text-center">-</td>`;
              }
            }
          }
          
          // Round scores
          pr.roundScores.forEach(score => {
            if (typeof score === 'string') {
              bodyHTML += `<td class="text-center">${score}</td>`;
            } else if (score !== null) {
              bodyHTML += `<td class="text-center">${score}</td>`;
            } else {
              bodyHTML += `<td class="text-center">-</td>`;
            }
          });
          
          // Total (only for multi-round)
          if (roundIds.length > 1) {
            if (pr.hasStatus) {
              bodyHTML += `<td class="text-center total-cell">${pr.status}</td>`;
            } else if (pr.total !== null) {
              bodyHTML += `<td class="text-center total-cell">${pr.total}</td>`;
            } else {
              bodyHTML += `<td class="text-center total-cell">-</td>`;
            }
          }
          
          bodyHTML += '</tr>';
        });

        document.getElementById('table-body').innerHTML = bodyHTML;
      }

      // Generate results on page load
      if (!tournamentId || !categoryCode) {
        alert('Missing parameters');
        window.close();
      } else {
        generateResults();
      }
    </script>
  </body>
</html>
