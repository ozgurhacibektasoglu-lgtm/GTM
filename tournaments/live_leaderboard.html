<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- Real-time updates via Firebase - no page refresh needed -->
    <title>Live Leaderboard</title>
    <style>
      * { box-sizing: border-box; margin: 0; padding: 0; }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        min-height: 100vh;
        color: white;
      }
      
      /* Header */
      .header {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        padding: 20px 24px;
        position: relative;
        overflow: hidden;
      }
      
      .header::before {
        content: '';
        position: absolute;
        top: -50%;
        right: -50%;
        width: 100%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 50%);
      }
      
      .header-content {
        max-width: 1400px;
        margin: 0 auto;
        position: relative;
        z-index: 1;
      }
      
      .tournament-name {
        font-size: 28px;
        font-weight: 800;
        margin-bottom: 4px;
      }
      
      .tournament-info {
        font-size: 14px;
        opacity: 0.9;
      }
      
      .live-indicator {
        position: absolute;
        top: 20px;
        right: 24px;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(239, 68, 68, 0.9);
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 700;
        animation: pulse 2s infinite;
      }
      
      .live-dot {
        width: 8px;
        height: 8px;
        background: white;
        border-radius: 50%;
        animation: blink 1s infinite;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.9; transform: scale(1.02); }
      }
      
      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      
      /* Main Container */
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 24px;
      }
      
      /* Quick Stats */
      .stats-bar {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }
      
      .stat-card {
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 16px 20px;
        text-align: center;
        border: 1px solid rgba(255,255,255,0.1);
      }
      
      .stat-value {
        font-size: 32px;
        font-weight: 800;
        color: #10b981;
      }
      
      .stat-value.red { color: #ef4444; }
      .stat-value.yellow { color: #fbbf24; }
      
      .stat-label {
        font-size: 12px;
        color: rgba(255,255,255,0.7);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-top: 4px;
      }
      
      /* Category Tabs */
      .category-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      
      .category-tab {
        background: rgba(255,255,255,0.1);
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        color: white;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .category-tab:hover {
        background: rgba(255,255,255,0.2);
      }
      
      .category-tab.active {
        background: #059669;
      }
      
      /* ========================================
         MATCH PLAY LEADERBOARD STYLES
         ======================================== */
      
      .match-list {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      
      .match-card-lb {
        background: rgba(255,255,255,0.08);
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.1);
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .match-card-lb:hover {
        background: rgba(255,255,255,0.12);
        transform: translateY(-2px);
      }
      
      .match-card-lb.completed {
        opacity: 0.8;
      }
      
      .match-card-header {
        background: rgba(0,0,0,0.3);
        padding: 12px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .match-card-info {
        font-size: 13px;
        color: rgba(255,255,255,0.7);
        font-weight: 600;
      }
      
      .match-format-label {
        background: rgba(139, 92, 246, 0.3);
        color: #c4b5fd;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 700;
      }
      
      .match-card-body {
        padding: 20px;
      }
      
      .match-competitors-lb {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
      }
      
      .match-side-lb {
        flex: 1;
        text-align: center;
      }
      
      .match-side-lb.home {
        text-align: left;
      }
      
      .match-side-lb.away {
        text-align: right;
      }
      
      .match-side-names {
        font-size: 16px;
        font-weight: 700;
        color: white;
        margin-bottom: 4px;
      }
      
      .match-side-names.winning {
        color: #10b981;
      }
      
      .match-side-names.losing {
        color: rgba(255,255,255,0.5);
      }
      
      .match-side-club {
        font-size: 12px;
        color: rgba(255,255,255,0.5);
      }
      
      .match-side-hcp {
        font-size: 11px;
        color: #a78bfa;
        margin-top: 4px;
      }
      
      .match-result-center {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
      }
      
      .match-score-arrow {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 4px;
      }
      
      .match-arrow {
        font-size: 24px;
        transition: transform 0.3s ease;
      }
      
      .match-arrow.left {
        color: #10b981;
      }
      
      .match-arrow.right {
        color: #10b981;
        transform: scaleX(-1);
      }
      
      .match-score-text {
        font-size: 24px;
        font-weight: 800;
        color: white;
      }
      
      .match-score-text.all-square {
        color: rgba(255,255,255,0.6);
        font-size: 18px;
      }
      
      .match-thru-text {
        font-size: 12px;
        color: rgba(255,255,255,0.5);
      }
      
      .match-final-badge {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 700;
        margin-top: 4px;
      }
      
      /* Match Detail Modal */
      .match-detail-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.9);
        z-index: 1000;
        display: none;
        overflow-y: auto;
      }
      
      .match-detail-modal.active {
        display: block;
      }
      
      .match-detail-content {
        max-width: 1000px;
        margin: 20px auto;
        padding: 0 20px 40px;
      }
      
      .match-detail-header {
        background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
        border-radius: 16px;
        padding: 24px;
        margin-bottom: 20px;
        position: relative;
      }
      
      .match-detail-close {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        background: rgba(255,255,255,0.2);
        color: white;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .match-detail-title {
        text-align: center;
        margin-bottom: 20px;
      }
      
      .match-detail-vs {
        font-size: 14px;
        opacity: 0.8;
        margin-bottom: 8px;
      }
      
      .match-detail-names {
        font-size: 22px;
        font-weight: 800;
      }
      
      .match-detail-score {
        text-align: center;
        font-size: 36px;
        font-weight: 800;
        color: white;
        margin-top: 16px;
      }
      
      /* Scorecard Table in Modal */
      .match-scorecard {
        background: rgba(255,255,255,0.05);
        border-radius: 12px;
        overflow-x: auto;
        border: 1px solid rgba(255,255,255,0.1);
      }
      
      .match-scorecard table {
        width: 100%;
        min-width: 800px;
        border-collapse: collapse;
      }
      
      .match-scorecard th,
      .match-scorecard td {
        padding: 12px 8px;
        text-align: center;
        font-size: 14px;
        border-bottom: 1px solid rgba(255,255,255,0.1);
      }
      
      .match-scorecard th {
        background: rgba(0,0,0,0.3);
        font-weight: 700;
        color: rgba(255,255,255,0.7);
        font-size: 12px;
      }
      
      .match-scorecard th:first-child,
      .match-scorecard td:first-child {
        text-align: left;
        padding-left: 16px;
        position: sticky;
        left: 0;
        background: #1e293b;
        z-index: 1;
      }
      
      .match-scorecard .player-name-cell {
        font-weight: 600;
        color: white;
        white-space: nowrap;
      }
      
      .match-scorecard .hcp-cell {
        font-size: 12px;
        color: rgba(255,255,255,0.5);
      }
      
      .match-scorecard .score-won {
        background: rgba(16, 185, 129, 0.3);
        color: #10b981;
        font-weight: 700;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      
      .match-scorecard .score-lost {
        background: rgba(239, 68, 68, 0.3);
        color: #ef4444;
        font-weight: 700;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      
      .match-scorecard .score-halved {
        color: rgba(255,255,255,0.6);
      }
      
      .match-status-row td {
        font-weight: 700;
        background: rgba(139, 92, 246, 0.2);
      }
      
      .match-status-row .home-up {
        color: #3b82f6;
      }
      
      .match-status-row .away-up {
        color: #ec4899;
      }
      
      .match-status-row .all-square {
        color: rgba(255,255,255,0.5);
      }
      
      /* Match Play Leaderboard Container - Centered, Large Cards */
      .match-play-container {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 20px;
        max-width: 700px;
        margin: 0 auto;
      }
      
      .match-play-content {
        background: transparent;
      }
      
      .match-card {
        background: rgba(255,255,255,0.06);
        border-radius: 16px;
        padding: 0;
        cursor: pointer;
        transition: all 0.2s;
        border: 1px solid rgba(255,255,255,0.1);
        overflow: hidden;
      }
      
      .match-card:hover {
        background: rgba(255,255,255,0.1);
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      }
      
      .match-card.expanded {
        background: rgba(255,255,255,0.12);
      }
      
      .match-card.completed {
        opacity: 0.9;
      }
      
      .match-card.in-progress {
        border: 2px solid rgba(16, 185, 129, 0.5);
      }
      
      .match-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 16px;
        background: rgba(0,0,0,0.2);
        font-size: 12px;
        color: rgba(255,255,255,0.5);
      }
      
      .match-number {
        font-weight: 600;
      }
      
      .match-thru {
        font-size: 12px;
        color: rgba(255,255,255,0.6);
      }
      
      .match-body {
        padding: 16px 20px;
      }
      
      .match-teams {
        display: flex;
        align-items: center;
        gap: 16px;
      }
      
      .team-side {
        flex: 1;
        padding: 14px 16px;
        border-radius: 12px;
        background: rgba(0,0,0,0.25);
        min-width: 120px;
      }
      
      .team-side.home {
        text-align: left;
        border-left: 4px solid #ef4444;
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(0,0,0,0.25));
      }
      
      .team-side.away {
        text-align: right;
        border-right: 4px solid #3b82f6;
        background: linear-gradient(135deg, rgba(0,0,0,0.25), rgba(59, 130, 246, 0.15));
      }
      
      .team-label {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 6px;
        padding-bottom: 4px;
        border-bottom: 1px solid rgba(255,255,255,0.2);
      }
      
      .team-side.home .team-label {
        color: #f87171;
      }
      
      .team-side.away .team-label {
        color: #60a5fa;
      }
      
      .team-name {
        font-weight: 600;
        color: white;
        font-size: 14px;
        line-height: 1.6;
      }
      
      .team-name .player-name {
        display: block;
      }
      
      .match-status-arrow {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 6px;
        min-width: 90px;
      }
      
      .arrow-indicator {
        display: flex;
        flex-direction: row;
        align-items: center;
        animation: pulse-arrow 1.5s ease-in-out infinite;
      }
      
      .arrow-indicator svg {
        width: 40px;
        height: 40px;
      }
      
      .arrow-indicator.home-leading svg {
        fill: #ef4444;
      }
      
      .arrow-indicator.away-leading svg {
        fill: #3b82f6;
      }
      
      @keyframes pulse-arrow {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.6; transform: scale(1.1); }
      }
      
      .match-score-badge {
        background: rgba(255,255,255,0.15);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: 700;
        font-size: 14px;
        white-space: nowrap;
      }
      
      .match-score-badge.in-progress {
        background: rgba(255,255,255,0.15);
        color: white;
      }
      
      .match-score-badge.in-progress.home-leading {
        background: rgba(239, 68, 68, 0.3);
        color: #fca5a5;
      }
      
      .match-score-badge.in-progress.away-leading {
        background: rgba(59, 130, 246, 0.3);
        color: #93c5fd;
      }
      
      .match-score-badge.completed {
        background: rgba(139, 92, 246, 0.25);
        color: #c4b5fd;
      }
      
      .match-score-badge.completed.home-leading {
        background: rgba(239, 68, 68, 0.35);
        color: #fca5a5;
      }
      
      .match-score-badge.completed.away-leading {
        background: rgba(59, 130, 246, 0.35);
        color: #93c5fd;
      }
      
      .match-score-badge.not-started {
        background: rgba(255,255,255,0.08);
        color: rgba(255,255,255,0.4);
      }
      
      .match-thru-center {
        font-size: 11px;
        color: rgba(255,255,255,0.6);
        margin-top: 4px;
      }
      
      .match-final-label {
        font-size: 12px;
        font-weight: 700;
        padding: 4px 12px;
        border-radius: 12px;
        background: rgba(16, 185, 129, 0.25);
        color: #4ade80;
        margin-bottom: 6px;
      }
      
      /* Match Details Panel */
      .match-details-panel {
        grid-column: 1 / -1;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
        padding: 16px;
        margin-top: 12px;
        overflow-x: auto;
      }
      
      .match-details-empty {
        text-align: center;
        color: rgba(255,255,255,0.5);
        padding: 20px;
      }
      
      .hole-score-grid {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 700px;
      }
      
      .hole-header-row,
      .hole-par-row,
      .hole-score-row,
      .hole-result-row {
        display: grid;
        grid-template-columns: 80px repeat(18, 1fr);
        gap: 2px;
        align-items: center;
      }
      
      .hole-label {
        font-size: 11px;
        font-weight: 600;
        color: rgba(255,255,255,0.7);
        padding: 4px;
        position: sticky;
        left: 0;
        background: rgba(0,0,0,0.5);
        z-index: 1;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }
      
      .hole-num,
      .hole-par,
      .hole-score,
      .hole-result {
        text-align: center;
        font-size: 12px;
        padding: 6px 2px;
        border-radius: 4px;
      }
      
      .hole-num {
        font-weight: 700;
        color: rgba(255,255,255,0.5);
        background: rgba(255,255,255,0.05);
      }
      
      .hole-par {
        color: rgba(255,255,255,0.6);
      }
      
      .hole-score-row.home {
        background: rgba(59, 130, 246, 0.1);
      }
      
      .hole-score-row.away {
        background: rgba(236, 72, 153, 0.1);
      }
      
      .hole-score {
        font-weight: 600;
        color: white;
        background: rgba(255,255,255,0.1);
      }
      
      .hole-score.eagle { background: #fbbf24; color: #78350f; }
      .hole-score.birdie { background: #dc2626; color: white; }
      .hole-score.par { background: rgba(255,255,255,0.2); }
      .hole-score.bogey { background: #1e293b; }
      .hole-score.double { background: #3b82f6; }
      
      .hole-result {
        font-weight: 700;
      }
      
      .hole-result.home-won {
        background: rgba(59, 130, 246, 0.3);
        color: #3b82f6;
      }
      
      .hole-result.away-won {
        background: rgba(236, 72, 153, 0.3);
        color: #ec4899;
      }
      
      .hole-result.halved {
        color: rgba(255,255,255,0.4);
      }
      
      /* Responsive Match Play - Keep horizontal, just smaller */
      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }
        
        .match-play-container {
          padding: 10px;
          gap: 12px;
        }
        
        .match-card {
          border-radius: 12px;
        }
        
        .match-header {
          padding: 6px 12px;
          font-size: 11px;
        }
        
        .match-body {
          padding: 12px 14px;
        }
        
        .match-teams {
          gap: 10px;
        }
        
        .team-side {
          padding: 10px 12px;
          min-width: 0;
          border-radius: 10px;
        }
        
        .team-name {
          font-size: 13px;
          line-height: 1.3;
          word-wrap: break-word;
        }
        
        .match-status-arrow {
          min-width: 65px;
        }
        
        .match-score-badge {
          padding: 6px 12px;
          font-size: 12px;
        }
        
        .arrow-indicator {
          font-size: 14px;
        }
        
        .stats-bar {
          grid-template-columns: repeat(2, 1fr);
          gap: 8px;
          margin-bottom: 16px;
        }
        
        .stat-card {
          padding: 10px 12px;
        }
        
        .stat-value {
          font-size: 24px;
        }
        
        .stat-label {
          font-size: 10px;
        }
      }
      
      /* Even smaller for very small phones */
      @media (max-width: 400px) {
        .container {
          padding: 6px;
        }
        
        .match-play-container {
          padding: 6px;
        }
        
        .match-body {
          padding: 10px 10px;
        }
        
        .match-teams {
          gap: 6px;
        }
        
        .team-side {
          padding: 8px 10px;
        }
        
        .team-name {
          font-size: 11px;
        }
        
        .match-status-arrow {
          min-width: 55px;
        }
        
        .match-score-badge {
          padding: 5px 10px;
          font-size: 11px;
        }
        
        .arrow-indicator {
          font-size: 12px;
        }
      }

      /* Leaderboard Table */
      .leaderboard-wrapper {
        background: rgba(255,255,255,0.05);
        border-radius: 16px;
        overflow-x: auto;
        overflow-y: hidden;
        border: 1px solid rgba(255,255,255,0.1);
      }
      
      .leaderboard-table {
        width: 100%;
        min-width: 900px;
        border-collapse: collapse;
      }
      
      .leaderboard-table thead {
        background: rgba(0,0,0,0.3);
      }
      
      .leaderboard-table th {
        padding: 14px 16px;
        text-align: left;
        font-size: 12px;
        font-weight: 700;
        color: rgba(255,255,255,0.7);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .leaderboard-table th.center { text-align: center; }
      
      .leaderboard-table tbody tr {
        border-bottom: 1px solid rgba(255,255,255,0.05);
        transition: background 0.2s, transform 0.3s ease, opacity 0.3s ease;
      }
      
      .leaderboard-table tbody tr:hover {
        background: rgba(255,255,255,0.05);
      }
      
      .leaderboard-table tbody tr.highlight {
        background: rgba(16, 185, 129, 0.15);
        animation: highlight 2s ease-out;
      }
      
      @keyframes highlight {
        0% { background: rgba(16, 185, 129, 0.4); transform: scale(1.01); }
        100% { background: rgba(16, 185, 129, 0.15); transform: scale(1); }
      }
      
      .score-cell {
        transition: transform 0.3s ease, color 0.3s ease;
      }
      
      .leaderboard-table td {
        padding: 14px 16px;
        font-size: 15px;
      }
      
      .leaderboard-table td.center { text-align: center; }
      
      /* Position Cell */
      .position-cell {
        font-size: 18px;
        font-weight: 800;
        color: white;
        width: 50px;
      }
      
      .position-cell.top-3 { color: #fbbf24; }
      
      /* Player Cell */
      .player-cell {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .player-avatar {
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 14px;
      }
      
      .player-info {
        flex: 1;
      }
      
      .player-name {
        font-weight: 600;
        color: white;
        font-size: 15px;
      }
      
      .player-club {
        font-size: 12px;
        color: rgba(255,255,255,0.6);
      }
      
      /* Score Cells */
      .score-cell {
        font-weight: 700;
        font-size: 18px;
        text-align: center;
      }
      
      .score-cell.under-par { color: #ef4444; }
      .score-cell.even-par { color: white; }
      .score-cell.over-par { color: #94a3b8; }
      
      .thru-cell {
        font-size: 13px;
        color: rgba(255,255,255,0.6);
        text-align: center;
      }
      
      .thru-cell.finished {
        color: #10b981;
        font-weight: 600;
      }
      
      .round-score {
        font-size: 14px;
        color: rgba(255,255,255,0.8);
        text-align: center;
      }
      
      /* Team Leaderboard Styles */
      .team-header-row {
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .team-header-row:hover {
        filter: brightness(1.1);
      }
      
      .team-player-row {
        background: rgba(30, 41, 59, 0.5);
        border-left: 3px solid transparent;
      }
      
      .team-player-row[style*="rgba(34, 197, 94"] {
        border-left-color: #22c55e;
      }
      
      /* Movement Indicators */
      .movement {
        display: inline-flex;
        align-items: center;
        gap: 2px;
        font-size: 12px;
        font-weight: 600;
        margin-left: 8px;
      }
      
      .movement.up { color: #10b981; }
      .movement.down { color: #ef4444; }
      
      /* Hole by Hole */
      .hole-scores-container {
        display: flex;
        flex-direction: column;
        gap: 2px;
        align-items: center;
      }
      
      /* Desktop: show all 18 in one row, hide nine-holes */
      .nine-holes {
        display: none;
      }
      
      .hole-numbers-all,
      .hole-scores-all {
        display: flex;
        gap: 3px;
      }
      
      .hole-number {
        width: 28px;
        height: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        font-weight: 600;
        color: rgba(255,255,255,0.5);
      }
      
      .hole-scores {
        display: flex;
        gap: 3px;
      }
      
      .hole-score {
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 600;
        border-radius: 4px;
        background: rgba(255,255,255,0.1);
      }
      
      .hole-score.birdie { background: #dc2626; color: white; }
      .hole-score.eagle { background: #fbbf24; color: #78350f; }
      .hole-score.par { background: rgba(255,255,255,0.2); color: white; }
      .hole-score.bogey { background: #1e293b; color: white; }
      .hole-score.double { background: #3b82f6; color: white; }
      .hole-score.dnf { background: #6b7280; color: white; font-style: italic; }
      
      /* Holes column width - desktop */
      #holes-header {
        min-width: 560px;
      }
      
      /* Last Updated */
      .last-updated {
        text-align: center;
        padding: 16px;
        font-size: 12px;
        color: rgba(255,255,255,0.5);
      }
      
      /* Loading State */
      .loading {
        text-align: center;
        padding: 60px 20px;
        color: rgba(255,255,255,0.6);
      }
      
      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid rgba(255,255,255,0.1);
        border-top-color: #10b981;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
      }
      
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      /* No Data */
      .no-data {
        text-align: center;
        padding: 60px 20px;
        color: rgba(255,255,255,0.6);
      }
      
      .no-data-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }
      
      /* Tournament Selector (for non-direct links) */
      .tournament-selector {
        background: rgba(255,255,255,0.1);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 24px;
      }
      
      .tournament-selector label {
        display: block;
        font-size: 12px;
        font-weight: 600;
        color: rgba(255,255,255,0.7);
        margin-bottom: 8px;
        text-transform: uppercase;
      }
      
      .tournament-selector select {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid rgba(255,255,255,0.2);
        border-radius: 8px;
        background: rgba(0,0,0,0.3);
        color: white;
        font-size: 15px;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
      }
      
      .tournament-selector select:focus {
        outline: none;
        border-color: #10b981;
      }
      
      /* Footer */
      .footer {
        text-align: center;
        padding: 24px;
        color: rgba(255,255,255,0.4);
        font-size: 12px;
      }
      
      .footer a {
        color: #10b981;
        text-decoration: none;
      }
      
      /* Responsive */
      @media (max-width: 768px) {
        .tournament-name { font-size: 20px; }
        .live-indicator { position: static; margin-top: 12px; display: inline-flex; }
        
        .leaderboard-table th,
        .leaderboard-table td {
          padding: 10px 8px;
        }
        
        .player-avatar { display: none; }
        .hole-scores-container {
          display: flex;
          flex-direction: column;
          gap: 6px;
          align-items: center;
        }
        /* Mobile: hide all-18 rows, show front/back nine */
        .hole-numbers-all,
        .hole-scores-all {
          display: none !important;
        }
        .nine-holes {
          display: flex;
          flex-direction: column;
          gap: 1px;
        }
        .hole-numbers {
          display: flex;
          gap: 2px;
        }
        .hole-number {
          width: 22px;
          height: 12px;
          font-size: 8px;
        }
        .hole-scores { 
          display: flex;
          gap: 2px;
        }
        .hole-score {
          width: 22px;
          height: 22px;
          font-size: 10px;
        }
        /* Holes column width - mobile */
        #holes-header {
          min-width: 220px;
        }
      }
      
      /* ========================================
         TEAM STANDINGS STYLES
         ======================================== */
      
      .team-standings-container {
        background: white;
        border-radius: 16px;
        padding: 24px;
        max-width: 900px;
        margin: 0 auto;
        box-shadow: 0 4px 24px rgba(0,0,0,0.1);
      }
      
      .team-standings-title {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 22px;
        font-weight: 700;
        color: #1e293b;
        margin-bottom: 20px;
      }
      
      .team-standings-title .trophy {
        font-size: 24px;
      }
      
      .team-standings-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }
      
      .team-standings-table th {
        padding: 12px 16px;
        text-align: left;
        font-weight: 600;
        color: #64748b;
        border-bottom: 2px solid #e2e8f0;
        font-size: 13px;
      }
      
      .team-standings-table th.center {
        text-align: center;
      }
      
      .team-standings-table td {
        padding: 16px;
        border-bottom: 1px solid #e2e8f0;
        color: #334155;
      }
      
      .team-standings-table td.center {
        text-align: center;
      }
      
      .team-standings-table tr:last-child td {
        border-bottom: none;
      }
      
      .team-standings-table .rank {
        font-weight: 700;
        color: #10b981;
        font-size: 16px;
      }
      
      .team-standings-table .team-name {
        font-weight: 600;
        color: #1e293b;
        font-size: 15px;
      }
      
      .team-standings-table .won {
        color: #10b981;
        font-weight: 600;
      }
      
      .team-standings-table .lost {
        color: #ef4444;
        font-weight: 600;
      }
      
      .team-standings-table .points {
        font-weight: 700;
        font-size: 16px;
        color: #1e293b;
      }
      
      .team-standings-table .diff-positive {
        color: #10b981;
        font-weight: 600;
      }
      
      .team-standings-table .diff-negative {
        color: #ef4444;
        font-weight: 600;
      }
      
      .team-standings-note {
        font-size: 12px;
        color: #94a3b8;
        margin-top: 16px;
        font-style: italic;
      }
      
      /* Expandable team row */
      .team-standings-table .team-row {
        cursor: pointer;
        transition: background 0.2s;
      }
      
      .team-standings-table .team-row:hover {
        background: #f8fafc;
      }
      
      .team-standings-table .team-row.expanded {
        background: #f1f5f9;
      }
      
      .team-standings-table .team-name-cell {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .team-standings-table .expand-icon {
        font-size: 10px;
        color: #94a3b8;
        transition: transform 0.2s;
      }
      
      .team-standings-table .team-row.expanded .expand-icon {
        transform: rotate(90deg);
      }
      
      /* Breakdown row */
      .team-standings-table .breakdown-row {
        display: none;
        background: #f8fafc;
      }
      
      .team-standings-table .breakdown-row.visible {
        display: table-row;
      }
      
      .team-standings-table .breakdown-row td {
        padding: 0 16px 16px 16px;
        border-bottom: 1px solid #e2e8f0;
      }
      
      .breakdown-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 12px;
        color: #64748b;
      }
      
      .breakdown-item {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 8px 12px;
        background: white;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
      }
      
      .breakdown-item .breakdown-label {
        font-weight: 600;
        min-width: 90px;
        color: #475569;
      }
      
      .breakdown-item.confirmed .breakdown-label {
        color: #10b981;
      }
      
      .breakdown-item.in-progress .breakdown-label {
        color: #f59e0b;
      }
      
      .breakdown-stats {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
      }
      
      .breakdown-stat {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      
      .breakdown-stat-label {
        color: #94a3b8;
      }
      
      .breakdown-stat-value {
        font-weight: 600;
        color: #334155;
      }
      
      .breakdown-stat-value.won { color: #10b981; }
      .breakdown-stat-value.lost { color: #ef4444; }
      .breakdown-stat-value.points { color: #1e293b; font-weight: 700; }
      
      @media (max-width: 600px) {
        .team-standings-container {
          padding: 16px;
          margin: 0 8px;
        }
        
        .team-standings-table th,
        .team-standings-table td {
          padding: 10px 8px;
          font-size: 12px;
        }
        
        .team-standings-title {
          font-size: 18px;
        }
        
        .breakdown-item {
          flex-direction: column;
          align-items: flex-start;
          gap: 8px;
        }
        
        .breakdown-stats {
          gap: 12px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Header -->
    <div class="header">
      <div class="header-content">
        <div class="tournament-name" id="tournament-name">Live Leaderboard</div>
        <div class="tournament-info" id="tournament-info">Loading tournament...</div>
        <div class="live-indicator">
          <span class="live-dot"></span>
          LIVE
        </div>
      </div>
    </div>

    <div class="container">
      <!-- Tournament Selector (shown when no tournamentId in URL) -->
      <div class="tournament-selector" id="tournament-selector" style="display: none;">
        <label>Select Tournament</label>
        <select id="tournament-select" onchange="selectTournament(this.value)">
          <option value="">-- Choose a tournament --</option>
        </select>
      </div>

      <!-- Stats Bar -->
      <div class="stats-bar" id="stats-bar" style="display: none;">
        <div class="stat-card">
          <div class="stat-value" id="stat-leader">-</div>
          <div class="stat-label">Leader Score</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="stat-players">0</div>
          <div class="stat-label">Players</div>
        </div>
        <div class="stat-card">
          <div class="stat-value yellow" id="stat-scoring">0</div>
          <div class="stat-label">On Course</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="stat-finished">0</div>
          <div class="stat-label">Finished</div>
        </div>
      </div>

      <!-- Category Tabs -->
      <div class="category-tabs" id="category-tabs" style="display: none;">
        <button class="category-tab active" data-category="ALL">All Players</button>
      </div>

      <!-- Leaderboard -->
      <div class="leaderboard-wrapper" id="leaderboard-wrapper" style="display: none;">
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th style="width: 50px;">Pos</th>
              <th>Player</th>
              <th class="center" style="width: 80px;" id="score-header">To Par</th>
              <th class="center" style="width: 60px;">Thru</th>
              <th class="center" style="width: 70px;" id="today-header">Today</th>
              <th class="center" style="width: 70px;" id="total-header">Total</th>
              <th class="center" id="holes-header">Holes</th>
            </tr>
          </thead>
          <tbody id="leaderboard-body">
          </tbody>
        </table>
        <div class="last-updated" id="last-updated">Last updated: --</div>
      </div>

      <!-- Loading State -->
      <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div>Loading leaderboard...</div>
      </div>

      <!-- No Data -->
      <div class="no-data" id="no-data" style="display: none;">
        <div class="no-data-icon">⛳</div>
        <div>No scores available yet</div>
        <div style="margin-top: 8px; font-size: 13px;">Scores will appear here once players start</div>
      </div>
      
      <!-- Team Standings -->
      <div id="team-standings-wrapper" style="display: none;"></div>
    </div>

    <!-- Footer -->
    <div class="footer">
      Powered by <a href="#">GTM - Golf Tournament Management</a><br>
      Updates in real-time
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>

    <script>
      // State
      let currentTournament = null;
      let currentRoundId = null;
      let currentRoundIndex = 0; // Index of current round (0-based)
      let currentCategory = 'ALL';
      let liveScores = {};
      let officialScores = {}; // Official scores from scores page - these take precedence
      let previousRoundsScores = {}; // Scores from previous rounds for multi-day tournaments: { playerKey: { gross: X, net: Y, toPar: Z } }
      let admittedPlayers = [];
      let courseData = null;
      let previousPositions = {};
      let firebaseListener = null;
      let settingsListener = null;
      let isLiveScoringActive = true;
      let isLeaderboardVisible = true;
      let isMultiRoundTournament = false;
      
      // Match play state
      let isMatchPlay = false;
      let matchPlayFormat = 'singles'; // singles, fourball, foursome
      let liveMatchScores = {};
      let drawData = null;
      
      // Detect if tournament is match play
      function detectMatchPlay() {
        if (!currentTournament) {
          isMatchPlay = false;
          return;
        }
        
        const type = (currentTournament.type || '').toLowerCase();
        isMatchPlay = type.includes('match');
        
        if (isMatchPlay) {
          // Check multiple possible locations for game format
          matchPlayFormat = currentTournament.gameFormat || 
                           currentTournament.meta?.gameFormat ||
                           currentTournament.matchType ||
                           currentTournament.meta?.matchType ||
                           'singles';
          
          // If type contains "teams" or teamsTournament is yes, it's likely fourball
          const isTeamsTournament = currentTournament.meta?.teamsTournament === 'yes' || 
                                    type.includes('teams');
          
          // If we have team pairings defined, it's a team format (fourball/foursome)
          const hasTeamPairings = currentTournament.teamPairings && 
                                  Object.keys(currentTournament.teamPairings).length > 0;
          
          // Override to fourball if it's a teams tournament with pairings but format is still singles
          if (matchPlayFormat === 'singles' && (isTeamsTournament || hasTeamPairings)) {
            matchPlayFormat = 'fourball';
          }
          
          // Normalize the format value
          matchPlayFormat = matchPlayFormat.toLowerCase();
          if (matchPlayFormat === 'foursomes') matchPlayFormat = 'foursome';
          
          console.log('Match play detected - format:', matchPlayFormat);
        } else {
          matchPlayFormat = 'singles';
        }
      }

      // Initialize
      document.addEventListener('DOMContentLoaded', async function() {
        console.log('=== Live Leaderboard Initializing ===');
        
        // Wait for Firebase
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (typeof initFirebase === 'function') {
          initFirebase();
          console.log('Firebase initialized');
        }
        
        // Check URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const tournamentId = urlParams.get('tournamentId');
        const roundId = urlParams.get('roundId');
        
        console.log('URL params - tournamentId:', tournamentId, 'roundId:', roundId);
        
        if (tournamentId) {
          await loadTournament(tournamentId, roundId);
        } else {
          // Show tournament selector
          await loadTournamentList();
        }
      });

      // Load tournament list
      async function loadTournamentList() {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('tournament-selector').style.display = 'block';
        
        // Try to load from Firebase
        let tournaments = [];
        
        if (db) {
          try {
            const snapshot = await db.ref('tournaments').once('value');
            const data = snapshot.val();
            if (data) {
              tournaments = Object.values(data);
            }
          } catch (e) {
            console.error('Firebase load error:', e);
          }
        }
        
        // Fall back to localStorage
        if (tournaments.length === 0) {
          tournaments = JSON.parse(localStorage.getItem('tournaments') || '[]');
        }
        
        // Sort by date descending
        tournaments.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        const select = document.getElementById('tournament-select');
        tournaments.forEach(t => {
          const option = document.createElement('option');
          option.value = t.tournamentId;
          option.textContent = `${t.name} (${t.date || 'No date'})`;
          select.appendChild(option);
        });
      }

      // Select tournament from dropdown
      function selectTournament(tournamentId) {
        if (!tournamentId) return;
        
        // Update URL
        const url = new URL(window.location);
        url.searchParams.set('tournamentId', tournamentId);
        window.history.pushState({}, '', url);
        
        loadTournament(tournamentId);
      }

      // Change round from dropdown
      function changeRound(roundId) {
        if (!roundId) return;
        currentRoundId = roundId;
        
        // Update URL
        const url = new URL(window.location);
        url.searchParams.set('roundId', roundId);
        window.history.pushState({}, '', url);
        
        // Reload scores for new round
        loadLiveScores().then(() => {
          renderLeaderboard();
        });
      }

      // Load tournament data
      async function loadTournament(tournamentId, roundId) {
        console.log('loadTournament called with:', tournamentId, roundId);
        document.getElementById('loading').style.display = 'block';
        document.getElementById('tournament-selector').style.display = 'none';
        
        try {
          // Load tournament
          let tournaments = [];
          
          if (db) {
            try {
              const snapshot = await db.ref('tournaments').once('value');
              const data = snapshot.val();
              if (data) {
                tournaments = Object.values(data);
              }
            } catch (e) {
              console.error('Firebase error:', e);
            }
          }
          
          if (tournaments.length === 0) {
            tournaments = JSON.parse(localStorage.getItem('tournaments') || '[]');
          }
          
          currentTournament = tournaments.find(t => t.tournamentId === tournamentId);
          
          if (!currentTournament) {
            throw new Error('Tournament not found');
          }
          
          // Detect match play tournament
          detectMatchPlay();
          
          // Set round - use URL param, or default to FIRST round (not last)
          const roundIds = currentTournament.meta?.roundIds || [tournamentId + '-1'];
          currentRoundId = roundId || roundIds[0]; // Default to first round
          
          // Determine round index for multi-round support
          currentRoundIndex = roundIds.indexOf(currentRoundId);
          if (currentRoundIndex === -1) currentRoundIndex = 0;
          isMultiRoundTournament = roundIds.length > 1;
          
          console.log('Multi-round tournament:', isMultiRoundTournament, '| Current round:', currentRoundIndex + 1, 'of', roundIds.length);
          
          // Update header with round selector if multiple rounds
          document.getElementById('tournament-name').textContent = currentTournament.name;
          
          if (roundIds.length > 1) {
            let roundSelector = `<select id="round-selector-dropdown" onchange="changeRound(this.value)" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; font-size: 13px; cursor: pointer;">`;
            roundIds.forEach((rid, idx) => {
              roundSelector += `<option value="${rid}" ${rid === currentRoundId ? 'selected' : ''} style="color: black;">Round ${idx + 1}</option>`;
            });
            roundSelector += `</select>`;
            document.getElementById('tournament-info').innerHTML = 
              `${currentTournament.date || ''} • ${roundSelector}`;
          } else {
            document.getElementById('tournament-info').textContent = 
              `${currentTournament.date || ''} • Round 1`;
          }
          
          // Load course data
          await loadCourseData();
          
          // Load admitted players
          await loadAdmittedPlayers();
          
          // Load categories
          loadCategories();
          
          // Load live scores and setup listener
          await loadLiveScores();
          setupFirebaseListener();
          
          // Show UI
          document.getElementById('loading').style.display = 'none';
          document.getElementById('stats-bar').style.display = 'grid';
          document.getElementById('leaderboard-wrapper').style.display = 'block';
          
          // Render leaderboard
          renderLeaderboard();
          
        } catch (error) {
          console.error('Error loading tournament:', error);
          document.getElementById('loading').innerHTML = `
            <div style="color: #ef4444;">Error loading tournament</div>
            <div style="margin-top: 8px; font-size: 13px;">${error.message}</div>
          `;
        }
      }

      // Load course data
      async function loadCourseData() {
        let courses = [];
        
        if (db) {
          try {
            const snapshot = await db.ref('courses').once('value');
            courses = snapshot.val() || [];
          } catch (e) {}
        }
        
        if (!courses.length) {
          courses = JSON.parse(localStorage.getItem('courses') || '[]');
        }
        
        const courseId = currentTournament.meta?.courses?.[0] || currentTournament.courseId;
        courseData = courses.find(c => c.id === courseId || c.name === courseId);
      }

      // Load admitted players
      async function loadAdmittedPlayers() {
        console.log('=== Loading admitted players ===');
        console.log('Looking for roundId:', currentRoundId);
        
        // Try Firebase FIRST for cross-device sync
        if (db) {
          try {
            const snapshot = await db.ref('admittedPlayers').once('value');
            const firebaseData = snapshot.val() || {};
            console.log('Firebase admittedPlayers keys:', Object.keys(firebaseData));
            
            // Try exact match first
            if (firebaseData[currentRoundId] && Array.isArray(firebaseData[currentRoundId])) {
              admittedPlayers = firebaseData[currentRoundId];
              console.log('Found admitted players in Firebase (exact match):', admittedPlayers.length);
            } else {
              // Try alternative key formats
              for (const key of Object.keys(firebaseData)) {
                if (key.includes(currentTournament?.tournamentId) || 
                    currentRoundId.includes(key) || 
                    key.includes(currentRoundId)) {
                  if (Array.isArray(firebaseData[key])) {
                    admittedPlayers = firebaseData[key];
                    console.log('Found admitted players in Firebase (partial match):', key, admittedPlayers.length);
                    break;
                  }
                }
              }
            }
          } catch (e) {
            console.error('Firebase admitted players error:', e);
          }
        }
        
        // Fallback to localStorage if Firebase didn't have data
        if (admittedPlayers.length === 0) {
          let admittedData = JSON.parse(localStorage.getItem('admittedPlayers') || '{}');
          console.log('localStorage admittedPlayers keys:', Object.keys(admittedData));
          
          admittedPlayers = admittedData[currentRoundId] || [];
          console.log('Admitted players from localStorage (exact):', admittedPlayers.length);
          
          // Try alternative roundId format
          if (admittedPlayers.length === 0) {
            for (const key of Object.keys(admittedData)) {
              if (key.includes(currentTournament?.tournamentId) || 
                  currentRoundId.includes(key) || 
                  key.includes(currentRoundId)) {
                admittedPlayers = admittedData[key];
                console.log('Found admitted players in localStorage (partial match):', key, admittedPlayers.length);
                break;
              }
            }
          }
        }
        
        console.log('Final admitted players count:', admittedPlayers.length);
        if (admittedPlayers.length > 0) {
          console.log('Sample player:', admittedPlayers[0]);
        }
      }

      // Get teams from tournament
      function getTeams() {
        if (!currentTournament) return [];
        
        // Teams are stored in tournament.teamsByRound
        const teamsByRound = currentTournament.teamsByRound || {};
        const roundKeys = Object.keys(teamsByRound);
        
        if (roundKeys.length > 0) {
          // Return teams from the first round (usually round 0)
          return teamsByRound[roundKeys[0]] || [];
        }
        
        // Fallback to legacy teams array
        if (currentTournament.teams && currentTournament.teams.length > 0) {
          return currentTournament.teams;
        }
        
        return [];
      }

      // Check if current view should show team leaderboard
      function isTeamLeaderboardView() {
        return currentTournament?.meta?.teamsTournament === 'yes' && currentCategory === 'TEAM';
      }

      // Load categories
      function loadCategories() {
        // For match play, show simplified tabs
        if (isMatchPlay) {
          const tabsContainer = document.getElementById('category-tabs');
          tabsContainer.innerHTML = `
            <button class="category-tab active" data-category="MATCHPLAY" onclick="selectCategory('MATCHPLAY')">Matches</button>
            <button class="category-tab" data-category="TEAM_STANDINGS" onclick="selectCategory('TEAM_STANDINGS')">Team Standings</button>
          `;
          tabsContainer.style.display = 'flex';
          currentCategory = 'MATCHPLAY';
          
          // Hide table header for match play - we don't need MATCH/HOME/STATUS/AWAY/THRU headers
          const thead = document.querySelector('.leaderboard-table thead');
          if (thead) {
            thead.style.display = 'none';
          }
          return;
        }
        
        // Check both direct categories and meta.categories
        const categories = currentTournament.categories || currentTournament.meta?.categories || [];
        const tabsContainer = document.getElementById('category-tabs');
        
        console.log('Loading categories from tournament:', currentTournament);
        console.log('Tournament categories:', currentTournament.categories);
        console.log('Meta categories:', currentTournament.meta?.categories);
        console.log('Final categories array:', categories);
        
        if (categories.length === 0) {
          console.log('No categories found - hiding tabs');
          tabsContainer.style.display = 'none';
          return;
        }
        
        let html = '<button class="category-tab active" data-category="ALL" onclick="selectCategory(\'ALL\')">All Players</button>';
        
        categories.forEach(cat => {
          // Handle both object format {code, name} and string format
          const code = cat.code || cat;
          const name = cat.name || cat;
          console.log('Adding category tab:', code, name);
          html += `<button class="category-tab" data-category="${code}" onclick="selectCategory('${code}')">${name}</button>`;
        });
        
        tabsContainer.innerHTML = html;
        tabsContainer.style.display = 'flex';
      }

      // Select category
      function selectCategory(category) {
        currentCategory = category;
        
        // Update tabs
        document.querySelectorAll('.category-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.category === category);
        });
        
        // Handle Team Standings view for match play
        if (category === 'TEAM_STANDINGS') {
          document.getElementById('leaderboard-wrapper').style.display = 'none';
          document.getElementById('no-data').style.display = 'none';
          document.getElementById('team-standings-wrapper').style.display = 'block';
          renderTeamStandings();
          return;
        } else {
          document.getElementById('team-standings-wrapper').style.display = 'none';
          if (isMatchPlay) {
            document.getElementById('leaderboard-wrapper').style.display = 'block';
          }
        }
        
        // Update column headers based on scoring format
        updateColumnHeaders();
        
        renderLeaderboard();
      }
      
      // Update column headers for scoring format
      function updateColumnHeaders() {
        const useStableford = isStablefordScoring();
        const useNet = isNetScoring();
        const isTeamView = isTeamLeaderboardView();
        
        const scoreHeader = document.getElementById('score-header');
        const todayHeader = document.getElementById('today-header');
        const totalHeader = document.getElementById('total-header');
        const holesHeader = document.getElementById('holes-header');
        
        // Find the table header row to modify for team view
        const thead = document.querySelector('.leaderboard-table thead tr');
        
        if (isTeamView) {
          // Team view: simpler columns
          if (thead) {
            const teamScoresCount = parseInt(currentTournament?.meta?.teamScoresCount) || 3;
            thead.innerHTML = `
              <th style="width: 50px;">Pos</th>
              <th>Team / Player</th>
              <th class="center" style="width: 60px;">Thru</th>
              <th class="center" style="width: 80px;">Points</th>
            `;
          }
          return;
        }
        
        // Reset to normal player view headers
        if (thead && thead.children.length < 6) {
          thead.innerHTML = `
            <th style="width: 50px;">Pos</th>
            <th>Player</th>
            <th class="center" style="width: 80px;" id="score-header">To Par</th>
            <th class="center" style="width: 60px;">Thru</th>
            <th class="center" style="width: 70px;" id="today-header">Today</th>
            <th class="center" style="width: 70px;" id="total-header">Total</th>
            <th class="center" id="holes-header">Holes</th>
          `;
        }
        
        // Re-get elements after potential reset
        const newScoreHeader = document.getElementById('score-header');
        const newTodayHeader = document.getElementById('today-header');
        const newTotalHeader = document.getElementById('total-header');
        
        if (newScoreHeader) {
          if (useStableford) {
            newScoreHeader.textContent = 'Points';
          } else if (useNet) {
            newScoreHeader.textContent = 'Net';
          } else {
            newScoreHeader.textContent = 'To Par';
          }
        }
        if (newTodayHeader) {
          if (useStableford) {
            newTodayHeader.textContent = 'Pts';
          } else if (useNet) {
            newTodayHeader.textContent = 'Net';
          } else {
            newTodayHeader.textContent = 'Today';
          }
        }
        if (newTotalHeader) {
          if (useStableford) {
            newTotalHeader.textContent = 'Total Pts';
          } else if (useNet) {
            newTotalHeader.textContent = 'Net Total';
          } else {
            newTotalHeader.textContent = 'Total';
          }
        }
      }
      
      // Get the scoring format for the current category
      function getCurrentScoringFormat() {
        if (currentCategory === 'ALL') {
          // Default to stroke play for "All Players" view
          return 'Stroke Play';
        }
        
        // Check both direct categories and meta.categories (same as loadCategories)
        const categories = currentTournament?.categories || currentTournament?.meta?.categories || [];
        const category = categories.find(c => (c.code || c) === currentCategory);
        
        return category?.tournamentType || 'Stroke Play';
      }
      
      // Check if current category uses Stableford scoring
      function isStablefordScoring() {
        const format = getCurrentScoringFormat();
        return format.toLowerCase().includes('stableford');
      }
      
      // Check if current category uses Net scoring (Medal Net, Stroke Play Net, etc.)
      function isNetScoring() {
        const format = getCurrentScoringFormat();
        return format.toLowerCase().includes('net');
      }
      
      // Calculate Stableford points for a single hole
      function calculateStablefordPoints(grossScore, par, strokesReceived) {
        if (!grossScore || grossScore === null) return 0;
        
        // Net score = gross - strokes received on this hole
        const netScore = grossScore - strokesReceived;
        
        // Stableford points based on net score vs par
        const diff = netScore - par;
        
        if (diff <= -3) return 5;      // Albatross or better
        if (diff === -2) return 4;     // Eagle
        if (diff === -1) return 3;     // Birdie
        if (diff === 0) return 2;      // Par
        if (diff === 1) return 1;      // Bogey
        return 0;                       // Double bogey or worse
      }

      // Load live scores
      async function loadLiveScores() {
        console.log('Loading scores for round:', currentRoundId);
        
        // First, load from localStorage
        const scoresData = JSON.parse(localStorage.getItem('scores') || '{}');
        console.log('All localStorage score keys:', Object.keys(scoresData));
        
        liveScores = scoresData[currentRoundId] || {};
        console.log('Local scores found:', Object.keys(liveScores).length);
        
        // Try alternative roundId formats if no scores found
        if (Object.keys(liveScores).length === 0) {
          // Try without prefix (T0003-1 instead of KLA-T0003-1)
          for (const key of Object.keys(scoresData)) {
            if (key.endsWith(currentRoundId) || currentRoundId.endsWith(key) || 
                key.includes(currentRoundId.replace(/^[A-Z]+-/, '')) ||
                currentRoundId.includes(key.replace(/^[A-Z]+-/, ''))) {
              console.log('Found scores with matching key:', key);
              liveScores = scoresData[key];
              break;
            }
          }
        }
        
        // Then try Firebase
        if (!db || !currentRoundId) return;
        
        try {
          // Check live settings first
          const settingsSnapshot = await db.ref(`liveSettings/${currentRoundId}`).once('value');
          const settings = settingsSnapshot.val();
          isLiveScoringActive = settings?.active !== false; // Default to true if not set
          isLeaderboardVisible = settings?.leaderboardVisible !== false; // Default to true if not set
          updateLiveIndicator();
          
          // Load official scores (from scores page) first - these take precedence
          // Scores are stored at path 'scores' as an object with roundId keys
          const officialSnapshot = await db.ref('scores').once('value');
          const allOfficialScores = officialSnapshot.val() || {};
          officialScores = allOfficialScores[currentRoundId] || {};
          console.log('Firebase official scores:', Object.keys(officialScores).length, 'for round', currentRoundId);
          
          // Try liveScores path for real-time data
          let snapshot = await db.ref(`liveScores/${currentRoundId}`).once('value');
          const firebaseLiveScores = snapshot.val() || {};
          console.log('Firebase liveScores:', Object.keys(firebaseLiveScores).length);
          
          // Merge scores - official scores take precedence over live scores
          for (const playerId in firebaseLiveScores) {
            // Only use live scores if no official scores exist for this player
            if (!hasCompleteOfficialScores(playerId)) {
              liveScores[playerId] = firebaseLiveScores[playerId];
            }
          }
          
          // Apply official scores on top (they always take precedence)
          for (const playerId in officialScores) {
            if (hasCompleteOfficialScores(playerId)) {
              liveScores[playerId] = officialScores[playerId];
            }
          }
          
          console.log('Total scores after merge:', Object.keys(liveScores).length);
          
          // Load previous round scores for multi-day aggregate tournaments
          if (isMultiRoundTournament && currentRoundIndex > 0) {
            await loadPreviousRoundsScores(allOfficialScores);
          }
        } catch (error) {
          console.error('Error loading scores from Firebase:', error);
        }
      }
      
      // Load scores from previous rounds for multi-day tournaments
      async function loadPreviousRoundsScores(allScoresData) {
        if (!currentTournament || !isMultiRoundTournament || currentRoundIndex === 0) {
          previousRoundsScores = {};
          return;
        }
        
        console.log('=== Loading previous rounds scores ===');
        
        const roundIds = currentTournament.meta?.roundIds || [];
        previousRoundsScores = {};
        
        // Get all scores data (either passed in or load fresh)
        let allScores = allScoresData;
        if (!allScores) {
          // Load from localStorage first
          allScores = JSON.parse(localStorage.getItem('scores') || '{}');
          
          // Also try Firebase
          if (db) {
            try {
              const snapshot = await db.ref('scores').once('value');
              allScores = snapshot.val() || allScores;
            } catch (e) {
              console.error('Error loading scores from Firebase:', e);
            }
          }
        }
        
        // Calculate cumulative scores from all previous rounds
        for (let i = 0; i < currentRoundIndex; i++) {
          const prevRoundId = roundIds[i];
          const prevRoundScores = allScores[prevRoundId] || {};
          
          console.log(`Processing round ${i + 1} (${prevRoundId}):`, Object.keys(prevRoundScores).length, 'players');
          
          for (const playerKey in prevRoundScores) {
            const playerData = prevRoundScores[playerKey];
            
            // Skip players with DQ/NS/NR status
            if (playerData.status && ['DQ', 'NS', 'NR', 'WD'].includes(playerData.status)) {
              continue;
            }
            
            if (!playerData.holes) continue;
            
            // Calculate gross and net for this round
            const holes = playerData.holes;
            let roundGross = 0;
            let roundNet = 0;
            let roundToPar = 0;
            let roundStableford = 0;
            let holesPlayed = 0;
            
            for (let h = 0; h < 18; h++) {
              if (holes[h] && holes[h] !== '' && holes[h] !== null) {
                const score = holes[h] === 'X' ? 10 : parseInt(holes[h]) || 0; // Use 10 for X (DNF)
                roundGross += score;
                holesPlayed++;
              }
            }
            
            // Get net and stableford from stored data if available
            if (playerData.points) {
              roundNet = playerData.points.reduce((sum, p) => sum + (parseInt(p) || 0), 0);
            }
            if (playerData.stablefordPoints) {
              roundStableford = playerData.stablefordPoints.reduce((sum, p) => sum + (parseInt(p) || 0), 0);
            }
            
            // Calculate to par (assuming course par 72 if not available)
            const coursePar = 72; // Default, will be overridden if course data available
            roundToPar = roundGross - coursePar;
            
            // Add to cumulative previous rounds
            if (!previousRoundsScores[playerKey]) {
              previousRoundsScores[playerKey] = {
                gross: 0,
                net: 0,
                toPar: 0,
                stableford: 0,
                rounds: 0
              };
            }
            
            previousRoundsScores[playerKey].gross += roundGross;
            previousRoundsScores[playerKey].net += roundNet;
            previousRoundsScores[playerKey].toPar += roundToPar;
            previousRoundsScores[playerKey].stableford += roundStableford;
            previousRoundsScores[playerKey].rounds++;
          }
        }
        
        console.log('Previous rounds scores calculated for', Object.keys(previousRoundsScores).length, 'players');
        
        // Debug: Show some sample data
        const samplePlayers = Object.keys(previousRoundsScores).slice(0, 3);
        samplePlayers.forEach(pk => {
          console.log(`[Previous] ${pk}: gross=${previousRoundsScores[pk].gross}, toPar=${previousRoundsScores[pk].toPar > 0 ? '+' : ''}${previousRoundsScores[pk].toPar}, rounds=${previousRoundsScores[pk].rounds}`);
        });
      }
      
      // Check if a player has complete official scores (18 holes or status like DQ/NS/NR)
      function hasCompleteOfficialScores(playerId) {
        const official = officialScores[playerId];
        if (!official || !official.holes) return false;
        
        // Check if player has 18 holes
        const completedHoles = official.holes.filter(s => s !== '' && s !== null && s !== undefined).length;
        if (completedHoles === 18) return true;
        
        // Check if player has a status (DQ, NS, NR, WD)
        if (official.status && ['DQ', 'NS', 'NR', 'WD'].includes(official.status)) return true;
        
        return false;
      }

      // Setup Firebase real-time listener
      function setupFirebaseListener() {
        if (firebaseListener) {
          firebaseListener();
        }
        if (settingsListener) {
          settingsListener();
        }
        
        if (!db || !currentRoundId) return;
        
        // Listen for live scores (stroke play)
        const liveScoresRef = db.ref(`liveScores/${currentRoundId}`);
        
        firebaseListener = liveScoresRef.on('value', (snapshot) => {
          const newScores = snapshot.val() || {};
          
          // Detect changes
          const changedPlayers = [];
          for (const key in newScores) {
            // Only apply live scores for players who don't have official scores
            if (!hasCompleteOfficialScores(key)) {
              if (!liveScores[key] || JSON.stringify(liveScores[key]) !== JSON.stringify(newScores[key])) {
                changedPlayers.push(key);
              }
              liveScores[key] = newScores[key];
            }
          }
          
          renderLeaderboard(changedPlayers);
        });
        
        // Also listen for official scores changes
        // Scores are stored at path 'scores' as an object with roundId keys
        const officialScoresRef = db.ref('scores');
        officialScoresRef.on('value', (snapshot) => {
          const allScores = snapshot.val() || {};
          const newOfficialScores = allScores[currentRoundId] || {};
          
          // Detect changes
          const changedPlayers = [];
          for (const key in newOfficialScores) {
            if (!officialScores[key] || JSON.stringify(officialScores[key]) !== JSON.stringify(newOfficialScores[key])) {
              changedPlayers.push(key);
            }
          }
          
          officialScores = newOfficialScores;
          
          // Apply official scores to liveScores (they take precedence)
          for (const playerId in officialScores) {
            if (hasCompleteOfficialScores(playerId)) {
              liveScores[playerId] = officialScores[playerId];
            }
          }
          
          if (changedPlayers.length > 0) {
            console.log('Official scores updated for:', changedPlayers);
            renderLeaderboard(changedPlayers);
          }
        });
        
        // Listen for match scores (match play)
        if (isMatchPlay) {
          const matchScoresRef = db.ref(`liveMatchScores/${currentRoundId}`);
          matchScoresRef.on('value', (snapshot) => {
            liveMatchScores = snapshot.val() || {};
            console.log('Live match scores updated:', liveMatchScores);
            renderLeaderboard();
          });
          
          // Load draw data for match info - try direct path first
          console.log('Loading draw data for roundId:', currentRoundId);
          const drawRef = db.ref(`draws/${currentRoundId}`);
          drawRef.once('value').then(snapshot => {
            drawData = snapshot.val();
            console.log('Draw data loaded from Firebase:', drawData);
            
            // If no draw data from Firebase, try alternative round ID format
            if (!drawData || !drawData.groups) {
              const altRoundId = currentRoundId.split('-').slice(-2).join('-');
              console.log('Trying alternative roundId for draws:', altRoundId);
              db.ref(`draws/${altRoundId}`).once('value').then(altSnapshot => {
                if (altSnapshot.val() && altSnapshot.val().groups) {
                  drawData = altSnapshot.val();
                  console.log('Draw data loaded with alt key:', drawData);
                }
                renderLeaderboard();
              });
            } else {
              renderLeaderboard();
            }
          });
        }
        
        // Listen for live settings (active/inactive)
        const settingsRef = db.ref(`liveSettings/${currentRoundId}`);
        
        settingsListener = settingsRef.on('value', (snapshot) => {
          const settings = snapshot.val();
          const wasActive = isLiveScoringActive;
          const wasVisible = isLeaderboardVisible;
          
          isLiveScoringActive = settings?.active !== false; // Default to true if not set
          isLeaderboardVisible = settings?.leaderboardVisible !== false; // Default to true if not set
          
          // Update the live indicator
          updateLiveIndicator();
          
          // Re-render if status changed
          if (wasActive !== isLiveScoringActive || wasVisible !== isLeaderboardVisible) {
            renderLeaderboard();
          }
        });
      }
      
      // Update the live indicator based on active status
      function updateLiveIndicator() {
        const indicator = document.querySelector('.live-indicator');
        if (!indicator) return;
        
        if (!isLeaderboardVisible) {
          indicator.innerHTML = '🚫 HIDDEN';
          indicator.style.background = 'rgba(100, 116, 139, 0.9)';
          indicator.style.animation = 'none';
        } else if (isLiveScoringActive) {
          indicator.innerHTML = '<div class="live-dot"></div> LIVE';
          indicator.style.background = 'rgba(239, 68, 68, 0.9)';
          indicator.style.animation = 'pulse 2s infinite';
        } else {
          indicator.innerHTML = '⏹ ENDED';
          indicator.style.background = 'rgba(100, 116, 139, 0.9)';
          indicator.style.animation = 'none';
        }
      }

      // Calculate player score
      function calculateScore(playerKey) {
        const scoreData = liveScores[playerKey];
        
        if (!scoreData || !scoreData.holes) {
          return { gross: 0, net: 0, toPar: 0, netToPar: 0, thru: 0, holesPlayed: 0, holes: [], stablefordPoints: 0, stablefordToPar: 0 };
        }
        
        const holes = scoreData.holes;
        const coursePars = getCoursePars();
        const strokeIndexes = getCourseStrokeIndexes();
        
        // Get player info for handicap
        const playerInfo = admittedPlayers.find(p => (p.reg || `${p.firstName}-${p.lastName}`) === playerKey) || scoreData;
        
        // Use phcp (from admissions) first, then playingHcp, then hcp
        const playingHcp = playerInfo?.phcp || playerInfo?.playingHcp || playerInfo?.hcp || 0;
        
        let gross = 0;
        let net = 0;
        let coursePar = 0;
        let thru = 0;  // Last hole number with a score (for display)
        let holesPlayed = 0;  // Actual count of holes played (for Stableford calculation)
        let stablefordPoints = 0;
        let totalStrokesReceived = 0;  // Total strokes received on played holes
        const holeScores = [];
        
        for (let i = 0; i < 18; i++) {
          const holePar = coursePars[i];
          const strokeIndex = strokeIndexes[i];
          const strokesOnHole = getStrokesForHole(playingHcp, strokeIndex);
          
          if (holes[i] && holes[i] !== '' && holes[i] !== null) {
            let score;
            
            // Handle 'X' (DNF) - use max score or net double bogey (0 points in Stableford)
            if (holes[i] === 'X' || holes[i] === 'x') {
              score = getMaxScoreForHole(i, playerInfo, holePar, strokeIndex);
            } else {
              score = parseInt(holes[i]);
              // Skip invalid scores
              if (isNaN(score)) {
                holeScores.push({ score: null, netScore: null, displayScore: null, diff: 0, netDiff: 0, par: holePar, stablefordPoints: 0, strokesReceived: strokesOnHole });
                continue;
              }
            }
            
            const netScore = score - strokesOnHole;
            
            gross += score;
            net += netScore;
            coursePar += holePar;
            totalStrokesReceived += strokesOnHole;
            thru = i + 1;  // Last hole number (1-indexed)
            holesPlayed++;  // Increment actual count of holes played
            
            const diff = score - holePar;
            const netDiff = netScore - holePar;
            
            // Calculate Stableford points for this hole
            const holeStablefordPoints = (holes[i] === 'X' || holes[i] === 'x') 
              ? 0 
              : calculateStablefordPoints(score, holePar, strokesOnHole);
            stablefordPoints += holeStablefordPoints;
            
            // Store original display value (X) but calculated score for sorting
            holeScores.push({ 
              score, 
              netScore,
              displayScore: holes[i], 
              diff,
              netDiff,
              par: holePar,
              stablefordPoints: holeStablefordPoints,
              strokesReceived: strokesOnHole
            });
          } else {
            holeScores.push({ score: null, netScore: null, displayScore: null, diff: 0, netDiff: 0, par: holePar, stablefordPoints: 0, strokesReceived: strokesOnHole });
          }
        }
        
        // Expected Stableford points (2 per hole ACTUALLY played = net par)
        // Use holesPlayed (actual count), not thru (last hole index) for shotgun support
        const expectedStablefordPoints = holesPlayed * 2;
        // Stableford "to par" = actual points - expected (positive is good!)
        const stablefordToPar = stablefordPoints - expectedStablefordPoints;
        
        // Calculate previous rounds totals for multi-round aggregate tournaments
        let prevRoundsGross = 0;
        let prevRoundsToPar = 0;
        let prevRoundsNet = 0;
        let prevRoundsNetToPar = 0;
        let prevRoundsStableford = 0;
        let prevRoundsStablefordToPar = 0;
        
        if (isMultiRoundTournament && previousRoundsScores && previousRoundsScores[playerKey]) {
          // Get the pre-calculated cumulative scores for this player
          const prevData = previousRoundsScores[playerKey];
          prevRoundsGross = prevData.gross || 0;
          prevRoundsToPar = prevData.toPar || 0;
          prevRoundsNet = prevData.net || 0;
          prevRoundsStableford = prevData.stableford || 0;
          
          // Calculate stableford to par for previous rounds (expected is 36 per round)
          const prevRoundsCount = prevData.rounds || 0;
          prevRoundsStablefordToPar = prevRoundsStableford - (prevRoundsCount * 36);
        }
        
        return {
          gross,
          net,
          toPar: gross - coursePar,  // Gross to par
          netToPar: net - coursePar, // Net to par (net score - course par for played holes)
          thru,
          holesPlayed,
          holes: holeScores,
          stablefordPoints,
          stablefordToPar,
          playingHcp,
          // Aggregate totals (current + previous rounds)
          totalGross: gross + prevRoundsGross,
          totalToPar: (gross - coursePar) + prevRoundsToPar,
          totalNet: net + prevRoundsNet,
          totalNetToPar: (net - coursePar) + prevRoundsNetToPar,
          totalStableford: stablefordPoints + prevRoundsStableford,
          totalStablefordToPar: stablefordToPar + prevRoundsStablefordToPar,
          prevRoundsGross,
          prevRoundsToPar,
          prevRoundsStableford
        };
      }

      // Get max score for a hole (used when X is entered)
      function getMaxScoreForHole(holeIndex, player, par, strokeIndex) {
        const maxScoreSetting = currentTournament?.meta?.maxScore;
        
        // If max score is defined in tournament settings
        if (maxScoreSetting && maxScoreSetting !== 'na') {
          const phcp = player?.playingHcp || player?.hcp || player?.phcp || 0;
          
          switch(maxScoreSetting) {
            case 'net_double_bogey':
              const strokesReceived = getStrokesForHole(phcp, strokeIndex);
              return par + 2 + strokesReceived;
            case 'par_plus_4':
              return par + 4;
            case 'double_par':
              return par * 2;
            case '10':
              return 10;
          }
        }
        
        // Default: Net double bogey
        const phcp = player?.playingHcp || player?.hcp || player?.phcp || 0;
        const strokesReceived = getStrokesForHole(phcp, strokeIndex);
        return par + 2 + strokesReceived;
      }

      // Calculate strokes received on a hole
      function getStrokesForHole(playingHcp, strokeIndex) {
        if (!playingHcp || playingHcp <= 0) return 0;
        
        let strokes = 0;
        
        if (playingHcp >= strokeIndex) strokes = 1;
        if (playingHcp > 18 && (playingHcp - 18) >= strokeIndex) strokes += 1;
        if (playingHcp > 36 && (playingHcp - 36) >= strokeIndex) strokes += 1;
        
        return strokes;
      }

      // Get course stroke indexes
      function getCourseStrokeIndexes() {
        const defaultSI = [1, 3, 5, 7, 9, 11, 13, 15, 17, 2, 4, 6, 8, 10, 12, 14, 16, 18];
        
        if (!courseData) return defaultSI;
        
        if (courseData.strokeIndexes && Array.isArray(courseData.strokeIndexes)) {
          return courseData.strokeIndexes;
        }
        
        if (courseData.holes && Array.isArray(courseData.holes)) {
          return courseData.holes.map(h => h.si || 1);
        }
        
        return defaultSI;
      }

      // Get course pars array (handles different data formats)
      function getCoursePars() {
        const defaultPars = [4, 4, 3, 5, 4, 4, 3, 4, 5, 4, 4, 3, 5, 4, 4, 3, 4, 5];
        
        if (!courseData) return defaultPars;
        
        // Check if course has pars array (new format)
        if (courseData.pars && Array.isArray(courseData.pars)) {
          return courseData.pars;
        }
        
        // Check if course has holes array (old format)
        if (courseData.holes && Array.isArray(courseData.holes)) {
          return courseData.holes.map(h => h.par || 4);
        }
        
        return defaultPars;
      }

      // Render leaderboard
      function renderLeaderboard(changedPlayers = []) {
        console.log('=== renderLeaderboard called ===');
        console.log('currentCategory:', currentCategory);
        console.log('isMatchPlay:', isMatchPlay);
        console.log('isTeamLeaderboardView():', isTeamLeaderboardView());
        console.log('teamsTournament:', currentTournament?.meta?.teamsTournament);
        
        // Check if match play - render match-based leaderboard
        if (isMatchPlay) {
          // If Team Standings view is active, re-render it
          if (currentCategory === 'TEAM_STANDINGS') {
            console.log('Routing to renderTeamStandings (match play)');
            renderTeamStandings();
            return;
          }
          console.log('Routing to renderMatchPlayLeaderboard');
          renderMatchPlayLeaderboard();
          return;
        }
        
        // Check if we should show team leaderboard
        if (isTeamLeaderboardView()) {
          console.log('Routing to renderTeamLeaderboard');
          renderTeamLeaderboard(changedPlayers);
          return;
        }
        
        console.log('Rendering individual leaderboard');
        const container = document.getElementById('leaderboard-body');
        const noData = document.getElementById('no-data');
        
        // Clear any team rows that might be left over from team view
        const teamRows = container.querySelectorAll('.team-header-row, .team-player-row');
        if (teamRows.length > 0) {
          console.log('Clearing', teamRows.length, 'team rows from previous view');
          container.innerHTML = ''; // Clear everything and rebuild
        }
        
        // If leaderboard is hidden, show message
        if (!isLeaderboardVisible) {
          container.innerHTML = '';
          noData.style.display = 'block';
          noData.innerHTML = `
            <div class="no-data-icon">🚫</div>
            <div>Leaderboard is currently unavailable</div>
            <div style="margin-top: 8px; font-size: 13px;">Please check back later</div>
          `;
          
          // Hide stats
          document.getElementById('stat-leader').textContent = '-';
          document.getElementById('stat-players').textContent = '-';
          document.getElementById('stat-completed').textContent = '-';
          return;
        }
        
        // Build player list with scores
        let players = [];
        
        // Get all players from admitted list or scores
        const playerKeys = new Set([
          ...Object.keys(liveScores),
          ...admittedPlayers.map(p => p.reg || `${p.firstName}-${p.lastName}`)
        ]);
        
        playerKeys.forEach(key => {
          const scoreData = calculateScore(key);
          
          // Find player info - try multiple matching strategies
          let playerInfo = admittedPlayers.find(p => {
            const playerReg = p.reg || '';
            const playerKey = `${p.firstName}-${p.lastName}`;
            return playerReg === key || playerKey === key || playerReg.toLowerCase() === key.toLowerCase();
          });
          
          // Also try matching by reg number within score data
          if (!playerInfo) {
            const scoreInfo = liveScores[key];
            if (scoreInfo?.firstName && scoreInfo?.lastName) {
              playerInfo = {
                firstName: scoreInfo.firstName,
                lastName: scoreInfo.lastName,
                club: scoreInfo.club || scoreInfo.homeClub || '',
                categories: scoreInfo.categories || [],
                hcp: scoreInfo.hcp,
                playingHcp: scoreInfo.playingHcp || scoreInfo.phcp,
                reg: key
              };
            } else {
              // Last resort - check if key looks like a registration number
              const isRegNumber = /^P\d+$/.test(key);
              if (isRegNumber) {
                // Try to find by reg number in admitted players
                playerInfo = admittedPlayers.find(p => p.reg === key);
              }
              
              if (!playerInfo) {
                // Fallback - create minimal player info
                const parts = key.split('-');
                playerInfo = {
                  firstName: parts.length > 1 ? parts[0] : key,
                  lastName: parts.length > 1 ? parts.slice(1).join(' ') : '',
                  reg: key
                };
              }
            }
          }
          
          // Filter by category
          if (currentCategory !== 'ALL') {
            const playerCategories = playerInfo.categories || [];
            
            // Special handling for TEAM category in team tournaments
            const isTeamTournament = currentTournament?.meta?.teamsTournament === 'yes';
            const isTeamCategory = currentCategory === 'TEAM';
            
            // In team tournaments, all players belong to TEAM category
            if (isTeamTournament && isTeamCategory) {
              // Include all players for TEAM category
            } else if (!playerCategories.includes(currentCategory)) {
              return;
            }
          }
          
          players.push({
            key,
            ...playerInfo,
            ...scoreData
          });
        });
        
        // Check if we're using Stableford scoring for this category
        const useStableford = isStablefordScoring();
        const useNet = isNetScoring();
        
        // Sort by score
        // Stroke play: lowest to par first (ascending)
        // Medal Net: lowest net to par first (ascending)
        // Stableford: highest points first (descending)
        // Use holesPlayed (actual count) instead of thru (last hole index) for shotgun support
        // For multi-round tournaments, use aggregate totals
        players.sort((a, b) => {
          if (a.holesPlayed === 0 && b.holesPlayed === 0) return 0;
          if (a.holesPlayed === 0) return 1;
          if (b.holesPlayed === 0) return -1;
          
          if (useStableford) {
            // Stableford: higher is better - use aggregate totals for multi-round
            const aScore = isMultiRoundTournament ? a.totalStablefordToPar : a.stablefordToPar;
            const bScore = isMultiRoundTournament ? b.totalStablefordToPar : b.stablefordToPar;
            if (aScore !== bScore) return bScore - aScore;
          } else if (useNet) {
            // Medal Net: lower net to par is better - use aggregate totals for multi-round
            const aScore = isMultiRoundTournament ? a.totalNetToPar : a.netToPar;
            const bScore = isMultiRoundTournament ? b.totalNetToPar : b.netToPar;
            if (aScore !== bScore) return aScore - bScore;
          } else {
            // Stroke play (gross): lower is better - use aggregate totals for multi-round
            const aScore = isMultiRoundTournament ? a.totalToPar : a.toPar;
            const bScore = isMultiRoundTournament ? b.totalToPar : b.toPar;
            if (aScore !== bScore) return aScore - bScore;
          }
          return b.holesPlayed - a.holesPlayed;
        });
        
        // Assign positions
        let currentPosition = 1;
        let previousScore = null;
        let previousHolesPlayed = null;
        let playersAtPosition = 0;
        
        players.forEach((player, index) => {
          // Use appropriate score based on format and multi-round status
          let sortScore;
          if (useStableford) {
            sortScore = isMultiRoundTournament ? player.totalStablefordToPar : player.stablefordToPar;
          } else if (useNet) {
            sortScore = isMultiRoundTournament ? player.totalNetToPar : player.netToPar;
          } else {
            sortScore = isMultiRoundTournament ? player.totalToPar : player.toPar;
          }
          
          if (player.holesPlayed === 0) {
            player.position = '-';
          } else if (sortScore === previousScore && player.holesPlayed === previousHolesPlayed) {
            player.position = players[index - playersAtPosition].position;
            playersAtPosition++;
          } else {
            player.position = currentPosition;
            previousScore = sortScore;
            previousHolesPlayed = player.holesPlayed;
            playersAtPosition = 1;
          }
          currentPosition = index + 2;
        });
        
        // Check for no data
        const playersWithScores = players.filter(p => p.holesPlayed > 0);
        
        if (playersWithScores.length === 0) {
          document.getElementById('leaderboard-wrapper').style.display = 'none';
          document.getElementById('no-data').style.display = 'block';
          document.getElementById('stats-bar').style.display = 'none';
          return;
        }
        
        document.getElementById('no-data').style.display = 'none';
        document.getElementById('leaderboard-wrapper').style.display = 'block';
        document.getElementById('stats-bar').style.display = 'grid';
        
        // Update stats
        updateStats(players);
        
        // Smart DOM update - update individual rows instead of rebuilding entire table
        const tbody = document.getElementById('leaderboard-body');
        const existingRows = tbody.querySelectorAll('tr[data-player-key]');
        const existingRowMap = {};
        existingRows.forEach(row => {
          existingRowMap[row.dataset.playerKey] = row;
        });
        
        // Track rows that should exist
        const currentPlayerKeys = new Set(players.map(p => p.key));
        
        // Remove rows for players no longer in the list
        existingRows.forEach(row => {
          if (!currentPlayerKeys.has(row.dataset.playerKey)) {
            row.style.opacity = '0';
            row.style.transform = 'translateX(-20px)';
            setTimeout(() => row.remove(), 300);
          }
        });
        
        // Update or create rows
        players.forEach((player, index) => {
          const isChanged = changedPlayers.includes(player.key);
          const positionChange = getPositionChange(player.key, player.position);
          
          // Store current position for next update
          if (typeof player.position === 'number') {
            previousPositions[player.key] = player.position;
          }
          
          // Format score based on scoring format
          // For multi-round tournaments, use aggregate totals
          let toParStr, toParClass;
          if (useStableford) {
            // Stableford: show total points and +/- from expected (positive is good)
            // Use holesPlayed to check if player has any scores (0 points is still a valid score!)
            const hasScores = player.holesPlayed > 0 || (isMultiRoundTournament && player.prevRoundsStableford > 0);
            const toParValue = isMultiRoundTournament ? player.totalStablefordToPar : player.stablefordToPar;
            // Check for NaN or no scores
            if (!hasScores || isNaN(toParValue)) {
              toParStr = '-';
              toParClass = 'even-par';
            } else {
              toParStr = toParValue === 0 ? 'E' : (toParValue > 0 ? `+${toParValue}` : toParValue);
              // In Stableford, positive is GOOD (under-par styling), negative is BAD (over-par styling)
              toParClass = toParValue > 0 ? 'under-par' : (toParValue < 0 ? 'over-par' : 'even-par');
            }
          } else {
            // Stroke play: show to par (negative is good)
            // Check if using Net scoring (Medal Net, etc.)
            const useNet = isNetScoring();
            const toParValue = isMultiRoundTournament 
              ? (useNet ? player.totalNetToPar : player.totalToPar)
              : (useNet ? player.netToPar : player.toPar);
            
            // Use holesPlayed to check if player has any scores
            const hasScores = player.holesPlayed > 0 || (isMultiRoundTournament && player.prevRoundsGross > 0);
            if (!hasScores || isNaN(toParValue)) {
              toParStr = '-';
              toParClass = 'even-par';
            } else {
              toParStr = toParValue === 0 ? 'E' : (toParValue > 0 ? `+${toParValue}` : toParValue);
              toParClass = toParValue < 0 ? 'under-par' : (toParValue > 0 ? 'over-par' : 'even-par');
            }
          }
          
          const initials = `${player.firstName?.[0] || ''}${player.lastName?.[0] || ''}`.toUpperCase();
          
          const existingRow = existingRowMap[player.key];
          
          if (existingRow) {
            // Update existing row with smooth transition
            const posCell = existingRow.querySelector('.position-cell');
            const scoreCell = existingRow.querySelector('.score-cell');
            const thruCell = existingRow.querySelector('.thru-cell');
            const roundScores = existingRow.querySelectorAll('.round-score');
            const holeScoresCell = existingRow.querySelector('td:last-child');
            
            // Update position
            if (posCell) {
              posCell.innerHTML = `${player.position}${positionChange}`;
              posCell.className = `position-cell ${player.position <= 3 ? 'top-3' : ''}`;
            }
            
            // Update score with animation if changed
            if (scoreCell) {
              const newScore = toParStr;
              if (scoreCell.textContent !== newScore || isChanged) {
                scoreCell.textContent = newScore;
                scoreCell.className = `score-cell ${toParClass}`;
                if (isChanged) {
                  scoreCell.style.transform = 'scale(1.2)';
                  scoreCell.style.transition = 'transform 0.3s ease';
                  setTimeout(() => { scoreCell.style.transform = 'scale(1)'; }, 300);
                }
              }
            }
            
            // Update thru (use holesPlayed for display, thru for "F" check)
            if (thruCell) {
              const thruDisplay = player.holesPlayed === 0 ? '-' : (player.holesPlayed === 18 ? 'F' : player.holesPlayed);
              thruCell.textContent = thruDisplay;
              thruCell.className = `thru-cell ${player.holesPlayed === 18 ? 'finished' : ''}`;
            }
            
            // Update round scores (0 is a valid score, so check holesPlayed not the value)
            const hasScores = player.holesPlayed > 0;
            const hasPrevScores = isMultiRoundTournament && player.prevRoundsGross > 0;
            const useNet = isNetScoring();
            let todayValue, totalValue;
            if (useStableford) {
              todayValue = hasScores ? player.stablefordPoints : '-';
              totalValue = (hasScores || hasPrevScores) ? player.totalStableford : '-';
            } else if (useNet) {
              todayValue = hasScores ? player.net : '-';
              totalValue = (hasScores || hasPrevScores) ? player.totalNet : '-';
            } else {
              todayValue = hasScores ? player.gross : '-';
              totalValue = (hasScores || hasPrevScores) ? player.totalGross : '-';
            }
            roundScores.forEach((cell, cellIndex) => {
              // First round-score is Today, second is Total
              cell.textContent = cellIndex === 0 ? todayValue : (isMultiRoundTournament ? totalValue : todayValue);
            });
            
            // Update hole scores
            if (holeScoresCell) {
              holeScoresCell.innerHTML = renderHoleScores(player.holes, useStableford, useNet);
            }
            
            // Highlight if changed
            if (isChanged) {
              existingRow.classList.add('highlight');
              setTimeout(() => existingRow.classList.remove('highlight'), 2000);
            }
            
            // Move row to correct position if needed
            const currentIndex = Array.from(tbody.children).indexOf(existingRow);
            if (currentIndex !== index) {
              existingRow.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
              const targetRow = tbody.children[index];
              if (targetRow && targetRow !== existingRow) {
                tbody.insertBefore(existingRow, targetRow);
              } else if (index >= tbody.children.length) {
                tbody.appendChild(existingRow);
              }
            }
          } else {
            // Create new row with animation
            const newRow = document.createElement('tr');
            newRow.dataset.playerKey = player.key;
            newRow.style.opacity = '0';
            newRow.style.transform = 'translateX(20px)';
            
            // Display values based on scoring format
            const hasScores = player.holesPlayed > 0;
            const hasPrevScores = isMultiRoundTournament && player.prevRoundsGross > 0;
            const useNet = isNetScoring();
            let todayValue, totalValue;
            if (useStableford) {
              todayValue = hasScores ? player.stablefordPoints : '-';
              totalValue = (hasScores || hasPrevScores) ? player.totalStableford : '-';
            } else if (useNet) {
              todayValue = hasScores ? player.net : '-';
              totalValue = (hasScores || hasPrevScores) ? player.totalNet : '-';
            } else {
              todayValue = hasScores ? player.gross : '-';
              totalValue = (hasScores || hasPrevScores) ? player.totalGross : '-';
            }
            
            // For multi-round, show Today and Total separately
            const roundTotalDisplay = isMultiRoundTournament ? totalValue : todayValue;
            
            newRow.innerHTML = `
              <td class="position-cell ${player.position <= 3 ? 'top-3' : ''}">${player.position}${positionChange}</td>
              <td>
                <div class="player-cell">
                  <div class="player-avatar">${initials}</div>
                  <div class="player-info">
                    <div class="player-name">${player.firstName} ${player.lastName}</div>
                    <div class="player-club">${player.club || player.homeClub || '-'}</div>
                  </div>
                </div>
              </td>
              <td class="score-cell ${toParClass}">${toParStr}</td>
              <td class="thru-cell ${player.holesPlayed === 18 ? 'finished' : ''}">${player.holesPlayed === 0 ? '-' : (player.holesPlayed === 18 ? 'F' : player.holesPlayed)}</td>
              <td class="round-score">${todayValue}</td>
              <td class="round-score">${roundTotalDisplay}</td>
              <td>${renderHoleScores(player.holes, useStableford, useNet)}</td>
            `;
            
            // Insert at correct position
            const targetRow = tbody.children[index];
            if (targetRow) {
              tbody.insertBefore(newRow, targetRow);
            } else {
              tbody.appendChild(newRow);
            }
            
            // Animate in
            requestAnimationFrame(() => {
              newRow.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
              newRow.style.opacity = '1';
              newRow.style.transform = 'translateX(0)';
            });
          }
        });
        
        // Update last updated
        document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
      }

      // Get position change indicator
      function getPositionChange(playerKey, currentPosition) {
        if (typeof currentPosition !== 'number') return '';
        
        const previousPosition = previousPositions[playerKey];
        if (!previousPosition) return '';
        
        const change = previousPosition - currentPosition;
        
        if (change > 0) {
          return `<span class="movement up">↑${change}</span>`;
        } else if (change < 0) {
          return `<span class="movement down">↓${Math.abs(change)}</span>`;
        }
        
        return '';
      }

      // Render hole scores
      function renderHoleScores(holes, useStableford = false, useNet = false) {
        if (!holes || holes.length === 0) return '-';
        
        // Helper to render a single hole score
        function renderSingleHole(hole, index) {
          if (hole.score === null) {
            return `<div class="hole-score">-</div>`;
          }
          
          let className = 'hole-score ';
          const isX = hole.displayScore === 'X' || hole.displayScore === 'x';
          
          if (useStableford) {
            const pts = hole.stablefordPoints || 0;
            if (isX || pts === 0) className += 'double';
            else if (pts === 1) className += 'bogey';
            else if (pts === 2) className += 'par';
            else if (pts === 3) className += 'birdie';
            else className += 'eagle';
            const displayValue = isX ? '0' : pts;
            return `<div class="${className}" title="${hole.score} strokes">${displayValue}</div>`;
          } else if (useNet) {
            const netDiff = hole.netDiff || 0;
            if (isX) className += 'dnf';
            else if (netDiff <= -2) className += 'eagle';
            else if (netDiff === -1) className += 'birdie';
            else if (netDiff === 0) className += 'par';
            else if (netDiff === 1) className += 'bogey';
            else className += 'double';
            const displayValue = isX ? 'X' : hole.netScore;
            const strokeInfo = hole.strokesReceived > 0 ? ` (${hole.strokesReceived} stroke${hole.strokesReceived > 1 ? 's' : ''})` : '';
            return `<div class="${className}" title="Gross: ${hole.score}${strokeInfo}">${displayValue}</div>`;
          } else {
            if (isX) className += 'dnf';
            else if (hole.diff <= -2) className += 'eagle';
            else if (hole.diff === -1) className += 'birdie';
            else if (hole.diff === 0) className += 'par';
            else if (hole.diff === 1) className += 'bogey';
            else className += 'double';
            const displayValue = isX ? 'X' : hole.score;
            return `<div class="${className}">${displayValue}</div>`;
          }
        }
        
        let html = '<div class="hole-scores-container">';
        
        // All 18 hole numbers in one row (for desktop)
        html += '<div class="hole-numbers hole-numbers-all">';
        for (let i = 1; i <= 18; i++) {
          html += `<div class="hole-number">${i}</div>`;
        }
        html += '</div>';
        
        // All 18 scores in one row (for desktop)
        html += '<div class="hole-scores hole-scores-all">';
        for (let i = 0; i < 18; i++) {
          html += renderSingleHole(holes[i], i);
        }
        html += '</div>';
        
        // Front 9 (for mobile only)
        html += '<div class="nine-holes front-nine">';
        html += '<div class="hole-numbers">';
        for (let i = 1; i <= 9; i++) {
          html += `<div class="hole-number">${i}</div>`;
        }
        html += '</div>';
        html += '<div class="hole-scores">';
        for (let i = 0; i < 9; i++) {
          html += renderSingleHole(holes[i], i);
        }
        html += '</div>';
        html += '</div>';
        
        // Back 9 (for mobile only)
        html += '<div class="nine-holes back-nine">';
        html += '<div class="hole-numbers">';
        for (let i = 10; i <= 18; i++) {
          html += `<div class="hole-number">${i}</div>`;
        }
        html += '</div>';
        html += '<div class="hole-scores">';
        for (let i = 9; i < 18; i++) {
          html += renderSingleHole(holes[i], i);
        }
        html += '</div>';
        html += '</div>';
        
        html += '</div>';
        return html;
      }
      
      // Get actual team name from teamsByRound using player's reg ID
      function getActualTeamName(playerRegId) {
        if (!currentTournament || !playerRegId) return '';
        
        const teamsByRound = currentTournament.teamsByRound || {};
        const roundKeys = Object.keys(teamsByRound);
        
        if (roundKeys.length === 0) return '';
        
        // Check first round's teams
        const teams = teamsByRound[roundKeys[0]] || [];
        
        for (const team of teams) {
          if (team.players && team.players.includes(playerRegId)) {
            return team.name || '';
          }
        }
        
        return '';
      }

      // Render Team Standings table
      // Process a single round's matches from OFFICIAL results (matchScores) and update team stats
      function processOfficialRoundResults(roundDrawData, officialScores, teamStats) {
        if (!roundDrawData || !roundDrawData.groups || roundDrawData.groups.length === 0) {
          return;
        }
        
        roundDrawData.groups.forEach((group, groupIndex) => {
          const players = group.players || [];
          if (players.length < 4) return;
          
          // Get official score for this match
          const matchKey = `match_${groupIndex}`;
          const score = officialScores?.[matchKey];
          
          // Skip if no official score or empty score
          if (!score || (score.left === '' && score.right === '')) return;
          
          // Get team names
          const homePlayerReg = players[0]?.reg;
          const awayPlayerReg = players[2]?.reg;
          const homeTeamName = getActualTeamName(homePlayerReg);
          const awayTeamName = getActualTeamName(awayPlayerReg);
          
          // Find team stats
          let homeTeamStats = null;
          let awayTeamStats = null;
          
          for (const key of Object.keys(teamStats)) {
            if (teamStats[key].name === homeTeamName) homeTeamStats = teamStats[key];
            if (teamStats[key].name === awayTeamName) awayTeamStats = teamStats[key];
          }
          
          if (!homeTeamStats || !awayTeamStats) return;
          
          // Official scores: left = home points won by, right = away points won by
          const homeWonBy = parseInt(score.left) || 0;
          const awayWonBy = parseInt(score.right) || 0;
          
          // Update CONFIRMED stats
          homeTeamStats.confirmed.played++;
          awayTeamStats.confirmed.played++;
          
          if (homeWonBy > 0) {
            homeTeamStats.confirmed.won++;
            homeTeamStats.confirmed.points += 1;
            homeTeamStats.confirmed.differential += homeWonBy;
            awayTeamStats.confirmed.lost++;
            awayTeamStats.confirmed.differential -= homeWonBy;
          } else if (awayWonBy > 0) {
            awayTeamStats.confirmed.won++;
            awayTeamStats.confirmed.points += 1;
            awayTeamStats.confirmed.differential += awayWonBy;
            homeTeamStats.confirmed.lost++;
            homeTeamStats.confirmed.differential -= awayWonBy;
          } else {
            homeTeamStats.confirmed.tied++;
            awayTeamStats.confirmed.tied++;
            homeTeamStats.confirmed.points += 0.5;
            awayTeamStats.confirmed.points += 0.5;
          }
        });
      }
      
      // Process current round's matches from LIVE scores and update team stats
      function processLiveRoundMatches(roundDrawData, liveScores, teamStats) {
        if (!roundDrawData || !roundDrawData.groups || roundDrawData.groups.length === 0) {
          return;
        }
        
        roundDrawData.groups.forEach((group, groupIndex) => {
          const players = group.players || [];
          if (players.length < 4) return;
          
          const matchKey = `match_${groupIndex}`;
          const matchScore = liveScores?.[matchKey];
          
          if (!matchScore) return;
          
          const homePlayerReg = players[0]?.reg;
          const awayPlayerReg = players[2]?.reg;
          const homeTeamName = getActualTeamName(homePlayerReg);
          const awayTeamName = getActualTeamName(awayPlayerReg);
          
          let homeTeamStats = null;
          let awayTeamStats = null;
          
          for (const key of Object.keys(teamStats)) {
            if (teamStats[key].name === homeTeamName) homeTeamStats = teamStats[key];
            if (teamStats[key].name === awayTeamName) awayTeamStats = teamStats[key];
          }
          
          if (!homeTeamStats || !awayTeamStats) return;
          
          const homeUp = matchScore.homeUp || 0;
          
          // For in-progress matches, update IN-PROGRESS stats
          if (matchScore.status !== 'completed') {
            homeTeamStats.inProgress.played++;
            awayTeamStats.inProgress.played++;
            
            if (homeUp > 0) {
              homeTeamStats.inProgress.won++;
              homeTeamStats.inProgress.points += 1;
              awayTeamStats.inProgress.lost++;
            } else if (homeUp < 0) {
              awayTeamStats.inProgress.won++;
              awayTeamStats.inProgress.points += 1;
              homeTeamStats.inProgress.lost++;
            } else {
              homeTeamStats.inProgress.tied++;
              awayTeamStats.inProgress.tied++;
              homeTeamStats.inProgress.points += 0.5;
              awayTeamStats.inProgress.points += 0.5;
            }
            return;
          }
          
          // Completed match in current round - goes to CONFIRMED
          homeTeamStats.confirmed.played++;
          awayTeamStats.confirmed.played++;
          
          let margin = 0;
          if (matchScore.finalResult) {
            const resultText = matchScore.finalResult;
            if (resultText.includes('&')) {
              margin = parseInt(resultText.split('&')[0].trim()) || 0;
            } else if (resultText.toUpperCase().includes('UP')) {
              margin = parseInt(resultText.replace(/UP/i, '').trim()) || 0;
            }
          } else {
            margin = Math.abs(homeUp);
          }
          
          if (matchScore.winner === 'home' || (homeUp > 0 && !matchScore.winner)) {
            homeTeamStats.confirmed.won++;
            homeTeamStats.confirmed.points += 1;
            homeTeamStats.confirmed.differential += margin;
            awayTeamStats.confirmed.lost++;
            awayTeamStats.confirmed.differential -= margin;
          } else if (matchScore.winner === 'away' || (homeUp < 0 && !matchScore.winner)) {
            awayTeamStats.confirmed.won++;
            awayTeamStats.confirmed.points += 1;
            awayTeamStats.confirmed.differential += margin;
            homeTeamStats.confirmed.lost++;
            homeTeamStats.confirmed.differential -= margin;
          } else {
            homeTeamStats.confirmed.tied++;
            awayTeamStats.confirmed.tied++;
            homeTeamStats.confirmed.points += 0.5;
            awayTeamStats.confirmed.points += 0.5;
          }
        });
      }
      
      // Render Team Standings - aggregates all rounds
      // Previous rounds: use official results from matchScores
      // Current round: use live scores from liveMatchScores
      async function renderTeamStandings() {
        const wrapper = document.getElementById('team-standings-wrapper');
        if (!wrapper) return;
        
        const teams = getTeams();
        console.log('Team Standings - teams from getTeams():', teams);
        
        if (teams.length === 0) {
          wrapper.innerHTML = `
            <div class="team-standings-container">
              <div class="team-standings-title">
                <span class="trophy">🏆</span> Team Standings
              </div>
              <p style="color: #64748b; text-align: center;">No teams configured for this tournament</p>
            </div>
          `;
          return;
        }
        
        // Initialize team stats with confirmed and inProgress sub-objects
        const teamStats = {};
        teams.forEach(team => {
          const key = team.teamId || team.id || team.name;
          teamStats[key] = {
            id: team.teamId || team.id,
            name: team.name,
            confirmed: { played: 0, won: 0, lost: 0, tied: 0, points: 0, differential: 0 },
            inProgress: { played: 0, won: 0, lost: 0, tied: 0, points: 0, differential: 0 }
          };
        });
        
        // Get all round IDs
        const tournamentId = currentTournament?.tournamentId || currentTournament?.id;
        const roundIds = currentTournament?.meta?.roundIds || [tournamentId + '-1'];
        
        console.log('Team Standings - Processing all rounds:', roundIds);
        console.log('Team Standings - Current round:', currentRoundId);
        
        // Fetch official results (matchScores) for all rounds at once
        let allOfficialScores = {};
        try {
          if (db) {
            const officialSnapshot = await db.ref('matchScores').once('value');
            allOfficialScores = officialSnapshot.val() || {};
            console.log('Team Standings - Official matchScores loaded:', Object.keys(allOfficialScores));
          }
        } catch (error) {
          console.error('Error fetching official matchScores:', error);
        }
        
        // Process each round
        for (const roundId of roundIds) {
          const isCurrentRound = (roundId === currentRoundId);
          
          let roundDrawData;
          
          if (isCurrentRound) {
            roundDrawData = drawData;
          } else {
            // Fetch draw data for previous rounds
            try {
              if (db) {
                const drawSnapshot = await db.ref(`draws/${roundId}`).once('value');
                roundDrawData = drawSnapshot.val();
              }
            } catch (error) {
              console.error(`Error fetching draw for round ${roundId}:`, error);
              continue;
            }
          }
          
          console.log(`Processing round ${roundId}, isCurrentRound: ${isCurrentRound}, groups: ${roundDrawData?.groups?.length || 0}`);
          
          if (isCurrentRound) {
            // Current round: use live scores
            processLiveRoundMatches(roundDrawData, liveMatchScores || {}, teamStats);
          } else {
            // Previous rounds: use official results from matchScores
            const officialScores = allOfficialScores[roundId] || {};
            console.log(`Round ${roundId} official scores:`, officialScores);
            processOfficialRoundResults(roundDrawData, officialScores, teamStats);
          }
        }
        
        // Calculate totals and sort teams
        const sortedTeams = Object.values(teamStats).map(team => {
          const total = {
            played: team.confirmed.played + team.inProgress.played,
            won: team.confirmed.won + team.inProgress.won,
            lost: team.confirmed.lost + team.inProgress.lost,
            tied: team.confirmed.tied + team.inProgress.tied,
            points: team.confirmed.points + team.inProgress.points,
            differential: team.confirmed.differential + team.inProgress.differential
          };
          return { ...team, total };
        }).sort((a, b) => {
          if (b.total.points !== a.total.points) return b.total.points - a.total.points;
          return b.total.differential - a.total.differential;
        });
        
        // Build HTML table with expandable rows
        let html = `
          <div class="team-standings-container">
            <div class="team-standings-title">
              <span class="trophy">🏆</span> Team Standings
            </div>
            <table class="team-standings-table">
              <thead>
                <tr>
                  <th style="width: 40px;">#</th>
                  <th>Team</th>
                  <th class="center">Played</th>
                  <th class="center">Won</th>
                  <th class="center">Lost</th>
                  <th class="center">Tied</th>
                  <th class="center">Points</th>
                  <th class="center">+/-</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        sortedTeams.forEach((team, index) => {
          const t = team.total;
          const c = team.confirmed;
          const p = team.inProgress;
          
          const diffClass = t.differential > 0 ? 'diff-positive' : (t.differential < 0 ? 'diff-negative' : '');
          const diffText = t.differential > 0 ? `+${t.differential}` : t.differential.toString();
          const hasInProgress = p.played > 0;
          const teamKey = (team.id || team.name).replace(/[^a-zA-Z0-9]/g, '_');
          
          // Main row (clickable if has in-progress matches)
          html += `
            <tr class="team-row ${hasInProgress ? '' : ''}" onclick="toggleTeamBreakdown('${teamKey}')" style="cursor: ${hasInProgress ? 'pointer' : 'default'}">
              <td class="rank">${index + 1}</td>
              <td>
                <div class="team-name-cell">
                  ${hasInProgress ? '<span class="expand-icon">▶</span>' : '<span style="width: 14px; display: inline-block;"></span>'}
                  <span class="team-name">${team.name}</span>
                </div>
              </td>
              <td class="center">${t.played}</td>
              <td class="center won">${t.won}</td>
              <td class="center lost">${t.lost}</td>
              <td class="center">${t.tied}</td>
              <td class="center points">${t.points % 1 === 0 ? t.points : t.points.toFixed(1)}</td>
              <td class="center ${diffClass}">${diffText}</td>
            </tr>
          `;
          
          // Breakdown row (hidden by default)
          if (hasInProgress) {
            const cDiffText = c.differential > 0 ? `+${c.differential}` : c.differential.toString();
            const pDiffText = p.differential > 0 ? `+${p.differential}` : p.differential.toString();
            
            html += `
              <tr class="breakdown-row" id="breakdown-${teamKey}">
                <td colspan="8">
                  <div class="breakdown-container">
                    <div class="breakdown-item confirmed">
                      <span class="breakdown-label">✓ Confirmed</span>
                      <div class="breakdown-stats">
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Matches:</span> <span class="breakdown-stat-value">${c.played}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Won:</span> <span class="breakdown-stat-value won">${c.won}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Lost:</span> <span class="breakdown-stat-value lost">${c.lost}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Tied:</span> <span class="breakdown-stat-value">${c.tied}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Pts:</span> <span class="breakdown-stat-value points">${c.points % 1 === 0 ? c.points : c.points.toFixed(1)}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">+/-:</span> <span class="breakdown-stat-value">${cDiffText}</span></div>
                      </div>
                    </div>
                    <div class="breakdown-item in-progress">
                      <span class="breakdown-label">⏳ In Progress</span>
                      <div class="breakdown-stats">
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Matches:</span> <span class="breakdown-stat-value">${p.played}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Leading:</span> <span class="breakdown-stat-value won">${p.won}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Down:</span> <span class="breakdown-stat-value lost">${p.lost}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">AS:</span> <span class="breakdown-stat-value">${p.tied}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">Proj Pts:</span> <span class="breakdown-stat-value points">${p.points % 1 === 0 ? p.points : p.points.toFixed(1)}</span></div>
                        <div class="breakdown-stat"><span class="breakdown-stat-label">+/-:</span> <span class="breakdown-stat-value">${pDiffText}</span></div>
                      </div>
                    </div>
                  </div>
                </td>
              </tr>
            `;
          }
        });
        
        html += `
              </tbody>
            </table>
            <div class="team-standings-note">
              * Click on a team row to see breakdown of confirmed vs in-progress matches.<br>
              * +/- = Score Differential (sum of winning margins). Used as untie criteria when points are equal.
            </div>
          </div>
        `;
        
        wrapper.innerHTML = html;
      }
      
      // Toggle team breakdown row visibility
      function toggleTeamBreakdown(teamKey) {
        const row = document.getElementById(`breakdown-${teamKey}`);
        const mainRow = row?.previousElementSibling;
        
        if (row) {
          row.classList.toggle('visible');
          mainRow?.classList.toggle('expanded');
        }
      }

      // Render match play leaderboard
      function renderMatchPlayLeaderboard() {
        const container = document.getElementById('leaderboard-body');
        const noData = document.getElementById('no-data');
        
        // Build matches from draw data (groups) similar to live_scoring.html
        let matches = [];
        
        if (drawData && drawData.groups && drawData.groups.length > 0) {
          // Construct matches from groups
          drawData.groups.forEach((group, groupIndex) => {
            const players = group.players || [];
            if (players.length < 2) return;
            
            if (matchPlayFormat === 'singles') {
              // Singles: Create matches for pairs (1v2, 3v4)
              const numMatches = Math.floor(players.length / 2);
              
              for (let i = 0; i < numMatches; i++) {
                const player1 = players[i * 2];
                const player2 = players[i * 2 + 1];
                
                if (!player1 || !player2) return;
                
                const matchKey = `match_${groupIndex}_${i}`;
                matches.push({
                  key: matchKey,
                  home: player1,
                  away: player2,
                  group: group,
                  liveScore: liveMatchScores[matchKey] || null
                });
              }
            } else {
              // Fourball/Foursome: Group is one match (2v2)
              if (players.length < 4) return;
              
              const matchKey = `match_${groupIndex}`;
              matches.push({
                key: matchKey,
                home: { player1: players[0], player2: players[1] },
                away: { player1: players[2], player2: players[3] },
                group: group,
                liveScore: liveMatchScores[matchKey] || null
              });
            }
          });
        } else if (Object.keys(liveMatchScores).length > 0) {
          // Fall back to live match scores if no draw data
          matches = Object.entries(liveMatchScores).map(([key, score]) => ({
            key,
            home: score.home || { name: 'Home' },
            away: score.away || { name: 'Away' },
            liveScore: score
          }));
        }
        
        // Update stats - use correct element IDs
        const totalMatches = matches.length;
        const inProgress = matches.filter(m => m.liveScore && m.liveScore.status === 'in-progress').length;
        const completed = matches.filter(m => m.liveScore && m.liveScore.status === 'completed').length;
        
        const statLeader = document.getElementById('stat-leader');
        const statPlayers = document.getElementById('stat-players');
        const statScoring = document.getElementById('stat-scoring');
        const statFinished = document.getElementById('stat-finished');
        
        if (statLeader) statLeader.textContent = `${totalMatches}`;
        if (statPlayers) statPlayers.textContent = `${inProgress}`;
        if (statScoring) statScoring.textContent = `${totalMatches - completed - inProgress}`;
        if (statFinished) statFinished.textContent = `${completed}`;
        
        // Update stat labels for match play
        const labels = document.querySelectorAll('.stat-label');
        if (labels.length >= 4) {
          labels[0].textContent = 'Matches';
          labels[1].textContent = 'In Progress';
          labels[2].textContent = 'Not Started';
          labels[3].textContent = 'Completed';
        }
        
        if (matches.length === 0) {
          container.innerHTML = '';
          noData.style.display = 'block';
          noData.innerHTML = `
            <div class="no-data-icon">⛳</div>
            <div>No matches scheduled</div>
            <div style="margin-top: 8px; font-size: 13px;">Matches will appear here once the draw is made</div>
          `;
          return;
        }
        
        noData.style.display = 'none';
        
        // Build match cards
        let html = '<div class="match-play-container">';
        
        matches.forEach((match, idx) => {
          const matchScore = match.liveScore;
          const homeScore = matchScore?.homeScore || matchScore?.homeUp || 0;
          const awayScore = matchScore?.awayScore || 0;
          const thru = matchScore?.thru || matchScore?.holesPlayed || 0;
          const status = matchScore?.status || 'not-started';
          
          // Determine match status text and arrow direction
          let statusText = 'Not Started';
          let arrowDirection = 'none'; // none, home, away
          let statusClass = 'not-started';
          
          if (status === 'completed') {
            if (matchScore.finalResult) {
              statusText = matchScore.finalResult; // e.g., "3 & 2", "1 UP", "AS"
              // Determine winner from finalResult or scores
              if (homeScore > awayScore) {
                arrowDirection = 'home';
              } else if (awayScore > homeScore || matchScore.winner === 'away') {
                arrowDirection = 'away';
              }
            } else if (homeScore > awayScore) {
              const diff = homeScore - awayScore;
              statusText = `${diff} & ${18 - thru}`; // Closed out with remaining holes
              arrowDirection = 'home';
            } else if (awayScore > homeScore) {
              const diff = awayScore - homeScore;
              statusText = `${diff} & ${18 - thru}`;
              arrowDirection = 'away';
            } else {
              statusText = 'AS';
            }
            statusClass = 'completed';
          } else if (status === 'in-progress' || thru > 0) {
            if (homeScore > awayScore) {
              statusText = `${homeScore - awayScore} UP`;
              arrowDirection = 'home';
            } else if (awayScore > homeScore) {
              statusText = `${awayScore - homeScore} UP`;
              arrowDirection = 'away';
            } else {
              statusText = 'AS';
            }
            statusClass = 'in-progress';
          }
          
          // Get team/player names - look up actual team names from teamsByRound
          const homePlayerReg = match.home.player1?.reg || match.home.reg || '';
          const awayPlayerReg = match.away.player1?.reg || match.away.reg || '';
          const homeTeamLabel = getActualTeamName(homePlayerReg) || match.home.player1?.teamName || match.home.teamName || '';
          const awayTeamLabel = getActualTeamName(awayPlayerReg) || match.away.player1?.teamName || match.away.teamName || '';
          const homeName = getMatchTeamName(match.home, 'home', homeTeamLabel);
          const awayName = getMatchTeamName(match.away, 'away', awayTeamLabel);
          
          html += `
            <div class="match-card ${statusClass}" data-match-key="${match.key}">
              <div class="match-header">
                <span class="match-number">Match ${idx + 1}</span>
                <span class="match-thru">${status === 'completed' ? 'Final' : ''}</span>
              </div>
              <div class="match-body">
                <div class="match-teams">
                  <div class="team-side home">
                    <span class="team-name">${homeName}</span>
                  </div>
                  <div class="match-status-arrow">
                    ${status === 'completed' ? `<div class="match-final-label">FINAL</div>` : ''}
                    ${arrowDirection === 'home' ? `<div class="arrow-indicator home-leading"><svg viewBox="0 0 60 40"><path d="M20 0 L0 20 L20 40 L20 32 L8 20 L20 8 Z M38 0 L18 20 L38 40 L38 32 L26 20 L38 8 Z M56 0 L36 20 L56 40 L56 32 L44 20 L56 8 Z"/></svg></div>` : ''}
                    ${arrowDirection === 'away' ? `<div class="arrow-indicator away-leading"><svg viewBox="0 0 60 40"><path d="M4 0 L24 20 L4 40 L4 32 L16 20 L4 8 Z M22 0 L42 20 L22 40 L22 32 L34 20 L22 8 Z M40 0 L60 20 L40 40 L40 32 L52 20 L40 8 Z"/></svg></div>` : ''}
                    <div class="match-score-badge ${statusClass} ${arrowDirection === 'home' ? 'home-leading' : ''} ${arrowDirection === 'away' ? 'away-leading' : ''}">
                      ${statusText}
                    </div>
                    ${thru > 0 && status !== 'completed' ? `<div class="match-thru-center">Thru ${thru}</div>` : ''}
                  </div>
                  <div class="team-side away">
                    <span class="team-name">${awayName}</span>
                  </div>
                </div>
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        container.innerHTML = html;
      }
      
      // Format player name as "FirstName MiddleName L." (first letter of last name + dot)
      function formatPlayerName(fullName) {
        if (!fullName || fullName === 'TBD') return 'TBD';
        const parts = fullName.trim().split(' ');
        if (parts.length === 1) return parts[0];
        // Last part is the last name - take first letter + dot
        const lastName = parts.pop();
        const firstNames = parts.join(' ');
        return `${firstNames} ${lastName.charAt(0)}.`;
      }
      
      // Get team/player name for match display
      function getMatchTeamName(team, side, teamLabel = '') {
        if (!team) return side === 'home' ? 'Home' : 'Away';
        
        // Add team label if provided
        const labelHtml = teamLabel ? `<div class="team-label">${teamLabel}</div>` : '';
        
        if (matchPlayFormat === 'singles') {
          // Single player
          let fullName = '';
          if (team.name) fullName = team.name;
          else if (team.firstName && team.lastName) fullName = `${team.firstName} ${team.lastName}`;
          else fullName = team.player1?.name || 'TBD';
          return `${labelHtml}<span class="player-name">${formatPlayerName(fullName)}</span>`;
        }
        
        // Fourball/Foursome - show both players on separate lines
        const player1 = team.player1 || team;
        const player2 = team.player2;
        
        const name1 = player1.name || `${player1.firstName || ''} ${player1.lastName || ''}`.trim() || 'TBD';
        const name2 = player2 ? (player2.name || `${player2.firstName || ''} ${player2.lastName || ''}`.trim()) : '';
        
        const formatted1 = formatPlayerName(name1);
        const formatted2 = name2 ? formatPlayerName(name2) : '';
        
        if (formatted2) {
          return `${labelHtml}<span class="player-name">${formatted1}</span><span class="player-name">${formatted2}</span>`;
        }
        
        return `${labelHtml}<span class="player-name">${formatted1}</span>`;
      }
      
      // Render hole-by-hole details for a match
      function renderMatchHoleByHole(match) {
        const matchScore = match.liveScore;
        if (!matchScore || !matchScore.holes) {
          return '<div class="match-details-empty">No hole data available</div>';
        }
        
        const holes = matchScore.holes;
        const coursePars = getCoursePars();
        
        let html = '<div class="hole-score-grid">';
        
        // Header row
        html += '<div class="hole-header-row">';
        html += '<div class="hole-label">Hole</div>';
        for (let i = 1; i <= 18; i++) {
          html += `<div class="hole-num">${i}</div>`;
        }
        html += '</div>';
        
        // Par row
        html += '<div class="hole-par-row">';
        html += '<div class="hole-label">Par</div>';
        for (let i = 0; i < 18; i++) {
          html += `<div class="hole-par">${coursePars[i] || '-'}</div>`;
        }
        html += '</div>';
        
        // Home scores
        if (matchScore.homeScores) {
          html += '<div class="hole-score-row home">';
          html += `<div class="hole-label">${getMatchTeamName(match.home, 'home').split('/')[0]}</div>`;
          for (let i = 0; i < 18; i++) {
            const score = matchScore.homeScores[i];
            html += `<div class="hole-score ${getScoreClass(score, coursePars[i])}">${score || '-'}</div>`;
          }
          html += '</div>';
        }
        
        // Away scores
        if (matchScore.awayScores) {
          html += '<div class="hole-score-row away">';
          html += `<div class="hole-label">${getMatchTeamName(match.away, 'away').split('/')[0]}</div>`;
          for (let i = 0; i < 18; i++) {
            const score = matchScore.awayScores[i];
            html += `<div class="hole-score ${getScoreClass(score, coursePars[i])}">${score || '-'}</div>`;
          }
          html += '</div>';
        }
        
        // Match result per hole (H = Home won, A = Away won, AS = All Square)
        html += '<div class="hole-result-row">';
        html += '<div class="hole-label">Result</div>';
        for (let i = 0; i < 18; i++) {
          const result = holes[i] || '-';
          let resultClass = '';
          if (result === 'H') resultClass = 'home-won';
          else if (result === 'A') resultClass = 'away-won';
          else if (result === 'AS') resultClass = 'halved';
          html += `<div class="hole-result ${resultClass}">${result}</div>`;
        }
        html += '</div>';
        
        html += '</div>';
        return html;
      }
      
      // Get score class for styling
      function getScoreClass(score, par) {
        if (!score || !par) return '';
        const diff = score - par;
        if (diff <= -2) return 'eagle';
        if (diff === -1) return 'birdie';
        if (diff === 0) return 'par';
        if (diff === 1) return 'bogey';
        return 'double';
      }
      
      // Toggle match details panel
      function toggleMatchDetails(matchKey) {
        const panel = document.getElementById(`match-details-${matchKey}`);
        const card = panel?.closest('.match-card');
        
        // Close other panels
        document.querySelectorAll('.match-details-panel').forEach(p => {
          if (p.id !== `match-details-${matchKey}`) {
            p.style.display = 'none';
            p.closest('.match-card')?.classList.remove('expanded');
          }
        });
        
        // Toggle this panel
        if (panel) {
          const isVisible = panel.style.display === 'block';
          panel.style.display = isVisible ? 'none' : 'block';
          card?.classList.toggle('expanded', !isVisible);
        }
      }

      // Render team leaderboard
      function renderTeamLeaderboard(changedPlayers = []) {
        const container = document.getElementById('leaderboard-body');
        const noData = document.getElementById('no-data');
        
        // If leaderboard is hidden, show message
        if (!isLeaderboardVisible) {
          container.innerHTML = '';
          noData.style.display = 'block';
          noData.innerHTML = `
            <div class="no-data-icon">🚫</div>
            <div>Leaderboard is currently unavailable</div>
          `;
          return;
        }
        
        const teams = getTeams();
        const teamScoresCount = parseInt(currentTournament.meta?.teamScoresCount) || 3;
        
        console.log('Rendering team leaderboard:', teams.length, 'teams');
        console.log('Teams data:', JSON.stringify(teams, null, 2));
        console.log('Admitted players count:', admittedPlayers.length);
        console.log('Admitted players IDs:', admittedPlayers.map(p => ({ reg: p.reg, playerId: p.playerId, name: p.firstName + ' ' + p.lastName })));
        
        if (teams.length === 0) {
          container.innerHTML = '';
          noData.style.display = 'block';
          noData.innerHTML = `
            <div class="no-data-icon">👥</div>
            <div>No teams configured</div>
            <div style="margin-top: 8px; font-size: 13px;">Please set up teams in the tournament settings</div>
          `;
          return;
        }
        
        // Calculate team scores
        const teamResults = teams.map(team => {
          console.log(`Processing team ${team.name}, players:`, team.players);
          
          const teamPlayers = (team.players || []).map(playerId => {
            const found = admittedPlayers.find(p => p.reg === playerId || p.playerId === playerId);
            console.log(`  Looking for player ${playerId}: ${found ? 'FOUND' : 'NOT FOUND'}`);
            return found;
          }).filter(p => p);
          
          console.log(`  Team ${team.name} matched ${teamPlayers.length} players`);
          
          // Get scores for each player
          const playerScoresData = teamPlayers.map(player => {
            const key = player.reg || `${player.firstName}-${player.lastName}`;
            const scoreData = calculateScore(key);
            
            return {
              ...player,
              ...scoreData,
              key
            };
          });
          
          // Sort by Stableford points (highest first) for best N
          const sortedPlayers = [...playerScoresData].sort((a, b) => {
            if (a.holesPlayed === 0 && b.holesPlayed === 0) return 0;
            if (a.holesPlayed === 0) return 1;
            if (b.holesPlayed === 0) return -1;
            return b.stablefordPoints - a.stablefordPoints;
          });
          
          // Take best N scores
          const countingPlayers = sortedPlayers.slice(0, teamScoresCount);
          const totalPoints = countingPlayers.reduce((sum, p) => sum + (p.stablefordPoints || 0), 0);
          const totalHolesPlayed = countingPlayers.reduce((sum, p) => sum + (p.holesPlayed || 0), 0);
          const avgHolesPlayed = countingPlayers.length > 0 ? Math.round(totalHolesPlayed / countingPlayers.length) : 0;
          
          // Check if any counting player is still playing
          const stillPlaying = countingPlayers.some(p => p.holesPlayed > 0 && p.holesPlayed < 18);
          const allFinished = countingPlayers.length > 0 && countingPlayers.every(p => p.holesPlayed === 18);
          
          return {
            teamId: team.teamId,
            teamName: team.name,
            players: sortedPlayers,
            countingPlayers,
            totalPoints,
            avgHolesPlayed,
            stillPlaying,
            allFinished,
            hasScores: countingPlayers.some(p => p.holesPlayed > 0)
          };
        });
        
        // Sort teams by total points (highest first)
        teamResults.sort((a, b) => {
          if (!a.hasScores && !b.hasScores) return 0;
          if (!a.hasScores) return 1;
          if (!b.hasScores) return -1;
          return b.totalPoints - a.totalPoints;
        });
        
        // Assign positions
        let currentPosition = 1;
        let previousPoints = null;
        teamResults.forEach((team, index) => {
          if (!team.hasScores) {
            team.position = '-';
          } else if (team.totalPoints === previousPoints) {
            team.position = teamResults[index - 1].position;
          } else {
            team.position = currentPosition;
          }
          previousPoints = team.totalPoints;
          currentPosition = index + 2;
        });
        
        // Check for no data
        const teamsWithScores = teamResults.filter(t => t.hasScores);
        if (teamsWithScores.length === 0) {
          document.getElementById('leaderboard-wrapper').style.display = 'none';
          noData.style.display = 'block';
          noData.innerHTML = `
            <div class="no-data-icon">⏳</div>
            <div>Waiting for scores...</div>
            <div style="margin-top: 8px; font-size: 13px;">${teams.length} teams ready</div>
          `;
          return;
        }
        
        noData.style.display = 'none';
        document.getElementById('leaderboard-wrapper').style.display = 'block';
        document.getElementById('stats-bar').style.display = 'grid';
        
        // Update stats for teams
        document.getElementById('stat-players').textContent = teams.length + ' teams';
        document.getElementById('stat-finished').textContent = teamResults.filter(t => t.allFinished).length;
        document.getElementById('stat-scoring').textContent = teamResults.filter(t => t.stillPlaying).length;
        
        if (teamsWithScores.length > 0) {
          const leader = teamsWithScores[0];
          document.getElementById('stat-leader').textContent = `${leader.totalPoints} pts`;
          document.getElementById('stat-leader').className = 'stat-value';
        }
        
        // Render team rows
        let html = '';
        
        teamResults.forEach(team => {
          const posClass = team.position <= 3 && team.position !== '-' ? 'top-3' : '';
          const statusIcon = team.allFinished ? '✓' : (team.stillPlaying ? '⛳' : '');
          
          // Team header row
          html += `
            <tr class="team-header-row" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); cursor: pointer;" onclick="toggleTeamPlayers('${team.teamId}')">
              <td class="position-cell ${posClass}" style="color: white; font-weight: 700;">${team.position}</td>
              <td style="color: white;">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="font-weight: 700; font-size: 15px;">🏆 ${team.teamName}</span>
                  <span style="opacity: 0.8; font-size: 12px;">(${team.countingPlayers.length}/${team.players.length} players)</span>
                  ${statusIcon ? `<span style="margin-left: auto;">${statusIcon}</span>` : ''}
                </div>
              </td>
              <td style="color: white; text-align: center; font-weight: 600;">${team.hasScores ? team.avgHolesPlayed : '-'}</td>
              <td style="color: white; text-align: center; font-weight: 700; font-size: 16px;">${team.hasScores ? team.totalPoints : '-'}</td>
            </tr>
          `;
          
          // Player rows (initially hidden)
          team.players.forEach((player, idx) => {
            const isCounting = idx < teamScoresCount && player.holesPlayed > 0;
            const countingStyle = isCounting ? 'background: rgba(34, 197, 94, 0.15);' : 'opacity: 0.7;';
            const countingBadge = isCounting ? '<span style="background: #22c55e; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 8px;">COUNTING</span>' : '';
            
            html += `
              <tr class="team-player-row" data-team="${team.teamId}" style="display: none; ${countingStyle}">
                <td style="padding-left: 24px; color: #64748b;">${isCounting ? '★' : ''}</td>
                <td>
                  <span style="font-weight: 500;">${player.firstName} ${player.lastName}</span>
                  ${countingBadge}
                </td>
                <td style="text-align: center;">${player.holesPlayed > 0 ? (player.holesPlayed === 18 ? 'F' : player.holesPlayed) : '-'}</td>
                <td style="text-align: center; font-weight: 600;">${player.holesPlayed > 0 ? player.stablefordPoints : '-'}</td>
              </tr>
            `;
          });
        });
        
        container.innerHTML = html;
      }
      
      // Toggle team players visibility
      function toggleTeamPlayers(teamId) {
        const playerRows = document.querySelectorAll(`.team-player-row[data-team="${teamId}"]`);
        playerRows.forEach(row => {
          row.style.display = row.style.display === 'none' ? 'table-row' : 'none';
        });
      }

      // Update stats
      function updateStats(players) {
        const playersWithScores = players.filter(p => p.thru > 0);
        const finishedPlayers = players.filter(p => p.thru === 18);
        const onCourse = playersWithScores.length - finishedPlayers.length;
        
        document.getElementById('stat-players').textContent = players.length;
        document.getElementById('stat-finished').textContent = finishedPlayers.length;
        document.getElementById('stat-scoring').textContent = onCourse;
        
        // Leader score
        if (playersWithScores.length > 0) {
          const leader = playersWithScores[0];
          const useStableford = isStablefordScoring();
          
          let leaderScore, isGoodScore;
          if (useStableford) {
            // Stableford: show points and +/- from expected
            const toParValue = leader.stablefordToPar;
            leaderScore = `${leader.stablefordPoints} pts` + (toParValue === 0 ? '' : (toParValue > 0 ? ` (+${toParValue})` : ` (${toParValue})`));
            isGoodScore = toParValue > 0; // Positive is good in Stableford
          } else {
            // Stroke play: show to par
            leaderScore = leader.toPar === 0 ? 'E' : (leader.toPar > 0 ? `+${leader.toPar}` : leader.toPar);
            isGoodScore = leader.toPar < 0; // Negative is good in stroke play
          }
          
          const statLeader = document.getElementById('stat-leader');
          statLeader.textContent = leaderScore;
          statLeader.className = 'stat-value ' + (isGoodScore ? 'red' : '');
        }
      }

      // Cleanup
      window.addEventListener('beforeunload', () => {
        if (firebaseListener && db) {
          db.ref(`liveScores/${currentRoundId}`).off('value', firebaseListener);
        }
      });
    </script>
  </body>
</html>
