<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Create Stroke Play Tournament</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>
    
    <link rel="stylesheet" href="../styles.css">
    <style>
      body { 
        padding-top: 0; 
        background: #f0f4f8; 
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      
      /* Top Navigation Bar */
      .top-nav {
        background: linear-gradient(135deg, #0b6efd 0%, #0a58d1 100%);
        padding: 16px 24px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: sticky;
        top: 0;
        z-index: 100;
      }
      .top-nav h1 { 
        margin: 0; 
        color: white; 
        font-size: 24px; 
        font-weight: 700; 
      }
      .btn-back-top {
        background: rgba(255,255,255,0.2);
        color: white;
        border: 1px solid rgba(255,255,255,0.3);
        padding: 8px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        text-decoration: none;
        transition: all 0.2s;
      }
      .btn-back-top:hover { background: rgba(255,255,255,0.3); }
      
      /* Action Buttons Container */
      .action-buttons-container {
        background: #f8fafc;
        padding: 12px 24px;
        border-bottom: 1px solid #e2e8f0;
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }
      
      .btn-save {
        background: linear-gradient(180deg, #28a745, #218838);
        color: white;
        border: 0;
        padding: 10px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        transition: all 0.2s;
      }
      .btn-save:hover { 
        opacity: 0.9; 
        transform: translateY(-1px); 
      }
      
      .form-card{max-width:1000px;margin:24px auto;padding:24px;background:#fff;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
      .field{margin-bottom:14px}
      .form-card label{display:block;font-weight:600;margin-bottom:6px;color:#374151;font-size:14px}
      .help-text{font-size:13px;color:#64748b;margin-top:4px}
      input[type="text"], input[type="date"], input[type="number"], select{width:100%;padding:10px 12px;border-radius:8px;border:2px solid #e5e7eb;font-size:15px;transition:border-color 0.2s}
      input[type="text"]:focus, input[type="date"]:focus, input[type="number"]:focus, select:focus{outline:none;border-color:#0b6efd}
      .row{display:flex;gap:12px}
      .row .field{flex:1}
      /* three-column compact row for small controls */
      .row.three { display:flex; gap:12px; align-items:flex-start; }
      .row.three .field { flex: 0 0 calc(33.333% - 8px); }
      /* rounds grid for 2 columns */
      .rounds-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
      .round-card { background: #f8fafc; padding: 16px; border-radius: 8px; border: 1px solid #e5e7eb; }
      .round-card .field { margin-bottom: 10px; }
      .round-card label { font-size: 13px; margin-bottom: 4px; }
      .round-card input, .round-card select { padding: 8px 10px; font-size: 14px; }
      .round-card .tee-row { display: flex; gap: 10px; }
      .round-card .tee-row .field { flex: 1; margin-bottom: 0; }
      .actions{display:none}
      .btn-primary{background:linear-gradient(180deg,var(--accent),#0a58d1);color:white;border:0;padding:10px 14px;border-radius:10px;cursor:pointer}
      .btn-secondary{background:white;border:1px solid #e6e9ef;padding:10px 14px;border-radius:10px;cursor:pointer}
      
      /* Section headers */
      .section-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid #e5e7eb;
      }
      .section-header-icon {
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #0b6efd 0%, #0a58d1 100%);
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
      }
      .section-header h2 {
        margin: 0;
        font-size: 18px;
        color: #1e293b;
      }
    </style>
  </head>
  <body>
    <!-- Top Navigation -->
    <div class="top-nav">
      <h1>‚õ≥ Create Stroke Play Tournament</h1>
      <a href="index.html" class="btn-back-top">‚Üê Back to Tournaments</a>
    </div>
    
    <!-- Action Buttons -->
    <div class="action-buttons-container">
      <button type="button" class="btn-save" onclick="document.getElementById('stroke-form').requestSubmit()">üíæ Save Tournament</button>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>
    <script src="../components/auth.js"></script>
    <script>
      (async function(){
        const { user, role } = await window.Auth.requireAuth();
        window.currentUserId = user.uid;
        window.currentUserRole = role;
      })();
    </script>
    <main class="container" style="max-width: 1000px; margin: 0 auto; padding: 24px;">

      <section class="form-card">
        <div class="section-header">
          <div class="section-header-icon">üèÜ</div>
          <h2>Tournament Details</h2>
        </div>
        
        <form id="stroke-form">
          <div class="field">
            <label for="tournament-name">Tournament name</label>
            <input id="tournament-name" name="name" type="text" required placeholder="e.g. Spring Invitational">
          </div>

          <!-- Tournament Type, Number of Rounds and Teams Tournament -->
          <div class="row" style="justify-content: flex-start;">
              <div class="field" style="flex:0 0 220px;">
                  <label for="tournament-type">Tournament Type</label>
                  <select id="tournament-type" name="tournamentType" required>
                    <option value="stroke" selected>Stroke Play</option>
                    <option value="match">Match Play</option>
                    <option value="bracket">Bracket Match Play</option>
                  </select>
              </div>
              <div class="field" style="flex:0 0 220px;" id="rounds-field">
                  <label for="rounds">Number of Rounds</label>
                  <select id="rounds" name="rounds" required>
                    <option value="1" selected>1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                  </select>
              </div>
              <div class="field" style="flex:0 0 220px;">
                  <label for="teams-tournament">Teams Tournament</label>
                  <select id="teams-tournament" name="teamsTournament" required>
                    <option value="no">No</option>
                    <option value="yes">Yes</option>
                  </select>
              </div>
          </div>

          <!-- HCP settings row -->
          <div class="row three" id="stroke-play-fields">
              <div class="field">
                <label for="hcp-qual">HCP qualifying</label>
                  <select id="hcp-qual" name="hcpQual" required>
                    <option value="yes" selected>Yes</option>
                    <option value="no">No</option>
                  </select>
              </div>
              <div class="field">
                <label for="hcp-allow">HCP allowance</label>
                <select id="hcp-allow" name="hcpAllow" required>
                  <option value="100">100%</option>
                  <option value="95">95%</option>
                  <option value="90">90%</option>
                  <option value="85">85%</option>
                  <option value="80">80%</option>
                  <option value="75">75%</option>
                  <option value="50">50%</option>
                </select>
              </div>
              <div class="field">
                <label for="max-score">Max Score</label>
                <select id="max-score" name="maxScore">
                  <option value="na">N/A</option>
                  <option value="net_double_bogey">Net double Bogey</option>
                  <option value="par_plus_4">Par +4</option>
                  <option value="double_par">Double Par</option>
                  <option value="10">10</option>
                </select>
              </div>
            </div>

            <!-- Bracket Match Play specific fields -->
            <div class="row" style="justify-content: flex-start;" id="bracket-fields">
              <div class="field" style="flex:0 0 220px;">
                  <label for="bracket-course">Course</label>
                  <select id="bracket-course" name="bracketCourse">
                    <option value="">-- Select course --</option>
                  </select>
              </div>
              <div class="field" style="flex:0 0 220px;">
                  <label for="bracket-start-date">Start Date</label>
                  <input type="date" id="bracket-start-date" name="bracketStartDate">
              </div>
              <div class="field" style="flex:0 0 220px;" id="team-format-field">
                  <label for="team-format">Match Format</label>
                  <select id="team-format" name="teamFormat">
                    <option value="fourball" selected>Fourball (Best Ball)</option>
                    <option value="foursomes">Foursomes (Alternate Shot)</option>
                  </select>
              </div>
            </div>

            <!-- Dynamic rounds container -->
            <div id="rounds-container" style="margin-top:20px;"></div>


          <div class="actions">
            <button type="submit" class="btn-primary">Save Tournament</button>
          </div>
        </form>

        <div id="result" style="margin-top:18px;color:#0b6efd;font-weight:600"></div>
      </section>
    </main>

    <script>
      const roundsContainer = document.getElementById('rounds-container');
      const roundsSelect = document.getElementById('rounds');
      const typeSelect = document.getElementById('tournament-type');
      let roundsState = [];
      
      // Load courses from localStorage
      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch(e) {
          console.error('Error loading courses:', e);
          return [];
        }
      }
      
      function getCourseOptions() {
        return getCourses().map(course => ({
          value: course.courseId || course.fullName,
          label: `${course.fullName || course.name} - ${course.city}`
        }));
      }

      const params = new URLSearchParams(window.location.search);
      const editIndexParam = params.get('edit'); // Legacy support
      const editIdParam = params.get('editId'); // New: edit by tournamentId
      const isEdit = editIndexParam !== null || editIdParam !== null;

      // Show/hide fields based on tournament type and teams selection
      function updateFieldsVisibility() {
        const strokePlayFields = document.getElementById('stroke-play-fields');
        const hcpQualField = document.getElementById('hcp-qual').closest('.field');
        const hcpAllowField = document.getElementById('hcp-allow').closest('.field');
        const maxScoreField = document.getElementById('max-score').closest('.field');
        const roundsField = document.getElementById('rounds-field');
        const bracketFields = document.getElementById('bracket-fields');
        const teamFormatField = document.getElementById('team-format-field');
        const teamsSelect = document.getElementById('teams-tournament');
        
        const selectedType = typeSelect ? typeSelect.value : 'stroke';
        const isTeams = teamsSelect && teamsSelect.value === 'yes';
        
        if (strokePlayFields) {
          if (selectedType === 'match') {
            // Match Play: hide all HCP fields, show rounds
            strokePlayFields.style.display = 'none';
            roundsField.style.display = 'block';
            bracketFields.style.display = 'none';
            document.getElementById('hcp-qual').removeAttribute('required');
            document.getElementById('hcp-allow').removeAttribute('required');
            document.getElementById('rounds').setAttribute('required', 'required');
          } else if (selectedType === 'bracket') {
            // Bracket Match Play: show only HCP allowance, hide rounds, show bracket fields
            strokePlayFields.style.display = 'flex';
            hcpQualField.style.display = 'none';
            hcpAllowField.style.display = 'block';
            maxScoreField.style.display = 'none';
            roundsField.style.display = 'none';
            bracketFields.style.display = 'flex';
            // Show team format only if teams tournament is selected
            teamFormatField.style.display = isTeams ? 'block' : 'none';
            document.getElementById('hcp-qual').removeAttribute('required');
            document.getElementById('hcp-allow').setAttribute('required', 'required');
            document.getElementById('rounds').removeAttribute('required');
          } else {
            // Stroke Play: show all fields, hide bracket fields
            strokePlayFields.style.display = 'flex';
            hcpQualField.style.display = 'block';
            hcpAllowField.style.display = 'block';
            maxScoreField.style.display = 'block';
            roundsField.style.display = 'block';
            bracketFields.style.display = 'none';
            document.getElementById('hcp-qual').setAttribute('required', 'required');
            document.getElementById('hcp-allow').setAttribute('required', 'required');
            document.getElementById('rounds').setAttribute('required', 'required');
          }
        }
        
        // Also update rounds container visibility and required attributes
        if (selectedType === 'bracket') {
          roundsContainer.style.display = 'none';
          // Remove required from all dynamic round fields
          const roundInputs = roundsContainer.querySelectorAll('input, select');
          roundInputs.forEach(input => input.removeAttribute('required'));
        } else {
          roundsContainer.style.display = 'block';
        }
      }
      
      // Backward compatibility alias
      function updateStrokePlayFieldsVisibility() {
        updateFieldsVisibility();
      }

      // Auto-fill dates: add one day to each subsequent round
      function autoFillDates(startDate) {
        if (!startDate) return;
        
        const numRounds = parseInt(roundsSelect.value, 10);
        const [year, month, day] = startDate.split('-').map(Number);
        
        for (let i = 2; i <= numRounds; i++) {
          const nextDate = new Date(year, month - 1, day);
          nextDate.setDate(nextDate.getDate() + (i - 1));
          
          const dateInput = document.getElementById(`date-${i}`);
          if (dateInput) {
            const yyyy = nextDate.getFullYear();
            const mm = String(nextDate.getMonth() + 1).padStart(2, '0');
            const dd = String(nextDate.getDate()).padStart(2, '0');
            dateInput.value = `${yyyy}-${mm}-${dd}`;
          }
        }
      }
      
      // Auto-fill courses: set same course for all rounds
      function autoFillCourses(courseId) {
        if (!courseId) return;
        
        const numRounds = parseInt(roundsSelect.value, 10);
        
        for (let i = 2; i <= numRounds; i++) {
          const courseSelect = document.getElementById(`course-${i}`);
          if (courseSelect) {
            courseSelect.value = courseId;
            // Trigger the change event to populate tees
            populateTeeSelectsForRound(i, courseId);
            autoSelectDefaultTees(i);
          }
        }
        
        // Also set default tees for round 1
        autoSelectDefaultTees(1);
      }
      
      // Auto-select default tees (Yellow for men, Red for women)
      function autoSelectDefaultTees(roundNumber) {
        const menSel = document.getElementById(`tee-men-${roundNumber}`);
        const womenSel = document.getElementById(`tee-women-${roundNumber}`);
        if (!menSel || !womenSel) return;
        
        // Look for Yellow tee in men's select
        for (let i = 0; i < menSel.options.length; i++) {
          const optText = menSel.options[i].textContent.toLowerCase();
          if (optText.includes('yellow')) {
            menSel.selectedIndex = i;
            break;
          }
        }
        
        // Look for Red tee in women's select
        for (let i = 0; i < womenSel.options.length; i++) {
          const optText = womenSel.options[i].textContent.toLowerCase();
          if (optText.includes('red')) {
            womenSel.selectedIndex = i;
            break;
          }
        }
      }

      // Populate tee selects for a specific round based on selected course
      function populateTeeSelectsForRound(roundNumber, courseId) {
        const courses = getCourses();
        const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
        const menSel = document.getElementById(`tee-men-${roundNumber}`);
        const womenSel = document.getElementById(`tee-women-${roundNumber}`);
        if (!menSel || !womenSel) return;

        // reset
        menSel.innerHTML = '<option value="">-- Select men\'s tee --</option>';
        womenSel.innerHTML = '<option value="">-- Select women\'s tee --</option>';

        if (!course || !Array.isArray(course.tees)) return;

        course.tees.forEach((teeName, idx) => {
          const gender = (course.genders && course.genders[idx]) ? course.genders[idx] : 'M';
          const value = `${course.courseId || course.fullName}||${idx}`;

          // Men: include M and B
          if (gender === 'M' || gender === 'B') {
            const opt = document.createElement('option');
            opt.value = value;
            opt.textContent = teeName;
            menSel.appendChild(opt);
          }

          // Women: include F and B
          if (gender === 'F' || gender === 'B') {
            const opt2 = document.createElement('option');
            opt2.value = value;
            opt2.textContent = teeName;
            womenSel.appendChild(opt2);
          }
        });
      }

      // Capture current round inputs so we can preserve on re-render
      function collectCurrentRoundsData() {
        // Count existing round cards in DOM (old count before re-render)
        const count = document.querySelectorAll('.round-card').length;
        for (let i = 1; i <= count; i++) {
          const dateEl = document.getElementById(`date-${i}`);
          const courseEl = document.getElementById(`course-${i}`);
          const menEl = document.getElementById(`tee-men-${i}`);
          const womenEl = document.getElementById(`tee-women-${i}`);
          const matchTypeEl = document.getElementById(`match-type-${i}`);
          const prev = roundsState[i-1] || {};
          roundsState[i-1] = {
            date: dateEl ? dateEl.value : (prev.date || ''),
            course: courseEl ? courseEl.value : (prev.course || ''),
            teeMen: menEl ? menEl.value : (prev.teeMen || ''),
            teeWomen: womenEl ? womenEl.value : (prev.teeWomen || ''),
            matchType: matchTypeEl ? matchTypeEl.value : (prev.matchType || '')
          };
        }
        // Do not truncate roundsState when decreasing; keep extra indices for restoration
        return roundsState.slice();
      }

      function renderRounds() {
        // Don't render rounds for bracket tournaments
        const currentType = typeSelect ? typeSelect.value : 'stroke';
        if (currentType === 'bracket') {
          roundsContainer.innerHTML = '';
          return;
        }
        
        const prev = collectCurrentRoundsData();
        const numRounds = parseInt(roundsSelect.value, 10);
        roundsContainer.innerHTML = '';
        
        // Create grid container
        const grid = document.createElement('div');
        grid.className = 'rounds-grid';
        roundsContainer.appendChild(grid);

        for (let i = 1; i <= numRounds; i++) {
          // Create round card
          const roundCard = document.createElement('div');
          roundCard.className = 'round-card';
          
          // Round header
          const roundLabel = document.createElement('label');
          roundLabel.textContent = `Round ${i}`;
          roundLabel.style.fontWeight = '600';
          roundLabel.style.fontSize = '15px';
          roundLabel.style.display = 'block';
          roundLabel.style.marginBottom = '12px';
          roundLabel.style.color = '#374151';
          roundCard.appendChild(roundLabel);

          // Date field
          const dateField = document.createElement('div');
          dateField.className = 'field';
          const dateLabel = document.createElement('label');
          dateLabel.htmlFor = `date-${i}`;
          dateLabel.textContent = 'Date';
          const dateInput = document.createElement('input');
          dateInput.type = 'date';
          dateInput.id = `date-${i}`;
          dateInput.name = `date-${i}`;
          // Only set required if not bracket type
          const currentType = typeSelect ? typeSelect.value : 'stroke';
          if (currentType !== 'bracket') {
            dateInput.required = true;
          }
          // Re-apply previous date if exists; otherwise auto-fill from Round 1
          if (prev[i-1] && prev[i-1].date) {
            dateInput.value = prev[i-1].date;
          } else if (i > 1 && prev[0] && prev[0].date) {
            const [y,m,d] = (prev[0].date || '').split('-').map(Number);
            if (y && m && d) {
              const dt = new Date(y, m-1, d);
              dt.setDate(dt.getDate() + (i-1));
              const yyyy = dt.getFullYear();
              const mm = String(dt.getMonth()+1).padStart(2,'0');
              const dd = String(dt.getDate()).padStart(2,'0');
              dateInput.value = `${yyyy}-${mm}-${dd}`;
              roundsState[i-1] = roundsState[i-1] || {};
              roundsState[i-1].date = dateInput.value;
            }
          }
          
          // Auto-fill dates: when first round date changes, update subsequent rounds
          if (i === 1) {
            dateInput.addEventListener('change', function() {
              autoFillDates(this.value);
            });
          }
          
          dateField.appendChild(dateLabel);
          dateField.appendChild(dateInput);
          roundCard.appendChild(dateField);

          // Course field
          const courseField = document.createElement('div');
          courseField.className = 'field';
          const courseLabel = document.createElement('label');
          courseLabel.htmlFor = `course-${i}`;
          courseLabel.textContent = 'Course';
          const courseSelect = document.createElement('select');
          courseSelect.id = `course-${i}`;
          courseSelect.name = `course-${i}`;
          // Only set required if not bracket type
          if (currentType !== 'bracket') {
            courseSelect.required = true;
          }
          
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = '-- Select a course --';
          courseSelect.appendChild(defaultOption);

          const courseOptions = getCourseOptions();
          courseOptions.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            courseSelect.appendChild(option);
          });

          // Set default course to TGF Silivri Golf Course for round 1 (if not editing)
          if (i === 1 && !isEdit && !prev[0]?.course) {
            const defaultCourse = courseOptions.find(opt => 
              opt.label.toLowerCase().includes('silivri') || 
              opt.value.toLowerCase().includes('silivri')
            );
            if (defaultCourse) {
              courseSelect.value = defaultCourse.value;
              // Populate tees for default course
              setTimeout(() => {
                populateTeeSelectsForRound(1, defaultCourse.value);
                autoSelectDefaultTees(1);
              }, 0);
            }
          }

          // Listen for course change to populate tee selects and auto-fill
          courseSelect.addEventListener('change', function() {
            populateTeeSelectsForRound(i, this.value);
            
            // Auto-fill course for other rounds when first round changes
            if (i === 1) {
              autoFillCourses(this.value);
            }
          });

          courseField.appendChild(courseLabel);
          courseField.appendChild(courseSelect);
          roundCard.appendChild(courseField);

          // Tee selections in a row
          const teeRow = document.createElement('div');
          teeRow.className = 'tee-row';
          
          // Default Tee Men field
          const teeMenField = document.createElement('div');
          teeMenField.className = 'field';
          const teeMenLabel = document.createElement('label');
          teeMenLabel.htmlFor = `tee-men-${i}`;
          teeMenLabel.textContent = 'Tee (Men)';
          const teeMenSelect = document.createElement('select');
          teeMenSelect.id = `tee-men-${i}`;
          teeMenSelect.name = `tee-men-${i}`;
          teeMenSelect.innerHTML = '<option value="">-- Select --</option>';
          teeMenField.appendChild(teeMenLabel);
          teeMenField.appendChild(teeMenSelect);
          teeRow.appendChild(teeMenField);

          // Default Tee Women field
          const teeWomenField = document.createElement('div');
          teeWomenField.className = 'field';
          const teeWomenLabel = document.createElement('label');
          teeWomenLabel.htmlFor = `tee-women-${i}`;
          teeWomenLabel.textContent = 'Tee (Women)';
          const teeWomenSelect = document.createElement('select');
          teeWomenSelect.id = `tee-women-${i}`;
          teeWomenSelect.name = `tee-women-${i}`;
          teeWomenSelect.innerHTML = '<option value="">-- Select --</option>';
          teeWomenField.appendChild(teeWomenLabel);
          teeWomenField.appendChild(teeWomenSelect);
          teeRow.appendChild(teeWomenField);
          
          roundCard.appendChild(teeRow);

          // Match Type field (only for match play tournaments) - placed after tee selections
          const isMatchPlay = typeSelect && (typeSelect.value === 'match' || typeSelect.value === 'bracket');
          if (isMatchPlay && currentType !== 'bracket') {
            const matchTypeField = document.createElement('div');
            matchTypeField.className = 'field';
            const matchTypeLabel = document.createElement('label');
            matchTypeLabel.htmlFor = `match-type-${i}`;
            matchTypeLabel.textContent = 'Match Type';
            const matchTypeSelect = document.createElement('select');
            matchTypeSelect.id = `match-type-${i}`;
            matchTypeSelect.name = `match-type-${i}`;
            matchTypeSelect.required = true;
            
            const matchOptions = [
              { value: '', text: '-- Select match type --' },
              { value: 'singles', text: 'Singles' },
              { value: 'fourball', text: 'Fourball' },
              { value: 'foursomes', text: 'Foursomes' }
            ];
            
            matchOptions.forEach(opt => {
              const option = document.createElement('option');
              option.value = opt.value;
              option.textContent = opt.text;
              matchTypeSelect.appendChild(option);
            });
            
            // Restore previous value if exists
            if (prev[i-1] && prev[i-1].matchType) {
              matchTypeSelect.value = prev[i-1].matchType;
            }
            
            matchTypeField.appendChild(matchTypeLabel);
            matchTypeField.appendChild(matchTypeSelect);
            roundCard.appendChild(matchTypeField);
          }
          grid.appendChild(roundCard);

          // Now that elements are in the DOM, re-apply previous course/tees if present
          if (prev[i-1] && prev[i-1].course) {
            const prevCourse = prev[i-1].course;
            courseSelect.value = prevCourse;
            // Populate tees for this course then set selected options
            populateTeeSelectsForRound(i, prevCourse);
            const { teeMen, teeWomen } = prev[i-1];
            const menEl = document.getElementById(`tee-men-${i}`);
            const womenEl = document.getElementById(`tee-women-${i}`);
            if (menEl && teeMen) menEl.value = teeMen;
            if (womenEl && teeWomen) womenEl.value = teeWomen;
          } else if (i > 1 && prev[0] && prev[0].course) {
            // For newly added rounds, auto-fill from Round 1
            const baseCourse = prev[0].course;
            if (baseCourse) {
              courseSelect.value = baseCourse;
              populateTeeSelectsForRound(i, baseCourse);
              autoSelectDefaultTees(i);
              roundsState[i-1] = roundsState[i-1] || {};
              roundsState[i-1].course = baseCourse;
              const menEl = document.getElementById(`tee-men-${i}`);
              const womenEl = document.getElementById(`tee-women-${i}`);
              roundsState[i-1].teeMen = menEl ? menEl.value : '';
              roundsState[i-1].teeWomen = womenEl ? womenEl.value : '';
            }
          }
        }
      }

      roundsSelect.addEventListener('change', renderRounds);
      
      // Re-render rounds when tournament type changes to show/hide match type field
      if (typeSelect) {
        typeSelect.addEventListener('change', function() {
          updateFieldsVisibility();
          renderRounds();
        });
      }
      
      // Update visibility when teams tournament selection changes
      const teamsSelect = document.getElementById('teams-tournament');
      if (teamsSelect) {
        teamsSelect.addEventListener('change', function() {
          updateFieldsVisibility();
        });
      }

      // Populate bracket course dropdown
      function populateBracketCourse() {
        const bracketCourseSelect = document.getElementById('bracket-course');
        if (!bracketCourseSelect) return;
        
        // Clear existing options except the first one
        bracketCourseSelect.innerHTML = '<option value="">-- Select course --</option>';
        
        const courseOptions = getCourseOptions();
        courseOptions.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt.value;
          option.textContent = opt.label;
          bracketCourseSelect.appendChild(option);
        });
      }

      // Initialize form: if editing, populate from localStorage
      function initForm() {
        // Populate bracket course dropdown
        populateBracketCourse();
        
        if (!isEdit) {
          updateFieldsVisibility();
          renderRounds();
          return;
        }

        try {
          const raw = localStorage.getItem('tournaments');
          const arr = raw ? JSON.parse(raw) : [];
          
          // Find tournament by ID (preferred) or by index (legacy)
          let t;
          if (editIdParam) {
            t = arr.find(tournament => tournament.tournamentId === editIdParam);
          } else if (editIndexParam !== null) {
            t = arr[parseInt(editIndexParam, 10)];
          }
          
          if (!t) { 
            console.error('Tournament not found for editing');
            updateFieldsVisibility();
            renderRounds(); 
            return; 
          }

          if (typeSelect && t.type) {
            const typeLower = t.type.toLowerCase();
            if (typeLower.includes('bracket')) {
              typeSelect.value = 'bracket';
            } else if (typeLower.includes('match')) {
              typeSelect.value = 'match';
            } else {
              typeSelect.value = 'stroke';
            }
          }
          
          // Update visibility based on loaded type
          updateFieldsVisibility();

          document.getElementById('tournament-name').value = t.name || '';
          
          // Only process rounds for non-bracket tournaments
          const isBracketType = typeSelect && typeSelect.value === 'bracket';
          if (!isBracketType) {
            const roundsVal = (t.meta && t.meta.rounds) ? String(t.meta.rounds) : '1';
            roundsSelect.value = roundsVal;
            
            // Populate round-specific data BEFORE rendering
            const roundsData = (t.meta && t.meta.roundsData) ? t.meta.roundsData : [];
            // Seed persistent state so changes in round count preserve values
            // This MUST be done before renderRounds() so the loaded data is used
            roundsState = roundsData.slice();
            
            renderRounds();

            const numRounds = parseInt(roundsVal, 10);
            
            for (let i = 0; i < numRounds; i++) {
              const roundData = roundsData[i] || {};
              const roundNum = i + 1;
              
              // Set date
              const dateInput = document.getElementById(`date-${roundNum}`);
              if (dateInput && roundData.date) dateInput.value = roundData.date;
              
              // Set course
              const courseSelect = document.getElementById(`course-${roundNum}`);
              if (courseSelect && roundData.course) {
                courseSelect.value = roundData.course;
                // Populate tee selects for this course
                populateTeeSelectsForRound(roundNum, roundData.course);
                
                // Set tee selections after populating
                setTimeout(() => {
                  const teeMenSelect = document.getElementById(`tee-men-${roundNum}`);
                  const teeWomenSelect = document.getElementById(`tee-women-${roundNum}`);
                  if (teeMenSelect && roundData.teeMen) teeMenSelect.value = roundData.teeMen;
                if (teeWomenSelect && roundData.teeWomen) teeWomenSelect.value = roundData.teeWomen;
                
                // Set match type if it exists
                const matchTypeSelect = document.getElementById(`match-type-${roundNum}`);
                if (matchTypeSelect && roundData.matchType) {
                  matchTypeSelect.value = roundData.matchType;
                }
              }, 50);
            }
          }
          } // end if (!isBracketType)

          if (t.meta && t.meta.hcpQual) document.getElementById('hcp-qual').value = t.meta.hcpQual;
          if (t.meta && t.meta.hcpAllow) document.getElementById('hcp-allow').value = t.meta.hcpAllow;
          if (t.meta && t.meta.maxScore) document.getElementById('max-score').value = t.meta.maxScore;
          if (t.meta && t.meta.teamsTournament) document.getElementById('teams-tournament').value = t.meta.teamsTournament;
          
          // Bracket Match Play specific fields
          // Seeding method is now selected in bracket.html, not here
          if (t.meta && t.meta.teamFormat) {
            const teamFormatSelect = document.getElementById('team-format');
            if (teamFormatSelect) teamFormatSelect.value = t.meta.teamFormat;
          }
          // Load bracket start date (use main date field for bracket tournaments)
          if (isBracketType && t.date) {
            const bracketStartDateInput = document.getElementById('bracket-start-date');
            if (bracketStartDateInput) bracketStartDateInput.value = t.date;
          }
          // Load bracket course
          if (isBracketType && t.course) {
            const bracketCourseSelect = document.getElementById('bracket-course');
            if (bracketCourseSelect) bracketCourseSelect.value = t.course;
          }
          
          // Update field visibility after loading values
          updateFieldsVisibility();
        } catch (err) {
          console.error('Failed to load tournament for edit', err);
          renderRounds();
        }
      }

      // Load data from Firebase before initializing form
      // v2 - Fixed to render immediately
      async function loadDataAndInit() {
        // Render rounds immediately so UI appears
        renderRounds();
        
        // Wait for Firebase to be ready
        let attempts = 0;
        while (!syncEnabled && attempts < 10) {
          await new Promise(resolve => setTimeout(resolve, 200));
          attempts++;
        }
        
        // Load courses and tournaments from Firebase if available
        if (syncEnabled) {
          try {
            if (typeof loadCoursesFromFirebase !== 'undefined') {
              await loadCoursesFromFirebase();
              console.log('‚úì Courses loaded from Firebase');
            }
            if (typeof loadTournamentsFromFirebase !== 'undefined') {
              await loadTournamentsFromFirebase();
              console.log('‚úì Tournaments loaded from Firebase');
            }
            // Re-render rounds with loaded course data
            initForm();
          } catch(e) {
            console.log('Firebase load error:', e);
          }
        } else {
          // Firebase not available, just initialize form
          initForm();
        }
      }

      // Start initialization
      loadDataAndInit();

      async function getNextTournamentId(tournamentType) {
        try {
          const raw = localStorage.getItem('tournaments');
          const tournaments = raw ? JSON.parse(raw) : [];
          let prefix;
          if (tournamentType === 'bracket') {
            prefix = 'B';
          } else if (tournamentType === 'match') {
            prefix = 'M';
          } else {
            prefix = 'T';
          }
          const currentUserId = window.currentUserId;
          
          // Get user profile to extract login name for club users
          let userPrefix = '';
          if (window.currentUserRole !== 'admin' && currentUserId) {
            try {
              const profile = await window.Auth.getUserProfile();
              if (profile && profile.loginName) {
                // Generate base prefix from first 3 characters
                let basePrefix = profile.loginName.substring(0, 3).toUpperCase();
                
                // Check if this prefix is already used by another user
                const existingPrefixes = new Set();
                tournaments.forEach(t => {
                  if (t.tournamentId && t.tournamentId.includes('-') && t.createdBy && t.createdBy !== currentUserId) {
                    const otherPrefix = t.tournamentId.split('-')[0];
                    existingPrefixes.add(otherPrefix);
                  }
                });
                
                // If prefix conflicts, add a number suffix
                if (existingPrefixes.has(basePrefix)) {
                  let counter = 2;
                  while (existingPrefixes.has(basePrefix + counter)) {
                    counter++;
                  }
                  basePrefix = basePrefix + counter;
                }
                
                userPrefix = basePrefix + '-';
              }
            } catch(e) {
              console.error('Error getting user profile:', e);
            }
          }
          
          // For clubs, filter by their tournaments only
          let userTournaments = tournaments;
          if (window.currentUserRole !== 'admin' && currentUserId) {
            userTournaments = tournaments.filter(t => t.createdBy === currentUserId);
          }
          
          // Build the full prefix (e.g., "KLA-T" or "KLA2-T" or just "T" for admin)
          const fullPrefix = userPrefix + prefix;
          
          if (userTournaments.length === 0) {
            return fullPrefix + '0001';
          }
          
          // Find the highest existing tournament ID with the same prefix
          let maxId = 0;
          userTournaments.forEach(tournament => {
            if (tournament.tournamentId && tournament.tournamentId.startsWith(fullPrefix)) {
              // Extract number after the prefix
              const numStr = tournament.tournamentId.substring(fullPrefix.length);
              const num = parseInt(numStr);
              if (!isNaN(num) && num > maxId) maxId = num;
            }
          });
          
          return fullPrefix + String(maxId + 1).padStart(4, '0');
        } catch(e) {
          console.error('Error generating tournament ID:', e);
          let fallbackPrefix = 'T';
          if (tournamentType === 'bracket') fallbackPrefix = 'B';
          else if (tournamentType === 'match') fallbackPrefix = 'M';
          return fallbackPrefix + '0001';
        }
      }

      function generateRoundIds(tournamentId, numRounds) {
        const roundIds = [];
        for (let i = 1; i <= numRounds; i++) {
          roundIds.push(`${tournamentId}-${i}`);
        }
        return roundIds;
      }

      document.getElementById('stroke-form').addEventListener('submit', async function (e) {
        e.preventDefault();
        
        // Show saving indicator
        const resultEl = document.getElementById('result');
        resultEl.textContent = 'Saving...';
        resultEl.style.color = 'blue';
        
        try {
        const data = new FormData(e.target);
        
        const selectedType = data.get('tournamentType') || 'stroke';
        const isTeamsTournament = data.get('teamsTournament') === 'yes';
        const isBracket = selectedType === 'bracket';
        
        // Collect round-specific data (only for non-bracket tournaments)
        let numRounds = 1;
        let roundsData = [];
        
        if (!isBracket) {
          numRounds = parseInt(data.get('rounds'), 10);
          const isMatchPlay = selectedType === 'match';
          
          for (let i = 1; i <= numRounds; i++) {
            const roundData = {
              date: data.get(`date-${i}`) || '',
              course: data.get(`course-${i}`) || '',
              teeMen: data.get(`tee-men-${i}`) || '',
              teeWomen: data.get(`tee-women-${i}`) || ''
            };
            
            if (isMatchPlay) {
              roundData.matchType = data.get(`match-type-${i}`) || '';
            }
            
            roundsData.push(roundData);
          }
        }
        
        // Generate or preserve tournament ID
        let tournamentId;
        let roundIds = null;
        
        try {
          const raw = localStorage.getItem('tournaments');
          const tournaments = raw ? JSON.parse(raw) : [];
          
          if (isEdit) {
            // Find existing tournament by ID (preferred) or index (legacy)
            let existingTournament;
            if (editIdParam) {
              existingTournament = tournaments.find(t => t.tournamentId === editIdParam);
            } else if (editIndexParam !== null) {
              existingTournament = tournaments[parseInt(editIndexParam, 10)];
            }
            // Preserve existing tournament ID
            tournamentId = (existingTournament && existingTournament.tournamentId) ? existingTournament.tournamentId : await getNextTournamentId(selectedType);
          } else {
            // New tournament - generate new ID based on type
            tournamentId = await getNextTournamentId(selectedType);
          }
          
          // Generate round IDs based on number of rounds (only for non-bracket)
          if (!isBracket) {
            roundIds = generateRoundIds(tournamentId, numRounds);
          }
        } catch(e) {
          console.error('Error generating IDs:', e);
          let fallbackPrefix = 'T';
          if (selectedType === 'bracket') fallbackPrefix = 'B';
          else if (selectedType === 'match') fallbackPrefix = 'M';
          tournamentId = fallbackPrefix + '0001';
          if (!isBracket) {
            roundIds = generateRoundIds(tournamentId, numRounds);
          }
        }

        // Use the first round's date as the main tournament date, or bracket start date for bracket tournaments
        let mainDate;
        if (isBracket) {
          mainDate = data.get('bracketStartDate') || '';
        } else {
          mainDate = roundsData[0]?.date || '';
        }
        
        // Determine tournament type string
        let tournamentType;
        
        if (selectedType === 'bracket') {
          tournamentType = isTeamsTournament ? 'Bracket Match Play (Teams)' : 'Bracket Match Play';
        } else if (selectedType === 'match') {
          tournamentType = isTeamsTournament ? 'Match Play (Teams)' : 'Match Play';
        } else {
          tournamentType = isTeamsTournament ? 'Stroke Play (Teams)' : 'Stroke Play';
        }

        // Declare entry outside try block so it's accessible later
        let entry = null;
        
        // Persist to localStorage so the tournaments list shows this entry.
        try {
          const raw = localStorage.getItem('tournaments');
          const arr = raw ? JSON.parse(raw) : [];
          
          // Get current user's club ID
          let userClubId = null;
          try {
            if (firebase.auth().currentUser) {
              const userProfileDoc = await firebase.firestore().collection('users').doc(firebase.auth().currentUser.uid).get();
              if (userProfileDoc.exists) {
                const userData = userProfileDoc.data();
                userClubId = userData.clubId || userData.club || null;
              }
            }
          } catch (e) {
            console.warn('Could not get user club info:', e);
          }
          
          // Build entry object - Firebase doesn't accept undefined, so use null instead
          const bracketCourse = data.get('bracketCourse') || null;
          console.log('Bracket course from form:', bracketCourse);
          
          entry = { 
            tournamentId: tournamentId,
            date: mainDate || '', 
            name: data.get('name') || '', 
            type: tournamentType || 'Stroke Play',
            course: selectedType === 'bracket' ? bracketCourse : null,
            meta: { 
              rounds: selectedType === 'bracket' ? null : numRounds, 
              roundIds: selectedType === 'bracket' ? null : roundIds,
              roundsData: selectedType === 'bracket' ? null : roundsData,
              hcpQual: data.get('hcpQual') || null, 
              hcpAllow: data.get('hcpAllow') || null, 
              maxScore: data.get('maxScore') || null,
              teamsTournament: data.get('teamsTournament') || null,
              // Bracket Match Play specific fields
              // seedingMethod is now selected in bracket.html
              teamFormat: (selectedType === 'bracket' && isTeamsTournament) ? (data.get('teamFormat') || null) : null
            },
            createdBy: (window.currentUserId || null),
            createdByClub: (userClubId || null)
          };
          
          console.log('Entry course field:', entry.course);
          
          if (isEdit) {
            // Find tournament by ID (preferred) or index (legacy)
            let idx = -1;
            if (editIdParam) {
              idx = arr.findIndex(t => t.tournamentId === editIdParam);
            } else if (editIndexParam !== null) {
              idx = parseInt(editIndexParam, 10);
            }
            
            if (idx !== -1 && arr[idx]) {
              // Preserve existing categories and result preferences
              if (arr[idx].categories) {
                entry.categories = arr[idx].categories;
              }
              if (arr[idx].resultPreferences) {
                entry.resultPreferences = arr[idx].resultPreferences;
              }
              arr[idx] = entry;
            } else {
              arr.push(entry);
            }
          } else {
            arr.push(entry);
          }
          localStorage.setItem('tournaments', JSON.stringify(arr));
          
          // Sync to Firebase and wait for completion before redirect
          if (typeof syncToFirebase !== 'undefined' && syncEnabled) {
            document.getElementById('result').textContent = 'Saving to cloud...';
            try {
              // Direct update to Firebase - just update this specific tournament
              // This is more reliable than re-uploading all tournaments
              await firebase.database().ref(`tournaments/${tournamentId}`).set(entry);
            } catch(e) {
              console.error('Firebase sync failed:', e);
              alert('Warning: Cloud sync failed: ' + e.message + '\n\nChanges saved locally only.');
            }
          }
        } catch (err) {
          console.error('Failed to save tournament', err);
          document.getElementById('result').textContent = 'Error saving tournament.';
          alert('Error saving tournament: ' + err.message);
          return;
        }

        // Redirect back to tournaments list so the updated/created entry appears
        window.location.href = 'index.html';
        
        } catch (outerErr) {
          console.error('Unexpected error:', outerErr);
          alert('Error: ' + outerErr.message);
        }
      });
    </script>
  </body>
</html>
