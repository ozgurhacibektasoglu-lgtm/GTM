<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Score Entry</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      body{padding-top:70px}
      .scores-container { max-width: 1600px; margin: 24px auto; padding: 16px; }
      .round-selector { background: #fff; border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .round-selector label { display: block; font-weight: 600; margin-bottom: 8px; }
      .round-selector select { padding: 10px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 15px; min-width: 200px; }
      .scores-grid { display: grid; grid-template-columns: 1fr 400px; gap: 20px; }
      .scorecard-panel { background: #fff; border-radius: 12px; padding: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .players-panel { background: #fff; border-radius: 12px; padding: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .player-info { background: #f8fafc; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
      .player-info h3 { margin: 0 0 8px 0; color: #1e293b; font-size: 18px; }
      .player-info-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; font-size: 13px; }
      .info-item { display: flex; flex-direction: column; }
      .info-label { color: #64748b; font-weight: 600; margin-bottom: 2px; }
      .info-value { color: #1e293b; font-weight: 500; }
      .search-box { margin-bottom: 12px; }
      .search-box input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 14px; }
      .table-wrapper { overflow: auto; max-height: calc(100vh - 240px); border-radius: 8px; }
      .scorecard-table { width: 100%; border-collapse: collapse; font-size: 13px; }
      .scorecard-table th { background: #1e293b; color: white; padding: 8px 4px; text-align: center; font-size: 12px; font-weight: 600; min-width: 45px; }
      .scorecard-table td { padding: 6px 4px; text-align: center; border: 1px solid #e5e7eb; font-size: 13px; }
      .scorecard-table td:first-child { text-align: left; font-weight: 600; background: #f8fafc; min-width: 70px; }
      .scorecard-table .subtotal-cell { background: #f1f5f9; font-weight: 600; }
      .scorecard-table .total-cell { background: #dbeafe; font-weight: 700; }
      .score-input { width: 40px; padding: 4px; border-radius: 4px; border: 1px solid #e6e9ef; text-align: center; font-size: 13px; }
      .score-input:focus { outline: none; border-color: #3b82f6; background: #eff6ff; }
      .score-input.has-value { background: #dcfce7; border-color: #86efac; }
      .score-input:disabled { background: #f1f5f9; cursor: not-allowed; opacity: 0.6; }
      /* Score type styling */
      .score-input.score-par { background: white; color: black; border-color: #94a3b8; }
      .score-input.score-birdie { background: #dc2626; color: white; border-color: #991b1b; font-weight: 600; }
      .score-input.score-eagle { background: #fbbf24; color: black; border-color: #d97706; font-weight: 600; }
      .score-input.score-bogey { background: black; color: white; border-color: #1e293b; font-weight: 600; }
      .score-input.score-double-bogey { background: #2563eb; color: white; border-color: #1e40af; font-weight: 600; }
      .score-input.score-zero { background: #9ca3af; color: black; border-color: #6b7280; font-weight: 600; }
      .status-select { padding: 4px 8px; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 13px; background: white; cursor: pointer; }
      .status-select:focus { outline: none; border-color: #3b82f6; }
      .status-warning { background: #fef3c7; border: 1px solid #fbbf24; color: #92400e; padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 13px; text-align: center; font-weight: 500; }
      .status-warning { background: #fef3c7; border-color: #fbbf24; color: #92400e; padding: 8px 12px; border-radius: 6px; margin-top: 8px; font-size: 13px; text-align: center; font-weight: 500; }
      .scorecard-table input[type="number"]::-webkit-outer-spin-button,
      .scorecard-table input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; appearance: none; margin: 0; }
      .scorecard-table input[type="number"] { -moz-appearance: textfield; appearance: textfield; }
      .players-table { width: 100%; border-collapse: collapse; }
      .players-table th { position: sticky; top: 0; background: #f8fafc; padding: 10px 8px; border-bottom: 2px solid #e6e9ef; font-weight: 600; text-align: left; font-size: 13px; }
      .players-table td { padding: 10px 8px; border-bottom: 1px solid #f1f5f9; font-size: 14px; }
      .players-table tr { cursor: pointer; }
      .players-table tr:hover { background: #f0f9ff; }
      .players-table tr.selected { background: #dbeafe; font-weight: 600; }
      .players-table tr.completed { background: #d1fae5; }
      .players-table tr.completed:hover { background: #a7f3d0; }
      .players-table tr.completed.selected { background: #86efac; }
      .player-total-score { color: #059669; font-weight: 600; margin-left: 8px; font-size: 12px; }
      .empty-state { text-align: center; padding: 40px; color: #94a3b8; }
      .empty-state-icon { font-size: 48px; margin-bottom: 12px; }
      .btn-back { background: white; border: 1px solid #e6e9ef; padding: 10px 14px; border-radius: 8px; cursor: pointer; font-size: 14px; color: #333; text-decoration: none; display: inline-block; }
      
      /* Action Buttons - Below Header */
      .action-buttons-container {
        background: #f8fafc;
        padding: 12px 24px;
        border-bottom: 1px solid #e2e8f0;
      }
      .action-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        max-width: 1200px;
        margin: 0 auto;
      }
      .btn-action { background: linear-gradient(180deg, #28a745, #218838); color: white; border: 0; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.2s; }
      .btn-action:hover { opacity: 0.9; transform: translateY(-1px); }
      .btn-action:active { transform: translateY(1px); }
      .status-text { font-size: 13px; color: #64748b; margin-bottom: 8px; }
      .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 1000; }
      .modal-overlay.active { display: flex; }
      .modal-box { background: white; border-radius: 12px; padding: 32px; min-width: 400px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
      .modal-box h3 { margin: 0 0 20px 0; font-size: 20px; color: #1e293b; text-align: center; }
      .modal-box p { margin: 0 0 24px 0; color: #64748b; text-align: center; font-size: 15px; }
      .modal-buttons { display: flex; gap: 12px; }
      .modal-buttons button { flex: 1; padding: 12px 20px; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
      .modal-btn-primary { background: #3b82f6; color: white; border: 0; }
      .modal-btn-primary:hover { background: #2563eb; }
      .modal-btn-secondary { background: #f1f5f9; color: #1e293b; border: 1px solid #e2e8f0; }
      .modal-btn-secondary:hover { background: #e2e8f0; }
      .modal-input { width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; text-align: center; margin-bottom: 20px; }
      .modal-input:focus { outline: none; border-color: #3b82f6; }
      
      /* Match Score Entry Styles */
      .match-scores-container { display: none; }
      .match-scores-container.active { display: block; }
      .match-list { display: flex; flex-direction: column; gap: 16px; }
      .match-card { display: flex; align-items: center; gap: 12px; background: white; border-radius: 12px; padding: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
      .match-team { flex: 1; padding: 16px; border-radius: 8px; position: relative; }
      .match-team.left { background: linear-gradient(135deg, #e0f2fe 0%, #f0e7fa 100%); border-left: 4px solid #8b5cf6; }
      .match-team.right { background: linear-gradient(135deg, #fce7f3 0%, #e0f2fe 100%); border-right: 4px solid #ec4899; }
      .match-team-name { font-size: 14px; font-weight: 600; color: #dc2626; margin-bottom: 8px; }
      .match-team-name::before { content: 'üìÅ '; }
      .match-player { font-size: 15px; font-weight: 600; color: #1e293b; margin-bottom: 4px; }
      .match-player-hcp { font-size: 13px; color: #64748b; font-weight: 500; }
      .match-vs { display: flex; align-items: center; gap: 8px; font-weight: 700; color: #64748b; font-size: 14px; }
      .match-score-input { width: 48px; height: 48px; border: 3px solid #22c55e; border-radius: 8px; text-align: center; font-size: 20px; font-weight: 700; background: white; -moz-appearance: textfield; }
      .match-score-input::-webkit-outer-spin-button, .match-score-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
      .match-score-input:focus { outline: none; border-color: #16a34a; background: #f0fdf4; }
      .match-score-input.has-score { background: #dcfce7; }
      .match-score-input.winner { background: #22c55e; color: white; border-color: #16a34a; }
      .match-score-input.loser { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
      .match-score-input.tied { background: #fef3c7; color: #92400e; border-color: #fcd34d; }
      .match-status { text-align: center; margin-top: 8px; font-size: 12px; font-weight: 600; }
      .match-status.pending { color: #64748b; }
      .match-status.completed { color: #16a34a; }
      .match-status.tied { color: #d97706; }
      
      /* Hole-by-Hole Match List Styles */
      .matches-panel { background: #fff; border-radius: 12px; padding: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .match-item { padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s; }
      .match-item:hover { border-color: #3b82f6; background: #f0f9ff; }
      .match-item.selected { border-color: #3b82f6; background: #dbeafe; }
      .match-item.completed { background: #d1fae5; border-color: #86efac; }
      .match-item.completed:hover { background: #a7f3d0; }
      .match-item.completed.selected { background: #86efac; }
      .match-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
      .match-item-title { font-weight: 700; font-size: 15px; color: #1e293b; }
      .match-item-status { font-size: 12px; font-weight: 600; padding: 2px 8px; border-radius: 12px; }
      .match-item-status.pending { background: #f1f5f9; color: #64748b; }
      .match-item-status.in-progress { background: #fef3c7; color: #92400e; }
      .match-item-status.completed { background: #d1fae5; color: #065f46; }
      .match-item-teams { display: flex; align-items: center; gap: 12px; font-size: 13px; color: #475569; }
      .match-item-team { flex: 1; }
      .match-item-team.left { text-align: left; }
      .match-item-team.right { text-align: right; }
      .match-item-vs { font-weight: 700; color: #94a3b8; font-size: 12px; }
      .match-item-score { font-size: 14px; font-weight: 700; color: #1e293b; margin-top: 6px; text-align: center; }
      
      /* Match Scorecard Styles */
      .match-scorecard { width: 100%; border-collapse: collapse; font-size: 12px; }
      .match-scorecard th, .match-scorecard td { border: 1px solid #e2e8f0; padding: 6px 4px; text-align: center; min-width: 36px; }
      .match-scorecard th { background: #1e293b; color: white; font-weight: 600; font-size: 11px; }
      .match-scorecard .row-label { background: #f8fafc; font-weight: 600; text-align: left; padding-left: 8px; min-width: 80px; }
      .match-scorecard .par-row td { background: #f1f5f9; font-weight: 500; }
      .match-scorecard .si-row td { background: #f8fafc; color: #64748b; font-size: 10px; }
      .match-scorecard .team1-row td { background: #fef2f2; }
      .match-scorecard .team2-row td { background: #eff6ff; }
      .match-scorecard .match-score-row td { background: #f8fafc; font-weight: 700; font-size: 11px; }
      .match-scorecard .subtotal-col { background: #e2e8f0 !important; font-weight: 600; }
      .match-scorecard .total-col { background: #cbd5e1 !important; font-weight: 700; }
      .match-scorecard-input { width: 32px; height: 28px; border: 1px solid #d1d5db; border-radius: 4px; text-align: center; font-size: 12px; font-weight: 600; }
      .match-scorecard-input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
      .match-scorecard-input.team1 { background: #fef2f2; }
      .match-scorecard-input.team2 { background: #eff6ff; }
      /* Winning best ball styling - circle the score in team color */
      .match-scorecard-input.winner-team1 { background: #dc2626 !important; color: white !important; border-radius: 50%; font-weight: 700; border: 2px solid #b91c1c; }
      .match-scorecard-input.winner-team2 { background: #2563eb !important; color: white !important; border-radius: 50%; font-weight: 700; border: 2px solid #1d4ed8; }
      .match-score-team1 { color: #dc2626; font-weight: 700; }
      .match-score-team2 { color: #2563eb; font-weight: 700; }
      .match-score-even { color: #64748b; font-weight: 600; }
      .score-cell-wrapper { display: flex; align-items: flex-start; justify-content: center; gap: 0; }
      .stroke-dots { font-size: 10px; color: #3b82f6; font-weight: bold; line-height: 1; margin-left: -2px; }
    </style>
  </head>
  <body>
    <div class="top-nav">
      <h1>üèÜ Scores</h1>
      <a href="index.html" class="btn-back-top">‚Üê Back</a>
    </div>
    
    <!-- Action Buttons -->
    <div class="action-buttons-container">
      <div class="action-buttons">
        <button class="btn-action" onclick="saveScores()">üíæ Save Scores (F12)</button>
        <button class="btn-action" style="background: linear-gradient(180deg, #3b82f6, #2563eb);" onclick="forceSyncToCloud()">‚òÅÔ∏è Sync to Cloud</button>
        <button class="btn-action" style="background: linear-gradient(180deg, #8b5cf6, #7c3aed);" onclick="refreshDigitalScores()" title="Load scores from signed digital scorecards">üì± Digital Scorecards</button>
      </div>
    </div>
    
    <main class="scores-container">
      <header style="margin-bottom: 20px;">
        <p class="lead" id="tournament-name">Enter scores for the tournament round.</p>
      </header>

      <section class="round-selector">
        <label for="round-select">Select Round:</label>
        <select id="round-select">
          <!-- Populated dynamically -->
        </select>
        <span id="entry-method-badge" style="display: none; margin-left: 12px; padding: 4px 12px; background: #dbeafe; color: #1e40af; border-radius: 20px; font-size: 13px; font-weight: 600;"></span>
      </section>

      <!-- Match Score Entry Container (for Match Play) -->
      <section id="match-scores-container" class="match-scores-container">
        <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 8px 24px rgba(2,6,23,0.06);">
          <h2 style="margin: 0 0 16px 0; font-size: 18px; color: #1e293b;">Match Results</h2>
          <p style="color: #64748b; font-size: 14px; margin-bottom: 20px;">Enter the winning margin in the winner's box. Enter 0 in either box for a tied match.</p>
          <div class="search-box" style="margin-bottom: 16px;">
            <input id="match-search" type="text" placeholder="Search player to find their match..." style="width: 100%; padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;" />
          </div>
          <div id="match-list" class="match-list">
            <!-- Matches will be rendered here -->
          </div>
        </div>
      </section>

      <section class="scores-grid">
        <!-- Left Panel: Scorecard -->
        <div class="scorecard-panel">
          <div id="player-info" class="player-info" style="display: none;">
            <h3 id="player-name">-</h3>
            <div class="player-info-grid">
              <div class="info-item">
                <span class="info-label">Reg No</span>
                <span class="info-value" id="player-reg">-</span>
              </div>
              <div class="info-item">
                <span class="info-label">Handicap</span>
                <span class="info-value" id="player-hcp">-</span>
              </div>
              <div class="info-item">
                <span class="info-label">Playing HCP</span>
                <span class="info-value" id="player-phcp">-</span>
              </div>
              <div class="info-item">
                <span class="info-label">Status</span>
                <select id="player-status" class="status-select">
                  <option value="">Playing</option>
                  <option value="DQ">Disqualified (DQ)</option>
                  <option value="NS">No Show (NS)</option>
                  <option value="NR">No Return (NR)</option>
                </select>
              </div>
            </div>
          </div>

          <div id="scorecard-content">
            <div class="empty-state">
              <div class="empty-state-icon">üìã</div>
              <p>Select a player from the right panel to enter scores</p>
            </div>
          </div>
        </div>

        <!-- Right Panel: Player List -->
        <div class="players-panel" id="players-panel">
          <h2 style="margin-top: 0; font-size: 18px; color: #1e293b; margin-bottom: 12px;">Players</h2>
          <div class="search-box">
            <input id="player-search" type="text" placeholder="Search by name or reg... (Press Enter to select)" />
          </div>
          <div id="status-text" class="status-text"></div>
          <div class="table-wrapper">
            <table class="players-table">
              <thead>
                <tr>
                  <th data-sort="name" style="cursor: pointer;">Name <span id="sort-name">‚ñ≤</span></th>
                  <th data-sort="phcp" style="text-align: center; cursor: pointer;">PHCP <span id="sort-phcp"></span></th>
                </tr>
              </thead>
              <tbody id="players-tbody">
                <!-- Populated dynamically -->
              </tbody>
            </table>
          </div>
        </div>

        <!-- Right Panel: Matches List (for Match Play Hole-by-Hole) -->
        <div class="matches-panel" id="matches-panel" style="display: none;">
          <h2 style="margin-top: 0; font-size: 18px; color: #1e293b; margin-bottom: 12px;">Matches</h2>
          <div class="search-box">
            <input id="match-player-search" type="text" placeholder="Search by player name... (Press Enter to select)" />
          </div>
          <div id="matches-status-text" class="status-text"></div>
          <div class="table-wrapper" id="matches-list-container">
            <!-- Matches will be rendered here -->
          </div>
        </div>
      </section>
    </main>

    <!-- Modal for score input -->
    <div id="score-modal" class="modal-overlay">
      <div class="modal-box">
        <h3 id="modal-title">Score Entry</h3>
        <p id="modal-message">Is this a Hole-in-One?</p>
        <div id="modal-input-container" style="display: none;">
          <input type="number" id="modal-input" class="modal-input" placeholder="Enter score" min="1" step="1">
        </div>
        <div class="modal-buttons">
          <button class="modal-btn-secondary" id="modal-cancel">Cancel</button>
          <button class="modal-btn-primary" id="modal-confirm">Confirm</button>
        </div>
      </div>
    </div>

    <!-- Modal for Match Play Score Entry Method -->
    <div id="match-play-method-modal" class="modal-overlay">
      <div class="modal-box" style="min-width: 450px;">
        <h3 style="text-align: center; margin-bottom: 12px;">üèÜ Match Play Tournament</h3>
        <p style="text-align: center; color: #64748b; margin-bottom: 24px;">Select how you want to enter scores for this match play tournament:</p>
        <div class="modal-buttons" style="flex-direction: column; gap: 12px;">
          <button class="modal-btn-primary" id="method-match-score" style="padding: 16px 24px; font-size: 16px;">
            üéØ Match Score
            <span style="display: block; font-size: 12px; font-weight: normal; margin-top: 4px; opacity: 0.8;">Enter final match result (e.g., 3&2, 1UP)</span>
          </button>
          <button class="modal-btn-secondary" id="method-hole-by-hole" style="padding: 16px 24px; font-size: 16px;">
            üìã Hole by Hole
            <span style="display: block; font-size: 12px; font-weight: normal; margin-top: 4px; opacity: 0.8;">Enter individual hole scores</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>

    <script>
      // Get tournament from URL
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentIdParam = urlParams.get('tournamentId');
      
      let currentTournament = null;
      let currentRoundId = null;
      let currentRoundIndex = 0;
      let isMatchPlay = false;
      let scoreEntryMethod = null; // 'match-score' or 'hole-by-hole'

      // Format date as dd.mm.yyyy
      function formatDateDDMMYYYY(dateStr) {
        if (!dateStr) return '';
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        return `${day}.${month}.${year}`;
      }

      let admittedPlayers = [];
      let selectedPlayer = null;
      let courseData = null;
      let scores = {}; // { playerId: { holes: [hole1, hole2, ...], points: [p1, p2, ...] } }
      let filteredPlayers = [];
      let highlightedIndex = -1;
      let sortColumn = 'name';
      let sortDirection = 'asc';
      let digitalScorecardData = {}; // Stores available signed digital scorecards

      // Add keyboard shortcut for F12 to save scores
      document.addEventListener('keydown', (e) => {
        if (e.key === 'F12') {
          e.preventDefault();
          saveScores();
          // Focus search bar for next player
          const searchInput = document.getElementById('player-search');
          if (searchInput) {
            searchInput.focus();
            searchInput.select();
          }
        }
      });

      // LocalStorage helpers
      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function getTournament() {
        const tournaments = getTournaments();
        return tournaments.find(t => t.tournamentId === tournamentIdParam);
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse courses', err);
          return [];
        }
      }

      function getTeeData(player) {
        if (!currentTournament || currentRoundIndex === undefined || currentRoundIndex < 0) return null;
        const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
        if (!roundData) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeValue = '';
        
        // Check if player has an assigned tee (from categories)
        if (player.tee) {
          // Convert tee ID to courseId||teeIndex format
          const courses = getCourses();
          const courseId = roundData.course;
          const course = courses.find(c => c.courseId === courseId);
          
          if (course && course.teeIds) {
            const idx = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              teeValue = `${courseId}||${idx}`;
            }
          }
        }
        
        // If no assigned tee, use default from tournament settings
        if (!teeValue) {
          if (playerGender === 'male' || playerGender === 'm') {
            teeValue = roundData.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            teeValue = roundData.teeWomen || '';
          }
        }
        
        if (!teeValue || !teeValue.includes('||')) return null;
        
        const [courseId, teeIndexStr] = teeValue.split('||');
        const teeIndex = parseInt(teeIndexStr, 10);
        
        const courses = getCourses();
        const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
        
        if (!course) return null;
        
        // Calculate total par from pars array (sum of all 18 holes)
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        // Get tee-specific data from teeData array
        const teeData = course.teeData?.[teeIndex];
        if (!teeData) return null;
        
        let slope, rating;
        
        // Check if this tee is for both genders (has nested ratings structure)
        const teeGender = course.genders?.[teeIndex];
        if (teeGender === 'B' && teeData.ratings) {
          // Both genders - use appropriate gender's ratings
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else if (playerGender === 'female' || playerGender === 'f') {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          // Single gender tee
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        return { slope, rating, par, course };
      }

      function calculatePlayingHcp(player) {
        const playerHcp = parseFloat(player.hcp);
        if (isNaN(playerHcp)) {
          return '';
        }
        
        const teeData = getTeeData(player);
        if (!teeData || !teeData.slope || !teeData.rating || !teeData.par) {
          return playerHcp; // Fallback to WHS HCP if data missing
        }
        
        const slope = parseFloat(teeData.slope);
        const rating = parseFloat(teeData.rating);
        const par = parseFloat(teeData.par);
        const hcpAllowance = parseFloat(currentTournament.meta?.hcpAllow || 100) / 100;
        
        if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
          return playerHcp;
        }
        
        // Formula: (HCP √ó (Slope/113) + (Rating - Par)) √ó HCP_Allowance
        const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
        
        // Round to nearest whole number (.5 rounds up)
        const rounded = Math.round(playingHcp);
        
        return rounded;
      }

      // Calculate match handicap for singles - shows strokes given/received
      function calculateMatchHcpSingles(player1, player2) {
        const phcp1 = parseInt(calculatePlayingHcp(player1));
        const phcp2 = parseInt(calculatePlayingHcp(player2));
        
        if (isNaN(phcp1) || isNaN(phcp2)) {
          return { player1Strokes: 0, player2Strokes: 0 };
        }
        
        const diff = Math.abs(phcp1 - phcp2);
        
        if (phcp1 < phcp2) {
          // Player 1 has lower pHCP, gives strokes to Player 2
          return { player1Strokes: 0, player2Strokes: diff };
        } else if (phcp2 < phcp1) {
          // Player 2 has lower pHCP, gives strokes to Player 1
          return { player1Strokes: diff, player2Strokes: 0 };
        } else {
          return { player1Strokes: 0, player2Strokes: 0 };
        }
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          return data[currentRoundId] || [];
        } catch (err) {
          console.error('Failed to parse admitted players', err);
          return [];
        }
      }

      function getScoresData() {
        try {
          const raw = localStorage.getItem('scores');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse scores', err);
          return {};
        }
      }

      function saveScoresData(scoresData) {
        localStorage.setItem('scores', JSON.stringify(scoresData));
        // Sync to Firebase if available
        if (typeof syncToFirebase !== 'undefined') {
          syncToFirebase('scores', scoresData)
            .then(() => console.log('‚úì Scores synced to Firebase'))
            .catch(e => {
              console.error('Firebase sync failed:', e);
              alert('Warning: Failed to sync scores to cloud. Saved locally only.');
            });
        } else {
          console.warn('syncToFirebase not available');
        }
      }

      // Show Match Play score entry method selection modal
      function showMatchPlayMethodModal() {
        const modal = document.getElementById('match-play-method-modal');
        modal.classList.add('active');
        
        const matchScoreBtn = document.getElementById('method-match-score');
        const holeByHoleBtn = document.getElementById('method-hole-by-hole');
        
        // Remove any existing listeners
        matchScoreBtn.replaceWith(matchScoreBtn.cloneNode(true));
        holeByHoleBtn.replaceWith(holeByHoleBtn.cloneNode(true));
        
        // Re-get the buttons after cloning
        const newMatchScoreBtn = document.getElementById('method-match-score');
        const newHoleByHoleBtn = document.getElementById('method-hole-by-hole');
        
        newMatchScoreBtn.addEventListener('click', () => {
          scoreEntryMethod = 'match-score';
          modal.classList.remove('active');
          console.log('Score entry method: Match Score');
          initMatchScoreUI();
        });
        
        newHoleByHoleBtn.addEventListener('click', () => {
          scoreEntryMethod = 'hole-by-hole';
          modal.classList.remove('active');
          console.log('Score entry method: Hole by Hole');
          // Hide match scores container, show normal scores grid
          document.getElementById('match-scores-container').classList.remove('active');
          document.querySelector('.scores-grid').style.display = 'grid';
          updateEntryMethodBadge();
          
          // For Match Play, always show matches panel instead of players panel
          if (isMatchPlay) {
            document.getElementById('players-panel').style.display = 'none';
            document.getElementById('matches-panel').style.display = 'block';
            initHoleByHoleMatchUI();
          } else {
            document.getElementById('players-panel').style.display = 'block';
            document.getElementById('matches-panel').style.display = 'none';
          }
        });
      }

      // Update entry method badge
      function updateEntryMethodBadge() {
        const badge = document.getElementById('entry-method-badge');
        if (isMatchPlay && scoreEntryMethod) {
          badge.style.display = 'inline';
          badge.textContent = scoreEntryMethod === 'match-score' ? 'üéØ Match Score' : 'üìã Hole by Hole';
        } else {
          badge.style.display = 'none';
        }
      }

      // Load draws from Firebase
      async function loadDrawsFromFirebase() {
        if (typeof syncFromFirebase === 'undefined' || !syncEnabled) {
          console.log('Firebase sync not available for draws');
          return;
        }
        
        try {
          const drawsData = await syncFromFirebase('draws');
          if (drawsData) {
            localStorage.setItem('draws', JSON.stringify(drawsData));
            console.log('‚úì Draws loaded from Firebase');
          }
        } catch (err) {
          console.error('Failed to load draws from Firebase:', err);
        }
      }

      // Initialize Match Score UI
      async function initMatchScoreUI() {
        // Hide normal scores grid, show match scores container
        document.querySelector('.scores-grid').style.display = 'none';
        document.getElementById('match-scores-container').classList.add('active');
        updateEntryMethodBadge();
        
        // Load draws from Firebase first
        await loadDrawsFromFirebase();
        
        // Load match scores from Firebase, then render
        await loadMatchScoresFromFirebase();
        loadMatchScores();
      }

      // ============================================
      // HOLE-BY-HOLE MATCH PLAY UI (Fourball)
      // ============================================
      
      let holeByHoleMatches = []; // Store matches for hole-by-hole mode
      let selectedMatch = null; // Currently selected match
      let holeByHoleScores = {}; // { matchKey: { holes: [{team1Score, team2Score, winner}, ...], status: 'pending'|'in-progress'|'completed' } }
      let filteredMatches = [];
      let highlightedMatchIndex = -1;

      // Initialize Hole-by-Hole Match UI for Fourball
      async function initHoleByHoleMatchUI() {
        console.log('Initializing Hole-by-Hole Match UI for Fourball');
        
        // Hide players panel, show matches panel
        document.getElementById('players-panel').style.display = 'none';
        document.getElementById('matches-panel').style.display = 'block';
        
        // Load course data for scorecard
        const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
        if (roundData && roundData.course) {
          const courses = getCourses();
          courseData = courses.find(c => c.courseId === roundData.course);
          console.log('Course data loaded:', courseData?.name || 'Not found');
        }
        
        // Load draws from Firebase first
        await loadDrawsFromFirebase();
        
        // Load hole-by-hole scores from Firebase
        await loadHoleByHoleScoresFromFirebase();
        
        // Load and render matches
        loadHoleByHoleMatches();
        
        // Setup search functionality
        setupMatchPlayerSearch();
      }

      // Load hole-by-hole scores from Firebase
      async function loadHoleByHoleScoresFromFirebase() {
        if (typeof syncFromFirebase === 'undefined' || !syncEnabled) {
          console.log('Firebase sync not available for hole-by-hole scores');
          // Load from localStorage
          const localData = localStorage.getItem('holeByHoleScores');
          holeByHoleScores = localData ? JSON.parse(localData) : {};
          return;
        }
        
        try {
          const firebaseData = await syncFromFirebase('holeByHoleScores');
          if (firebaseData) {
            localStorage.setItem('holeByHoleScores', JSON.stringify(firebaseData));
            holeByHoleScores = firebaseData;
            console.log('‚úì Hole-by-hole scores loaded from Firebase');
          } else {
            const localData = localStorage.getItem('holeByHoleScores');
            holeByHoleScores = localData ? JSON.parse(localData) : {};
          }
        } catch (err) {
          console.error('Failed to load hole-by-hole scores from Firebase:', err);
          const localData = localStorage.getItem('holeByHoleScores');
          holeByHoleScores = localData ? JSON.parse(localData) : {};
        }
      }

      // Save hole-by-hole scores
      function saveHoleByHoleScores() {
        localStorage.setItem('holeByHoleScores', JSON.stringify(holeByHoleScores));
        // Sync to Firebase if available
        if (typeof syncToFirebase !== 'undefined') {
          syncToFirebase('holeByHoleScores', holeByHoleScores)
            .then(() => console.log('‚úì Hole-by-hole scores synced to Firebase'))
            .catch(e => console.error('Firebase sync failed:', e));
        }
      }

      // Load matches for hole-by-hole mode
      function loadHoleByHoleMatches() {
        const drawData = getDrawData(currentRoundId);
        console.log('Loading hole-by-hole matches, draw data:', drawData);
        
        if (!drawData || !drawData.groups || drawData.groups.length === 0) {
          document.getElementById('matches-list-container').innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">üìã</div>
              <p>No draw data found for this round. Please create groups in the Draw page first.</p>
            </div>
          `;
          return;
        }

        // Build matches array from groups (for Fourball: each group is one match)
        holeByHoleMatches = [];
        
        drawData.groups.forEach((group, groupIndex) => {
          const players = group.players || [];
          
          if (players.length < 2) return;
          
          // For Fourball: Players 1&2 vs Players 3&4
          const team1 = players.slice(0, 2);
          const team2 = players.slice(2, 4);
          
          const matchKey = `${currentRoundId}_match_${groupIndex}`;
          
          // Get existing scores for this match
          const matchScoreData = holeByHoleScores[matchKey] || { holes: [], status: 'pending' };
          
          holeByHoleMatches.push({
            matchIndex: groupIndex,
            matchKey: matchKey,
            team1: team1,
            team2: team2,
            teamNames: {
              team1: team1[0]?.teamName || team1[0]?.team || '',
              team2: team2[0]?.teamName || team2[0]?.team || ''
            },
            scores: matchScoreData,
            groupData: group
          });
        });

        renderHoleByHoleMatchesList();
        updateMatchesStatus();
      }

      // Render the matches list for hole-by-hole mode
      function renderHoleByHoleMatchesList() {
        const container = document.getElementById('matches-list-container');
        const searchTerm = document.getElementById('match-player-search')?.value?.toLowerCase() || '';
        
        // Filter matches by search term
        let matchesToShow = holeByHoleMatches;
        if (searchTerm) {
          matchesToShow = holeByHoleMatches.filter(match => {
            const allPlayers = [...match.team1, ...match.team2];
            return allPlayers.some(p => {
              const fullName = `${p.firstName} ${p.lastName}`.toLowerCase();
              return fullName.includes(searchTerm);
            });
          });
        }
        
        // Sort: incomplete matches first, completed matches at bottom
        matchesToShow.sort((a, b) => {
          const aCompleted = a.scores.status === 'completed';
          const bCompleted = b.scores.status === 'completed';
          
          if (aCompleted && !bCompleted) return 1;
          if (!aCompleted && bCompleted) return -1;
          return a.matchIndex - b.matchIndex;
        });
        
        filteredMatches = matchesToShow;
        
        if (matchesToShow.length === 0) {
          container.innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">üîç</div>
              <p>No matches found</p>
            </div>
          `;
          return;
        }

        let html = '';
        matchesToShow.forEach((match, idx) => {
          const isSelected = selectedMatch && selectedMatch.matchKey === match.matchKey;
          const isHighlighted = idx === highlightedMatchIndex;
          const status = match.scores.status || 'pending';
          
          // Build team names display
          const team1Names = match.team1.map(p => `${p.firstName} ${p.lastName}`).join(' & ');
          const team2Names = match.team2.length > 0 
            ? match.team2.map(p => `${p.firstName} ${p.lastName}`).join(' & ')
            : 'No opponent';
          
          // Calculate current match score
          const matchScore = calculateMatchScore(match.scores.holes || []);
          
          html += `
            <div class="match-item ${status === 'completed' ? 'completed' : ''} ${isSelected ? 'selected' : ''}" 
                 data-match-key="${match.matchKey}"
                 style="${isHighlighted ? 'border-color: #f59e0b; background: #fef3c7;' : ''}">
              <div class="match-item-header">
                <span class="match-item-title">Match ${match.matchIndex + 1}</span>
                <span class="match-item-status ${status}">${getStatusLabel(status)}</span>
              </div>
              <div class="match-item-teams">
                <div class="match-item-team left">${team1Names}</div>
                <div class="match-item-vs">VS</div>
                <div class="match-item-team right">${team2Names}</div>
              </div>
              ${matchScore ? `<div class="match-item-score">${matchScore}</div>` : ''}
            </div>
          `;
        });

        container.innerHTML = html;

        // Add click handlers
        container.querySelectorAll('.match-item').forEach(item => {
          item.addEventListener('click', () => {
            const matchKey = item.dataset.matchKey;
            const match = holeByHoleMatches.find(m => m.matchKey === matchKey);
            if (match) {
              selectMatch(match);
              highlightedMatchIndex = -1;
              renderHoleByHoleMatchesList();
            }
          });
        });
      }

      // Get status label text
      function getStatusLabel(status) {
        switch(status) {
          case 'completed': return '‚úì Complete';
          case 'in-progress': return 'In Progress';
          default: return 'Pending';
        }
      }

      // Calculate match score from holes data
      function calculateMatchScore(holes) {
        if (!holes || holes.length === 0) return '';
        
        let team1Up = 0;
        let holesPlayed = 0;
        
        holes.forEach(hole => {
          if (hole && hole.winner) {
            holesPlayed++;
            if (hole.winner === 'team1') team1Up++;
            else if (hole.winner === 'team2') team1Up--;
          }
        });
        
        if (holesPlayed === 0) return '';
        
        const holesRemaining = 18 - holesPlayed;
        
        if (team1Up === 0) {
          return 'All Square';
        } else if (team1Up > 0) {
          if (holesRemaining === 0) {
            return `Team 1 wins ${team1Up}UP`;
          }
          return `Team 1 ${team1Up}UP`;
        } else {
          if (holesRemaining === 0) {
            return `Team 2 wins ${Math.abs(team1Up)}UP`;
          }
          return `Team 2 ${Math.abs(team1Up)}UP`;
        }
      }

      // Update matches status text
      function updateMatchesStatus() {
        const total = holeByHoleMatches.length;
        const completed = holeByHoleMatches.filter(m => m.scores.status === 'completed').length;
        const inProgress = holeByHoleMatches.filter(m => m.scores.status === 'in-progress').length;
        
        const statusText = document.getElementById('matches-status-text');
        if (statusText) {
          statusText.textContent = `${total} matches | ${completed} completed | ${inProgress} in progress`;
        }
      }

      // Select a match for scoring
      function selectMatch(match) {
        selectedMatch = match;
        console.log('Selected match:', match);
        
        // Update player info panel for match
        const playerInfo = document.getElementById('player-info');
        playerInfo.style.display = 'block';
        
        // Show team names in header
        const team1Names = match.team1.map(p => `${p.firstName} ${p.lastName}`).join(' & ');
        const team2Names = match.team2.map(p => `${p.firstName} ${p.lastName}`).join(' & ');
        
        document.getElementById('player-name').textContent = `Match ${match.matchIndex + 1}`;
        document.getElementById('player-reg').textContent = `${team1Names} vs ${team2Names}`;
        document.getElementById('player-hcp').textContent = '-';
        document.getElementById('player-phcp').textContent = '-';
        
        // Hide status dropdown for matches
        document.getElementById('player-status').parentElement.style.display = 'none';
        
        // Render match scorecard
        renderMatchScorecard(match);
      }

      // Get player's playing handicap for match play
      function getMatchPlayingHcp(player) {
        // Use stored PHCP or calculate
        let phcp = player.phcp;
        if (phcp === undefined || phcp === null || phcp === '') {
          phcp = calculatePlayingHcp(player);
        }
        return parseInt(phcp) || 0;
      }

      // Calculate strokes received on a hole based on handicap and stroke index
      function getMatchStrokesForHole(phcp, strokeIndex) {
        const si = parseInt(strokeIndex);
        if (isNaN(si) || si > 18 || si < 1) return 0;
        
        const absPhcp = Math.abs(phcp);
        const fullStrokes = Math.floor(absPhcp / 18);
        const remainingStrokes = absPhcp % 18;
        
        if (phcp >= 0) {
          return fullStrokes + (si <= remainingStrokes ? 1 : 0);
        } else {
          const givesStroke = si >= (19 - remainingStrokes) ? 1 : 0;
          return -(fullStrokes + givesStroke);
        }
      }

      // Calculate stroke allocation for a match handicap (array of strokes per hole)
      function calculateStrokeAllocation(matchHCP, strokeIndexes) {
        const allocation = Array(18).fill(0);
        if (matchHCP <= 0) return allocation;
        
        for (let stroke = 1; stroke <= matchHCP; stroke++) {
          for (let hole = 0; hole < 18; hole++) {
            const si = parseInt(strokeIndexes[hole]) || 99;
            const targetSI = stroke <= 18 ? stroke : stroke - 18;
            if (si === targetSI) {
              allocation[hole]++;
              break;
            }
          }
        }
        return allocation;
      }

      // Render match scorecard for Fourball
      function renderMatchScorecard(match) {
        const content = document.getElementById('scorecard-content');
        
        if (!courseData || !courseData.pars) {
          content.innerHTML = '<div class="empty-state"><p>Course data not available</p></div>';
          return;
        }
        
        const pars = courseData.pars;
        const strokeIndexes = courseData.strokeIndexes || Array(18).fill('-');
        
        // Get players from teams
        const team1Player1 = match.team1[0];
        const team1Player2 = match.team1[1];
        const team2Player1 = match.team2[0];
        const team2Player2 = match.team2[1];
        
        // Get playing handicaps (PHCP)
        const t1p1Phcp = getMatchPlayingHcp(team1Player1);
        const t1p2Phcp = team1Player2 ? getMatchPlayingHcp(team1Player2) : null;
        const t2p1Phcp = team2Player1 ? getMatchPlayingHcp(team2Player1) : null;
        const t2p2Phcp = team2Player2 ? getMatchPlayingHcp(team2Player2) : null;
        
        // Calculate Match HCPs: Lowest PHCP gets 0, others get the difference
        const allPhcps = [t1p1Phcp, t1p2Phcp, t2p1Phcp, t2p2Phcp].filter(p => p !== null);
        const lowestPhcp = Math.min(...allPhcps);
        
        const t1p1MatchHcp = t1p1Phcp - lowestPhcp;
        const t1p2MatchHcp = t1p2Phcp !== null ? t1p2Phcp - lowestPhcp : 0;
        const t2p1MatchHcp = t2p1Phcp !== null ? t2p1Phcp - lowestPhcp : 0;
        const t2p2MatchHcp = t2p2Phcp !== null ? t2p2Phcp - lowestPhcp : 0;
        
        // Calculate stroke allocation for each player
        const t1p1Strokes = calculateStrokeAllocation(t1p1MatchHcp, strokeIndexes);
        const t1p2Strokes = calculateStrokeAllocation(t1p2MatchHcp, strokeIndexes);
        const t2p1Strokes = calculateStrokeAllocation(t2p1MatchHcp, strokeIndexes);
        const t2p2Strokes = calculateStrokeAllocation(t2p2MatchHcp, strokeIndexes);
        
        // Get existing scores for this match
        let matchScoreData = holeByHoleScores[match.matchKey] || {};
        
        // Ensure all score arrays exist
        matchScoreData.team1Player1Scores = matchScoreData.team1Player1Scores || Array(18).fill('');
        matchScoreData.team1Player2Scores = matchScoreData.team1Player2Scores || Array(18).fill('');
        matchScoreData.team2Player1Scores = matchScoreData.team2Player1Scores || Array(18).fill('');
        matchScoreData.team2Player2Scores = matchScoreData.team2Player2Scores || Array(18).fill('');
        matchScoreData.status = matchScoreData.status || 'pending';
        
        // Initialize if not exists
        if (!holeByHoleScores[match.matchKey]) {
          holeByHoleScores[match.matchKey] = matchScoreData;
        }
        
        let html = '<div style="overflow-x: auto;"><table class="match-scorecard">';
        
        // Header row - Hole numbers
        html += '<thead><tr><th class="row-label">Hole:</th>';
        for (let i = 1; i <= 9; i++) html += `<th>${i}</th>`;
        html += '<th class="subtotal-col">Front</th>';
        for (let i = 10; i <= 18; i++) html += `<th>${i}</th>`;
        html += '<th class="subtotal-col">Back</th><th class="total-col">Total</th></tr></thead>';
        
        html += '<tbody>';
        
        // PAR row
        let frontPar = 0, backPar = 0;
        html += '<tr class="par-row"><td class="row-label">PAR</td>';
        for (let i = 0; i < 9; i++) { html += `<td>${pars[i]}</td>`; frontPar += pars[i]; }
        html += `<td class="subtotal-col">${frontPar}</td>`;
        for (let i = 9; i < 18; i++) { html += `<td>${pars[i]}</td>`; backPar += pars[i]; }
        html += `<td class="subtotal-col">${backPar}</td><td class="total-col">${frontPar + backPar}</td></tr>`;
        
        // Stroke Index row
        html += '<tr class="si-row"><td class="row-label">Str. Indx</td>';
        for (let i = 0; i < 9; i++) html += `<td>${strokeIndexes[i]}</td>`;
        html += '<td class="subtotal-col"></td>';
        for (let i = 9; i < 18; i++) html += `<td>${strokeIndexes[i]}</td>`;
        html += '<td class="subtotal-col"></td><td class="total-col"></td></tr>';
        
        // Calculate winning scores for each hole (to highlight the best ball that won)
        const winningScores = calculateWinningScoresPerHole(
          matchScoreData, 
          t1p1Strokes, t1p2Strokes, t2p1Strokes, t2p2Strokes
        );
        
        // Team 1 Player 1 row
        html += renderPlayerScoreRow(team1Player1, t1p1MatchHcp, t1p1Strokes, 'team1', 'p1', matchScoreData.team1Player1Scores, pars, match.matchKey, winningScores);
        
        // Team 1 Player 2 row (if exists)
        if (team1Player2) {
          html += renderPlayerScoreRow(team1Player2, t1p2MatchHcp, t1p2Strokes, 'team1', 'p2', matchScoreData.team1Player2Scores, pars, match.matchKey, winningScores);
        }
        
        // Match Score row
        html += renderMatchScoreRow(matchScoreData, pars, t1p1Strokes, t1p2Strokes, t2p1Strokes, t2p2Strokes);
        
        // Team 2 Player 1 row
        if (team2Player1) {
          html += renderPlayerScoreRow(team2Player1, t2p1MatchHcp, t2p1Strokes, 'team2', 'p1', matchScoreData.team2Player1Scores, pars, match.matchKey, winningScores);
        }
        
        // Team 2 Player 2 row (if exists)
        if (team2Player2) {
          html += renderPlayerScoreRow(team2Player2, t2p2MatchHcp, t2p2Strokes, 'team2', 'p2', matchScoreData.team2Player2Scores, pars, match.matchKey, winningScores);
        }
        
        html += '</tbody></table></div>';
        
        content.innerHTML = html;
        
        // Add event listeners to all score inputs
        content.querySelectorAll('.match-scorecard-input').forEach(input => {
          input.addEventListener('input', handleMatchHoleScoreInput);
          input.addEventListener('keydown', handleMatchScoreKeydown);
        });
      }

      // Calculate which player's score is the winning best ball for each hole
      function calculateWinningScoresPerHole(matchScoreData, t1p1Strokes, t1p2Strokes, t2p1Strokes, t2p2Strokes) {
        const results = [];
        
        for (let i = 0; i < 18; i++) {
          const t1p1Score = matchScoreData.team1Player1Scores[i];
          const t1p2Score = matchScoreData.team1Player2Scores ? matchScoreData.team1Player2Scores[i] : '';
          const t2p1Score = matchScoreData.team2Player1Scores ? matchScoreData.team2Player1Scores[i] : '';
          const t2p2Score = matchScoreData.team2Player2Scores ? matchScoreData.team2Player2Scores[i] : '';
          
          // Calculate net scores
          const t1p1Net = t1p1Score ? parseInt(t1p1Score) - (t1p1Strokes[i] || 0) : 999;
          const t1p2Net = t1p2Score ? parseInt(t1p2Score) - (t1p2Strokes[i] || 0) : 999;
          const t2p1Net = t2p1Score ? parseInt(t2p1Score) - (t2p1Strokes[i] || 0) : 999;
          const t2p2Net = t2p2Score ? parseInt(t2p2Score) - (t2p2Strokes[i] || 0) : 999;
          
          // Find best ball for each team
          const team1Best = Math.min(t1p1Net, t1p2Net);
          const team2Best = Math.min(t2p1Net, t2p2Net);
          
          let winner = null;
          let winningTeam = null;
          let winningPlayer = null;
          
          if (team1Best < 999 && team2Best < 999) {
            if (team1Best < team2Best) {
              winningTeam = 'team1';
              // Find which player had the best ball
              if (t1p1Net <= t1p2Net && t1p1Score) {
                winningPlayer = 'p1';
              } else if (t1p2Score) {
                winningPlayer = 'p2';
              }
            } else if (team2Best < team1Best) {
              winningTeam = 'team2';
              // Find which player had the best ball
              if (t2p1Net <= t2p2Net && t2p1Score) {
                winningPlayer = 'p1';
              } else if (t2p2Score) {
                winningPlayer = 'p2';
              }
            }
            // If tied (halved), no winner highlighted
          }
          
          results.push({ winningTeam, winningPlayer });
        }
        
        return results;
      }

      // Render a player's score row
      function renderPlayerScoreRow(player, matchHcp, strokeAllocation, team, playerNum, scores, pars, matchKey, winningScores) {
        if (!player) return '';
        
        const teamClass = team === 'team1' ? 'team1-row' : 'team2-row';
        const inputClass = team === 'team1' ? 'team1' : 'team2';
        const name = `${player.firstName || ''} ${(player.lastName || '').charAt(0)}.`;
        
        // Ensure scores is an array
        scores = scores || Array(18).fill('');
        winningScores = winningScores || [];
        
        let html = `<tr class="${teamClass}"><td class="row-label">${name}<br><small>HCP:${matchHcp}</small></td>`;
        
        let frontTotal = 0, backTotal = 0;
        
        for (let i = 0; i < 9; i++) {
          const score = scores[i] || '';
          const strokes = strokeAllocation[i] || 0;
          const strokeDots = strokes > 0 ? '<sup class="stroke-dots">' + '‚Ä¢'.repeat(strokes) + '</sup>' : '';
          
          // Check if this player's score is the winning best ball for this hole
          const holeWinner = winningScores[i];
          const isWinningScore = holeWinner && holeWinner.winningTeam === team && holeWinner.winningPlayer === playerNum;
          const winnerClass = isWinningScore ? (team === 'team1' ? 'winner-team1' : 'winner-team2') : '';
          
          if (score) frontTotal += parseInt(score) || 0;
          
          html += `<td>
            <div class="score-cell-wrapper">
              <input type="text" class="match-scorecard-input ${inputClass} ${winnerClass}" 
                     value="${score}" 
                     data-match-key="${matchKey}"
                     data-team="${team}"
                     data-player="${playerNum}"
                     data-hole="${i}"
                     maxlength="2">${strokeDots}
            </div>
          </td>`;
        }
        
        html += `<td class="subtotal-col">${frontTotal || ''}</td>`;
        
        for (let i = 9; i < 18; i++) {
          const score = scores[i] || '';
          const strokes = strokeAllocation[i] || 0;
          const strokeDots = strokes > 0 ? '<sup class="stroke-dots">' + '‚Ä¢'.repeat(strokes) + '</sup>' : '';
          
          // Check if this player's score is the winning best ball for this hole
          const holeWinner = winningScores[i];
          const isWinningScore = holeWinner && holeWinner.winningTeam === team && holeWinner.winningPlayer === playerNum;
          const winnerClass = isWinningScore ? (team === 'team1' ? 'winner-team1' : 'winner-team2') : '';
          
          if (score) backTotal += parseInt(score) || 0;
          
          html += `<td>
            <div class="score-cell-wrapper">
              <input type="text" class="match-scorecard-input ${inputClass} ${winnerClass}" 
                     value="${score}" 
                     data-match-key="${matchKey}"
                     data-team="${team}"
                     data-player="${playerNum}"
                     data-hole="${i}"
                     maxlength="2">${strokeDots}
            </div>
          </td>`;
        }
        
        html += `<td class="subtotal-col">${backTotal || ''}</td>`;
        html += `<td class="total-col">${(frontTotal + backTotal) || ''}</td>`;
        html += '</tr>';
        
        return html;
      }

      // Get score class for styling - NOT USED anymore, keeping for reference
      function getScoreClass(score, par, team) {
        return ''; // No birdie/eagle styling in match play hole-by-hole
      }

      // Render the match score row
      function renderMatchScoreRow(matchScoreData, pars, t1p1Strokes, t1p2Strokes, t2p1Strokes, t2p2Strokes) {
        let html = '<tr class="match-score-row"><td class="row-label"><strong>MATCH SCORE</strong></td>';
        
        let runningScore = 0; // Positive = Team 1 up, Negative = Team 2 up
        
        for (let i = 0; i < 18; i++) {
          const holeResult = calculateHoleWinner(
            matchScoreData.team1Player1Scores[i],
            matchScoreData.team1Player2Scores ? matchScoreData.team1Player2Scores[i] : '',
            matchScoreData.team2Player1Scores ? matchScoreData.team2Player1Scores[i] : '',
            matchScoreData.team2Player2Scores ? matchScoreData.team2Player2Scores[i] : '',
            pars[i],
            t1p1Strokes[i], t1p2Strokes[i], t2p1Strokes[i], t2p2Strokes[i]
          );
          
          if (holeResult !== null) {
            runningScore += holeResult;
          }
          
          let displayText = '';
          let displayClass = 'match-score-even';
          
          if (holeResult !== null) {
            if (runningScore > 0) {
              displayText = `${runningScore}up`;
              displayClass = 'match-score-team1';
            } else if (runningScore < 0) {
              displayText = `${Math.abs(runningScore)}up`;
              displayClass = 'match-score-team2';
            } else {
              displayText = 'E';
              displayClass = 'match-score-even';
            }
          }
          
          if (i === 8) {
            html += `<td class="${displayClass}">${displayText}</td><td class="subtotal-col"></td>`;
          } else if (i === 17) {
            html += `<td class="${displayClass}">${displayText}</td><td class="subtotal-col"></td><td class="total-col"></td>`;
          } else {
            html += `<td class="${displayClass}">${displayText}</td>`;
          }
        }
        
        html += '</tr>';
        return html;
      }

      // Calculate who won a hole in Fourball (best ball comparison using stroke allocation)
      function calculateHoleWinner(t1p1Score, t1p2Score, t2p1Score, t2p2Score, par, t1p1Strokes, t1p2Strokes, t2p1Strokes, t2p2Strokes) {
        // Need at least one score from each team
        const t1Scores = [t1p1Score, t1p2Score].filter(s => s !== '' && s !== null && s !== undefined);
        const t2Scores = [t2p1Score, t2p2Score].filter(s => s !== '' && s !== null && s !== undefined);
        
        if (t1Scores.length === 0 || t2Scores.length === 0) return null;
        
        // Calculate net scores for each player (gross - strokes received on this hole)
        const t1p1Net = t1p1Score ? parseInt(t1p1Score) - (t1p1Strokes || 0) : 999;
        const t1p2Net = t1p2Score ? parseInt(t1p2Score) - (t1p2Strokes || 0) : 999;
        const t2p1Net = t2p1Score ? parseInt(t2p1Score) - (t2p1Strokes || 0) : 999;
        const t2p2Net = t2p2Score ? parseInt(t2p2Score) - (t2p2Strokes || 0) : 999;
        
        // Best ball for each team (lowest net score)
        const team1Best = Math.min(t1p1Net, t1p2Net);
        const team2Best = Math.min(t2p1Net, t2p2Net);
        
        if (team1Best < team2Best) return 1;  // Team 1 wins hole
        if (team2Best < team1Best) return -1; // Team 2 wins hole
        return 0; // Halved
      }

      // Handle score input for match hole
      function handleMatchHoleScoreInput(e) {
        const input = e.target;
        const matchKey = input.dataset.matchKey;
        const team = input.dataset.team;
        const playerNum = input.dataset.player;
        const holeIndex = parseInt(input.dataset.hole);
        let value = input.value.trim();
        
        // Only allow numbers
        if (value !== '' && !/^\d+$/.test(value)) {
          input.value = '';
          return;
        }
        
        // Update scores data
        const scoreKey = `${team}Player${playerNum === 'p1' ? '1' : '2'}Scores`;
        if (!holeByHoleScores[matchKey]) {
          holeByHoleScores[matchKey] = {
            team1Player1Scores: Array(18).fill(''),
            team1Player2Scores: Array(18).fill(''),
            team2Player1Scores: Array(18).fill(''),
            team2Player2Scores: Array(18).fill(''),
            status: 'pending'
          };
        }
        
        holeByHoleScores[matchKey][scoreKey][holeIndex] = value;
        
        // Update status
        updateMatchStatus(matchKey);
        
        // Save scores
        saveHoleByHoleScores();
        
        // Re-render to update match score row and styling
        if (selectedMatch && selectedMatch.matchKey === matchKey) {
          renderMatchScorecard(selectedMatch);
          // Re-focus on next input
          const allInputs = document.querySelectorAll('.match-scorecard-input');
          const currentIdx = Array.from(allInputs).findIndex(inp => 
            inp.dataset.matchKey === matchKey && 
            inp.dataset.team === team && 
            inp.dataset.player === playerNum && 
            parseInt(inp.dataset.hole) === holeIndex
          );
          if (currentIdx < allInputs.length - 1 && value !== '') {
            allInputs[currentIdx + 1].focus();
          }
        }
        
        // Update match list
        renderHoleByHoleMatchesList();
      }

      // Handle keydown for navigation
      function handleMatchScoreKeydown(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          const allInputs = Array.from(document.querySelectorAll('.match-scorecard-input'));
          const currentIdx = allInputs.indexOf(e.target);
          if (currentIdx < allInputs.length - 1) {
            allInputs[currentIdx + 1].focus();
            allInputs[currentIdx + 1].select();
          }
        }
      }

      // Update match status based on scores
      function updateMatchStatus(matchKey) {
        const data = holeByHoleScores[matchKey];
        if (!data) return;
        
        // Count holes with scores from both teams
        let holesPlayed = 0;
        for (let i = 0; i < 18; i++) {
          const t1HasScore = data.team1Player1Scores[i] || data.team1Player2Scores[i];
          const t2HasScore = data.team2Player1Scores[i] || data.team2Player2Scores[i];
          if (t1HasScore && t2HasScore) holesPlayed++;
        }
        
        if (holesPlayed === 0) {
          data.status = 'pending';
        } else if (holesPlayed === 18) {
          data.status = 'completed';
        } else {
          data.status = 'in-progress';
        }
        
        // Update the match in holeByHoleMatches array
        const matchIdx = holeByHoleMatches.findIndex(m => m.matchKey === matchKey);
        if (matchIdx !== -1) {
          holeByHoleMatches[matchIdx].scores = data;
        }
        
        updateMatchesStatus();
      }

      // Setup search functionality for match player search
      function setupMatchPlayerSearch() {
        const searchInput = document.getElementById('match-player-search');
        if (!searchInput) return;

        searchInput.addEventListener('input', (e) => {
          highlightedMatchIndex = e.target.value.trim() ? 0 : -1;
          renderHoleByHoleMatchesList();
        });

        searchInput.addEventListener('keydown', (e) => {
          if (filteredMatches.length === 0) return;

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            highlightedMatchIndex = Math.min(highlightedMatchIndex + 1, filteredMatches.length - 1);
            renderHoleByHoleMatchesList();
            scrollToHighlightedMatch();
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            highlightedMatchIndex = Math.max(highlightedMatchIndex - 1, 0);
            renderHoleByHoleMatchesList();
            scrollToHighlightedMatch();
          } else if (e.key === 'Enter') {
            e.preventDefault();
            if (highlightedMatchIndex >= 0 && filteredMatches[highlightedMatchIndex]) {
              selectMatch(filteredMatches[highlightedMatchIndex]);
              searchInput.value = '';
              highlightedMatchIndex = -1;
              renderHoleByHoleMatchesList();
            }
          } else if (e.key === 'Escape') {
            searchInput.value = '';
            highlightedMatchIndex = -1;
            renderHoleByHoleMatchesList();
          }
        });
      }

      // Scroll to highlighted match
      function scrollToHighlightedMatch() {
        const items = document.querySelectorAll('.match-item');
        if (items[highlightedMatchIndex]) {
          items[highlightedMatchIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      }

      // ============================================
      // END HOLE-BY-HOLE MATCH PLAY UI
      // ============================================

      // Get draw data for current round
      function getDrawData(roundId) {
        try {
          const draws = JSON.parse(localStorage.getItem('draws') || '{}');
          return draws[roundId] || null;
        } catch (err) {
          console.error('Failed to parse draw data', err);
          return null;
        }
      }

      // Load match scores from Firebase
      async function loadMatchScoresFromFirebase() {
        if (typeof syncFromFirebase === 'undefined' || !syncEnabled) {
          console.log('Firebase sync not available for match scores');
          return;
        }
        
        try {
          const firebaseData = await syncFromFirebase('matchScores');
          if (firebaseData) {
            localStorage.setItem('matchScores', JSON.stringify(firebaseData));
            console.log('‚úì Match scores loaded from Firebase');
          }
        } catch (err) {
          console.error('Failed to load match scores from Firebase:', err);
        }
      }

      // Load digital scorecard availability (which players have signed scorecards)
      async function loadDigitalScorecardAvailability(roundId) {
        if (!window.db) return;
        
        try {
          const digitalScoresRef = window.db.ref(`digitalScores/${roundId}`);
          const snapshot = await digitalScoresRef.once('value');
          const data = snapshot.val() || {};
          
          // Store availability data globally
          digitalScorecardData = {};
          for (const [playerId, playerData] of Object.entries(data)) {
            if (playerData.scorecardStatus?.locked && playerData.playerScores?.length > 0) {
              const playerKey = playerData.playerReg || playerId;
              digitalScorecardData[playerKey] = {
                playerId: playerId,
                playerReg: playerData.playerReg,
                playerName: playerData.playerName,
                playerScores: playerData.playerScores,
                signedAt: playerData.scorecardStatus?.lockedAt
              };
            }
          }
          
          console.log('üì± Digital scorecards available:', Object.keys(digitalScorecardData).length);
        } catch (err) {
          console.error('Failed to load digital scorecard availability:', err);
        }
      }

      // Load digital scorecard scores from Firebase (only NEW ones not yet imported)
      async function loadDigitalScorecardScores(roundId) {
        if (!window.db) {
          console.log('Firebase database not available for digital scorecard scores');
          return 0;
        }
        
        try {
          // Load availability first
          await loadDigitalScorecardAvailability(roundId);
          
          // Merge with existing scores data
          const scoresData = getScoresData();
          if (!scoresData[roundId]) {
            scoresData[roundId] = {};
          }
          
          let importedCount = 0;
          
          // Only import scorecards that haven't been imported yet
          for (const [playerKey, digitalData] of Object.entries(digitalScorecardData)) {
            const existingScore = scoresData[roundId][playerKey];
            
            // Skip if already has scores (either manual or already imported)
            if (existingScore && hasManualScores(existingScore)) {
              console.log('Skipping', playerKey, '- already has scores');
              continue;
            }
            
            // Import this scorecard
            const imported = importSingleDigitalScorecard(roundId, playerKey, digitalData, scoresData);
            if (imported) importedCount++;
          }
          
          if (importedCount > 0) {
            localStorage.setItem('scores', JSON.stringify(scoresData));
            console.log(`‚úÖ Imported ${importedCount} NEW digital scorecard scores for round ${roundId}`);
          }
          
          return importedCount;
        } catch (err) {
          console.error('Failed to load digital scorecard scores:', err);
          return 0;
        }
      }
      
      // Import a single digital scorecard (used by both bulk import and individual reimport)
      function importSingleDigitalScorecard(roundId, playerKey, digitalData, scoresData) {
        const playerScores = digitalData.playerScores || [];
        if (playerScores.length === 0) return false;
        
        const holesArray = playerScores.map(score => {
          if (score === null || score === undefined) return '';
          if (score === 'X') return 0;
          return score;
        });
        
        // Set empty arrays so they get recalculated when player is selected
        scoresData[roundId][playerKey] = {
          holes: holesArray,
          points: Array(18).fill(''),
          stablefordPoints: Array(18).fill(''),
          incompleteHoles: holesArray.map((s, i) => s === 0 ? i : -1).filter(i => i >= 0),
          status: '',
          digitalScorecard: true,
          signedAt: digitalData.signedAt || Date.now(),
          syncedFromDigitalScorecard: true,
          needsRecalculation: true
        };
        
        console.log('üì± Imported digital scorecard for:', playerKey);
        return true;
      }
      
      // Reimport a single player's digital scorecard (force reimport)
      async function reimportDigitalScorecard(playerKey) {
        const digitalData = digitalScorecardData[playerKey];
        if (!digitalData) {
          alert('No digital scorecard found for this player');
          return;
        }
        
        const scoresData = getScoresData();
        if (!scoresData[currentRoundId]) {
          scoresData[currentRoundId] = {};
        }
        
        // Force reimport - just import holes, points will be recalculated when player is selected
        const imported = importSingleDigitalScorecard(currentRoundId, playerKey, digitalData, scoresData);
        
        if (imported) {
          localStorage.setItem('scores', JSON.stringify(scoresData));
          
          // Refresh the view - this will reload scores
          await loadScores();
          
          // Now select the player to trigger proper recalculation with courseData loaded
          const player = admittedPlayers.find(p => p.reg === playerKey);
          if (player) {
            selectPlayer(player);
            
            // Force recalculation by simulating entering each score
            const playerScores = scores[playerKey];
            if (playerScores && courseData) {
              for (let i = 0; i < 18; i++) {
                const score = playerScores.holes[i];
                if (score === '' || score === null || score === undefined) continue;
                
                // Use the same calculation as manual entry
                playerScores.points[i] = calculatePoints(i, score, player);
                playerScores.stablefordPoints[i] = calculateStablefordPoints(i, score, player);
              }
              
              // Save and update display
              const scoresDataUpdated = getScoresData();
              scoresDataUpdated[currentRoundId][playerKey] = playerScores;
              saveScoresData(scoresDataUpdated);
              
              // Re-render scorecard to show correct values
              renderScorecard(player);
              updateTotals(playerKey);
            }
          }
          
          alert(`‚úÖ Reimported digital scorecard for ${digitalData.playerName || playerKey}`);
        }
      }
      
      // Check if score data has manual entries
      function hasManualScores(scoreData) {
        if (!scoreData || !scoreData.holes) return false;
        return scoreData.holes.some(h => h !== '' && h !== null && h !== undefined);
      }
      
      // Recalculate all digital scorecard scores that need recalculation
      function recalculateAllDigitalScores() {
        if (!courseData || !courseData.pars) {
          console.log('Course data not available for recalculation');
          return;
        }
        
        const scoresData = getScoresData();
        const roundScores = scoresData[currentRoundId] || {};
        let recalcCount = 0;
        
        for (const [playerKey, playerScores] of Object.entries(roundScores)) {
          if (playerScores.syncedFromDigitalScorecard && playerScores.needsRecalculation) {
            // Find the player to get PHCP
            const player = admittedPlayers.find(p => p.reg === playerKey);
            if (!player) continue;
            
            // Ensure PHCP is calculated
            if (player.phcp === undefined || player.phcp === null || player.phcp === '') {
              player.phcp = calculatePlayingHcp(player);
            }
            
            // Recalculate points
            for (let i = 0; i < 18; i++) {
              const score = playerScores.holes[i];
              if (score === '' || score === null || score === undefined) continue;
              
              const par = courseData.pars[i];
              playerScores.points[i] = par - score;
              playerScores.stablefordPoints[i] = calculateStablefordPoints(i, score, player);
            }
            
            playerScores.needsRecalculation = false;
            recalcCount++;
          }
        }
        
        if (recalcCount > 0) {
          scoresData[currentRoundId] = roundScores;
          saveScoresData(scoresData);
          scores = roundScores;
          console.log(`‚úÖ Recalculated points for ${recalcCount} digital scorecards`);
        }
      }
      
      // Manual refresh digital scorecard scores
      async function refreshDigitalScores() {
        // Load availability first
        await loadDigitalScorecardAvailability(currentRoundId);
        
        const totalAvailable = Object.keys(digitalScorecardData).length;
        
        if (totalAvailable === 0) {
          alert('No signed digital scorecards found.\n\nScores appear here after players sign their digital scorecards.');
          return;
        }
        
        // Count how many are already imported
        const scoresData = getScoresData();
        const roundScores = scoresData[currentRoundId] || {};
        let alreadyImported = 0;
        let notYetImported = 0;
        
        for (const playerKey of Object.keys(digitalScorecardData)) {
          if (roundScores[playerKey] && hasManualScores(roundScores[playerKey])) {
            alreadyImported++;
          } else {
            notYetImported++;
          }
        }
        
        if (notYetImported === 0) {
          alert(`üì± All ${totalAvailable} digital scorecards already imported.\n\nUse the üì± button next to a player's name to reimport their individual scorecard.`);
          renderPlayersList(); // Refresh to show reimport buttons
          return;
        }
        
        // Import only new ones
        const importedCount = await loadDigitalScorecardScores(currentRoundId);
        if (importedCount > 0) {
          recalculateAllDigitalScores();
          alert(`üì± Imported ${importedCount} new score(s) from digital scorecards.\n\n${alreadyImported} already imported (use individual üì± button to reimport).`);
          loadScores();
        }
      }

      // Get match scores data
      function getMatchScoresData() {
        try {
          const raw = localStorage.getItem('matchScores');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse match scores', err);
          return {};
        }
      }
      
      // Recalculate points and stableford for imported digital scorecard scores
      function recalculateDigitalScorecardPoints(player) {
        const playerKey = player.reg;
        const playerScores = scores[playerKey];
        
        if (!playerScores || !courseData || !courseData.pars) return;
        
        console.log('üì± Recalculating points for digital scorecard:', playerKey);
        
        for (let i = 0; i < 18; i++) {
          const score = playerScores.holes[i];
          if (score === '' || score === null || score === undefined) continue;
          
          // Calculate points (gross)
          const par = courseData.pars[i];
          const points = par - score;
          playerScores.points[i] = points;
          
          // Calculate stableford points (using player's PHCP)
          const stablefordPoints = calculateStablefordPoints(i, score, player);
          playerScores.stablefordPoints[i] = stablefordPoints;
        }
        
        // Mark as recalculated
        playerScores.needsRecalculation = false;
        
        // Save updated scores
        const scoresData = getScoresData();
        scoresData[currentRoundId][playerKey] = playerScores;
        saveScoresData(scoresData);
        scores[playerKey] = playerScores;
        
        console.log('‚úÖ Recalculated points for:', playerKey);
      }

      // Save match scores data
      function saveMatchScoresData(matchScoresData) {
        localStorage.setItem('matchScores', JSON.stringify(matchScoresData));
        // Sync to Firebase if available
        if (typeof syncToFirebase !== 'undefined') {
          syncToFirebase('matchScores', matchScoresData)
            .then(() => console.log('‚úì Match scores synced to Firebase'))
            .catch(e => {
              console.error('Firebase sync failed:', e);
            });
        }
      }

      // Load and render match scores
      function loadMatchScores() {
        console.log('loadMatchScores called, currentRoundId:', currentRoundId);
        const drawData = getDrawData(currentRoundId);
        console.log('Draw data:', drawData);
        
        if (!drawData || !drawData.groups || drawData.groups.length === 0) {
          document.getElementById('match-list').innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">üìã</div>
              <p>No draw data found for this round. Please create groups in the Draw page first.</p>
            </div>
          `;
          return;
        }

        // Get the match type for this round
        const roundIds = currentTournament.meta?.roundIds || [];
        const roundIndex = roundIds.indexOf(currentRoundId);
        const roundData = currentTournament.meta?.roundsData?.[roundIndex];
        const matchType = (roundData?.matchType || '').toLowerCase();
        console.log('Match type for round:', matchType);

        // Get existing match scores
        const matchScoresData = getMatchScoresData();
        const roundMatchScores = matchScoresData[currentRoundId] || {};

        // Render matches based on groups and match type
        renderMatchList(drawData.groups, roundMatchScores, matchType);
      }

      // Render the match list
      function renderMatchList(groups, matchScores, matchType) {
        const container = document.getElementById('match-list');
        let html = '';
        let matchIndex = 0; // Global match index across all groups

        groups.forEach((group, groupIndex) => {
          const players = group.players || [];
          
          if (players.length < 2) return;

          // For SINGLES: Each group can have multiple individual matches (1v2, 3v4)
          // For FOURBALL/FOURSOMES: Group is one match (pair vs pair)
          if (matchType === 'singles' || matchType === '') {
            // Singles: Create separate matches for each pair of players
            // Players 1&2 compete, Players 3&4 compete (if 4 in group)
            const numMatches = Math.floor(players.length / 2);
            
            for (let i = 0; i < numMatches; i++) {
              const player1 = players[i * 2];
              const player2 = players[i * 2 + 1];
              
              if (!player1 || !player2) continue;
              
              const matchKey = `match_${groupIndex}_${i}`;
              const existingScore = matchScores[matchKey] || { left: '', right: '' };
              
              html += `
                <div class="match-card" data-match-index="${groupIndex}" data-sub-match="${i}">
                  <!-- Player 1 -->
                  <div class="match-team left" style="border-left-color: #3b82f6;">
                    <div class="match-player">${player1.firstName} ${player1.lastName}</div>
                  </div>

                  <!-- Left Score Input -->
                  <input type="number" 
                         class="match-score-input ${getScoreInputClass(existingScore, 'left')}" 
                         data-match="${groupIndex}" 
                         data-sub-match="${i}"
                         data-side="left" 
                         value="${existingScore.left !== '' ? existingScore.left : ''}"
                         min="0" 
                         max="10"
                         placeholder="">

                  <!-- VS -->
                  <div class="match-vs">VS</div>

                  <!-- Right Score Input -->
                  <input type="number" 
                         class="match-score-input ${getScoreInputClass(existingScore, 'right')}" 
                         data-match="${groupIndex}" 
                         data-sub-match="${i}"
                         data-side="right" 
                         value="${existingScore.right !== '' ? existingScore.right : ''}"
                         min="0" 
                         max="10"
                         placeholder="">

                  <!-- Player 2 -->
                  <div class="match-team right" style="border-right-color: #ec4899;">
                    <div class="match-player">${player2.firstName} ${player2.lastName}</div>
                  </div>
                </div>
              `;
              matchIndex++;
            }
          } else {
            // Fourball/Foursomes: Group is one match with pairs
            const leftPlayers = players.slice(0, 2);
            const rightPlayers = players.slice(2, 4);
            
            const leftTeamName = leftPlayers[0]?.teamName || leftPlayers[0]?.team || '';
            const rightTeamName = rightPlayers[0]?.teamName || rightPlayers[0]?.team || '';

            const matchKey = `match_${groupIndex}`;
            const existingScore = matchScores[matchKey] || { left: '', right: '' };

            html += `
              <div class="match-card" data-match-index="${groupIndex}">
                <!-- Left Team -->
                <div class="match-team left">
                  ${leftTeamName ? `<div class="match-team-name">${leftTeamName}</div>` : ''}
                  ${leftPlayers.map(p => `
                    <div class="match-player">${p.firstName} ${p.lastName}</div>
                  `).join('')}
                </div>

                <!-- Left Score Input -->
                <input type="number" 
                       class="match-score-input ${getScoreInputClass(existingScore, 'left')}" 
                       data-match="${groupIndex}" 
                       data-side="left" 
                       value="${existingScore.left !== '' ? existingScore.left : ''}"
                       min="0" 
                       max="10"
                       placeholder="">

                <!-- VS -->
                <div class="match-vs">VS</div>

                <!-- Right Score Input -->
                <input type="number" 
                       class="match-score-input ${getScoreInputClass(existingScore, 'right')}" 
                       data-match="${groupIndex}" 
                       data-side="right" 
                       value="${existingScore.right !== '' ? existingScore.right : ''}"
                       min="0" 
                       max="10"
                       placeholder="">

                <!-- Right Team -->
                <div class="match-team right">
                  ${rightTeamName ? `<div class="match-team-name">${rightTeamName}</div>` : ''}
                  ${rightPlayers.length > 0 ? rightPlayers.map(p => `
                    <div class="match-player">${p.firstName} ${p.lastName}</div>
                  `).join('') : '<div class="match-player" style="color: #94a3b8;">No opponent</div>'}
                </div>
              </div>
            `;
            matchIndex++;
          }
        });

        container.innerHTML = html || '<div class="empty-state"><p>No matches found in the draw.</p></div>';

        // Add event listeners to score inputs
        container.querySelectorAll('.match-score-input').forEach(input => {
          input.addEventListener('input', handleMatchScoreInput);
          input.addEventListener('blur', handleMatchScoreBlur);
          input.addEventListener('keydown', handleMatchScoreKeydown);
        });

        // Setup match search
        setupMatchSearch();
        
        // Add click handlers to clear search when clicking score inputs
        addScoreInputClickHandlers();
      }

      // Handle keydown on score inputs - Enter goes back to search
      function handleMatchScoreKeydown(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          saveCurrentMatchScores();
          const searchInput = document.getElementById('match-search');
          if (searchInput) {
            searchInput.focus();
            searchInput.select();
          }
        }
      }

      // Track current highlighted match index for keyboard navigation
      let matchSearchResults = [];
      let currentMatchIndex = -1;

      // Setup match search functionality
      function setupMatchSearch() {
        const searchInput = document.getElementById('match-search');
        if (!searchInput) return;

        searchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase().trim();
          const matchCards = document.querySelectorAll('.match-card');
          
          // Reset search results
          matchSearchResults = [];
          currentMatchIndex = -1;

          matchCards.forEach(card => {
            // Remove any previous highlight
            card.classList.remove('search-highlight');
            
            if (!searchTerm) {
              // No search term - show all and remove highlight
              card.style.display = 'flex';
              card.style.border = '';
              card.style.boxShadow = '';
              return;
            }

            // Get all player names in this match
            const playerNames = card.querySelectorAll('.match-player');
            let found = false;

            playerNames.forEach(playerEl => {
              const nameText = playerEl.textContent.toLowerCase();
              if (nameText.includes(searchTerm)) {
                found = true;
              }
            });

            if (found) {
              card.style.display = 'flex';
              card.style.border = '3px solid #3b82f6';
              card.style.boxShadow = '0 4px 12px rgba(59, 130, 246, 0.3)';
              matchSearchResults.push(card);
            } else {
              card.style.display = 'none';
              card.style.border = '';
              card.style.boxShadow = '';
            }
          });

          // Highlight first result if any
          if (matchSearchResults.length > 0) {
            currentMatchIndex = 0;
            highlightCurrentMatch();
          }
        });

        // Keyboard navigation for search results
        searchInput.addEventListener('keydown', (e) => {
          if (matchSearchResults.length === 0) return;

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            currentMatchIndex = (currentMatchIndex + 1) % matchSearchResults.length;
            highlightCurrentMatch();
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            currentMatchIndex = (currentMatchIndex - 1 + matchSearchResults.length) % matchSearchResults.length;
            highlightCurrentMatch();
          } else if (e.key === 'Enter') {
            e.preventDefault();
            // Focus the first score input in the current match
            if (matchSearchResults[currentMatchIndex]) {
              const firstInput = matchSearchResults[currentMatchIndex].querySelector('.match-score-input');
              if (firstInput) {
                clearMatchSearch();
                firstInput.focus();
              }
            }
          } else if (e.key === 'Escape') {
            clearMatchSearch();
          }
        });
      }

      // Highlight the currently selected match in search results
      function highlightCurrentMatch() {
        // Remove highlight from all
        matchSearchResults.forEach(card => {
          card.classList.remove('search-highlight');
          card.style.border = '3px solid #3b82f6';
        });

        // Add highlight to current
        if (matchSearchResults[currentMatchIndex]) {
          const card = matchSearchResults[currentMatchIndex];
          card.classList.add('search-highlight');
          card.style.border = '3px solid #f59e0b';
          card.style.boxShadow = '0 4px 16px rgba(245, 158, 11, 0.4)';
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }

      // Clear match search and show all matches
      function clearMatchSearch() {
        const searchInput = document.getElementById('match-search');
        if (searchInput) {
          searchInput.value = '';
        }
        
        const matchCards = document.querySelectorAll('.match-card');
        matchCards.forEach(card => {
          card.style.display = 'flex';
          card.style.border = '';
          card.style.boxShadow = '';
          card.classList.remove('search-highlight');
        });
        
        matchSearchResults = [];
        currentMatchIndex = -1;
      }

      // Add click handler to score inputs to clear search
      function addScoreInputClickHandlers() {
        document.querySelectorAll('.match-score-input').forEach(input => {
          input.addEventListener('focus', () => {
            clearMatchSearch();
          });
        });
      }

      // Get CSS class for score input based on current scores
      function getScoreInputClass(score, side) {
        if (score.left === '' && score.right === '') return '';
        
        const leftScore = parseInt(score.left) || 0;
        const rightScore = parseInt(score.right) || 0;
        
        // Both 0 = tied
        if (leftScore === 0 && rightScore === 0 && score.left !== '' && score.right !== '') {
          return 'tied';
        }
        
        if (side === 'left') {
          if (leftScore > rightScore) return 'winner';
          if (leftScore < rightScore) return 'loser';
          return 'tied';
        } else {
          if (rightScore > leftScore) return 'winner';
          if (rightScore < leftScore) return 'loser';
          return 'tied';
        }
      }

      // Handle match score input
      function handleMatchScoreInput(e) {
        const input = e.target;
        const matchIndex = input.dataset.match;
        const subMatch = input.dataset.subMatch; // For singles matches
        const side = input.dataset.side;
        let value = input.value.trim();
        
        // Only allow numbers
        if (value !== '' && !/^\d+$/.test(value)) {
          input.value = '';
          return;
        }

        const numValue = value === '' ? '' : parseInt(value);
        
        // Build selector that includes sub-match if present
        const subMatchSelector = subMatch !== undefined ? `[data-sub-match="${subMatch}"]` : ':not([data-sub-match])';
        const otherSide = side === 'left' ? 'right' : 'left';
        const otherInput = document.querySelector(`.match-score-input[data-match="${matchIndex}"]${subMatchSelector}[data-side="${otherSide}"]`);
        
        if (!otherInput) return;
        
        if (numValue === '') {
          // Clear both if empty
          otherInput.value = '';
          updateMatchScoreStyles(matchIndex, subMatch, '', '');
        } else if (numValue === 0) {
          // Tie - both get 0
          otherInput.value = '0';
          updateMatchScoreStyles(matchIndex, subMatch, 0, 0);
        } else {
          // Winner entered - other side gets 0
          otherInput.value = '0';
          if (side === 'left') {
            updateMatchScoreStyles(matchIndex, subMatch, numValue, 0);
          } else {
            updateMatchScoreStyles(matchIndex, subMatch, 0, numValue);
          }
        }
      }

      // Handle blur to save
      function handleMatchScoreBlur(e) {
        saveCurrentMatchScores();
      }

      // Update match score input styles
      function updateMatchScoreStyles(matchIndex, subMatch, leftScore, rightScore) {
        // Build selector that includes sub-match if present
        const subMatchSelector = subMatch !== undefined ? `[data-sub-match="${subMatch}"]` : ':not([data-sub-match])';
        const leftInput = document.querySelector(`.match-score-input[data-match="${matchIndex}"]${subMatchSelector}[data-side="left"]`);
        const rightInput = document.querySelector(`.match-score-input[data-match="${matchIndex}"]${subMatchSelector}[data-side="right"]`);
        
        if (!leftInput || !rightInput) return;
        
        // Remove all classes
        leftInput.classList.remove('winner', 'loser', 'tied', 'has-score');
        rightInput.classList.remove('winner', 'loser', 'tied', 'has-score');
        
        if (leftScore === '' && rightScore === '') return;
        
        leftInput.classList.add('has-score');
        rightInput.classList.add('has-score');
        
        // Both 0 = tied
        if (leftScore === 0 && rightScore === 0) {
          leftInput.classList.add('tied');
          rightInput.classList.add('tied');
        } else if (leftScore > rightScore) {
          leftInput.classList.add('winner');
          rightInput.classList.add('loser');
        } else {
          leftInput.classList.add('loser');
          rightInput.classList.add('winner');
        }
      }

      // Save current match scores
      function saveCurrentMatchScores() {
        const matchScoresData = getMatchScoresData();
        matchScoresData[currentRoundId] = matchScoresData[currentRoundId] || {};
        
        document.querySelectorAll('.match-card').forEach(card => {
          const matchIndex = card.dataset.matchIndex;
          const subMatch = card.dataset.subMatch; // For singles matches
          const leftInput = card.querySelector('[data-side="left"]');
          const rightInput = card.querySelector('[data-side="right"]');
          
          const leftValue = leftInput.value.trim();
          const rightValue = rightInput.value.trim();
          
          // Use different key format for singles (with sub-match) vs team matches
          const matchKey = subMatch !== undefined ? `match_${matchIndex}_${subMatch}` : `match_${matchIndex}`;
          
          matchScoresData[currentRoundId][matchKey] = {
            left: leftValue === '' ? '' : parseInt(leftValue),
            right: rightValue === '' ? '' : parseInt(rightValue)
          };
        });
        
        saveMatchScoresData(matchScoresData);
        console.log('Match scores saved:', matchScoresData[currentRoundId]);
      }

      // Initialize
      function init() {
        currentTournament = getTournament();
        
        if (!currentTournament) {
          alert('Tournament not found.');
          window.location.href = 'index.html';
          return;
        }

        // Check if this is a match play tournament
        const tournamentType = (currentTournament.type || '').toLowerCase();
        isMatchPlay = tournamentType.includes('match');
        
        console.log('Tournament type:', currentTournament.type, '| isMatchPlay:', isMatchPlay);
        
        // Check if mode is passed from scores_mode.html
        const modeParam = urlParams.get('mode');
        if (modeParam === 'match-score' || modeParam === 'hole-by-hole') {
          scoreEntryMethod = modeParam;
          console.log('Score entry method set from URL:', scoreEntryMethod);
        } else if (isMatchPlay) {
          // If match play but no mode specified, show method selection modal
          showMatchPlayMethodModal();
        }

        document.getElementById('tournament-name').textContent = `Enter scores for ${currentTournament.name}`;

        // Populate round selector
        const roundSelect = document.getElementById('round-select');
        const roundIds = currentTournament.meta?.roundIds || [currentTournament.tournamentId + '-1'];
        const roundsData = currentTournament.meta?.roundsData || [];

        roundIds.forEach((rid, idx) => {
          const option = document.createElement('option');
          option.value = rid;
          
          if (roundsData[idx]) {
            const roundDate = roundsData[idx].date ? formatDateDDMMYYYY(roundsData[idx].date) : '';
            option.textContent = `Round ${idx + 1}${roundDate ? ' - ' + roundDate : ''}`;
          } else {
            option.textContent = `Round ${idx + 1}`;
          }
          
          roundSelect.appendChild(option);
        });

        currentRoundId = roundIds[0];
        currentRoundIndex = 0;
        roundSelect.value = currentRoundId;

        roundSelect.addEventListener('change', (e) => {
          currentRoundId = e.target.value;
          currentRoundIndex = roundIds.indexOf(currentRoundId);
          
          // Reload based on current entry method
          if (scoreEntryMethod === 'match-score') {
            loadMatchScores();
          } else if (scoreEntryMethod === 'hole-by-hole' && isMatchPlay) {
            // For match play hole-by-hole, reload matches
            loadHoleByHoleMatches();
          } else {
            loadScores();
          }
        });

        // Load appropriate view based on entry method
        if (scoreEntryMethod === 'match-score') {
          initMatchScoreUI();
        } else if (scoreEntryMethod === 'hole-by-hole' && isMatchPlay) {
          // For Match Play hole-by-hole, always show matches panel
          console.log('Initializing hole-by-hole for match play');
          document.querySelector('.scores-grid').style.display = 'grid';
          document.getElementById('players-panel').style.display = 'none';
          document.getElementById('matches-panel').style.display = 'block';
          updateEntryMethodBadge();
          initHoleByHoleMatchUI();
        } else {
          loadScores();
        }
      }

      async function loadScores() {
        // Skip loading scores if we're in match play hole-by-hole mode
        if (scoreEntryMethod === 'hole-by-hole' && isMatchPlay) {
          console.log('Skipping loadScores - in match play hole-by-hole mode');
          return;
        }
        
        admittedPlayers = getAdmittedPlayers();
        selectedPlayer = null;
        
        if (admittedPlayers.length === 0) {
          document.getElementById('status-text').textContent = 'No admitted players for this round.';
          document.getElementById('players-tbody').innerHTML = '<tr><td colspan="2" style="text-align: center; color: #6b7280; padding: 20px;">No players admitted yet.</td></tr>';
          return;
        }

        // Get course info
        const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
        if (roundData && roundData.course) {
          const courses = getCourses();
          courseData = courses.find(c => c.courseId === roundData.course);
        }

        // Load digital scorecard scores from Firebase first
        const importedCount = await loadDigitalScorecardScores(currentRoundId);
        if (importedCount > 0) {
          console.log(`üì± Loaded ${importedCount} scores from digital scorecards`);
        }

        // Load existing scores (now includes digital scorecard scores)
        const scoresData = getScoresData();
        const roundScores = scoresData[currentRoundId] || {};
        scores = {};
        
        admittedPlayers.forEach(player => {
          const playerKey = player.reg;
          const numHoles = courseData?.pars?.length || 18;
          scores[playerKey] = roundScores[playerKey] || {
            holes: Array(numHoles).fill(''),
            points: Array(numHoles).fill(''),
            stablefordPoints: Array(numHoles).fill(''),
            incompleteHoles: [], // Track holes where player did not complete (0 entered)
            status: ''
          };
        });

        renderPlayersList();
        updateStatus();
      }

      function renderPlayersList() {
        // Skip rendering players list if we're in match play hole-by-hole mode
        if (scoreEntryMethod === 'hole-by-hole' && isMatchPlay) {
          console.log('Skipping renderPlayersList - in match play hole-by-hole mode');
          return;
        }
        
        const tbody = document.getElementById('players-tbody');
        const searchTerm = document.getElementById('player-search').value.toLowerCase();
        
        let playersToShow;
        if (searchTerm) {
          playersToShow = admittedPlayers.filter(p => {
            const fullName = `${p.firstName} ${p.lastName}`.toLowerCase();
            const reg = (p.reg || '').toString().toLowerCase();
            return fullName.includes(searchTerm) || reg.includes(searchTerm);
          });
        } else {
          playersToShow = [...admittedPlayers];
        }
        
        // Sort: incomplete players first, completed players middle, status players at bottom
        playersToShow.sort((a, b) => {
          const aScores = scores[a.reg]?.holes || [];
          const bScores = scores[b.reg]?.holes || [];
          const aStatus = scores[a.reg]?.status || '';
          const bStatus = scores[b.reg]?.status || '';
          const aComplete = aScores.filter(s => s !== '' && s !== null && s !== undefined).length === 18;
          const bComplete = bScores.filter(s => s !== '' && s !== null && s !== undefined).length === 18;
          
          // Players with status (DQ, NS, NR) always go to the very bottom
          if (aStatus && !bStatus) return 1;
          if (!aStatus && bStatus) return -1;
          if (aStatus && bStatus) {
            // Both have status, sort alphabetically
            const aName = `${a.firstName} ${a.lastName}`.toLowerCase();
            const bName = `${b.firstName} ${b.lastName}`.toLowerCase();
            return aName.localeCompare(bName);
          }
          
          // Among players without status: incomplete first, complete second
          if (aComplete && !bComplete) return 1;
          if (!aComplete && bComplete) return -1;
          
          // Within each group, apply the appropriate sort
          let comparison = 0;
          
          // For incomplete players, use selected sort column
          if (!aComplete && !bComplete) {
            if (sortColumn === 'name') {
              const aName = `${a.firstName} ${a.lastName}`.toLowerCase();
              const bName = `${b.firstName} ${b.lastName}`.toLowerCase();
              comparison = aName.localeCompare(bName);
            } else if (sortColumn === 'phcp') {
              const aPhcp = typeof a.phcp === 'string' ? (a.phcp.startsWith('+') ? -parseInt(a.phcp.substring(1)) : parseInt(a.phcp)) : (a.phcp || 0);
              const bPhcp = typeof b.phcp === 'string' ? (b.phcp.startsWith('+') ? -parseInt(b.phcp.substring(1)) : parseInt(b.phcp)) : (b.phcp || 0);
              comparison = aPhcp - bPhcp;
            }
            return sortDirection === 'asc' ? comparison : -comparison;
          }
          
          // For complete players, always sort by score (lowest first)
          if (aComplete && bComplete) {
            const aTotal = aScores.reduce((sum, score) => sum + (parseInt(score) || 0), 0);
            const bTotal = bScores.reduce((sum, score) => sum + (parseInt(score) || 0), 0);
            return aTotal - bTotal;
          }
          
          return 0;
        });
        
        filteredPlayers = playersToShow;

        tbody.innerHTML = '';
        filteredPlayers.forEach((player, idx) => {
          const row = tbody.insertRow();
          row.dataset.playerReg = player.reg;
          
          // Check if player has completed all 18 holes
          const playerScores = scores[player.reg]?.holes || [];
          const completedHoles = playerScores.filter(s => s !== '' && s !== null && s !== undefined).length;
          const isComplete = completedHoles === 18;
          
          if (isComplete) {
            row.classList.add('completed');
          }
          
          if (selectedPlayer && selectedPlayer.reg === player.reg) {
            row.classList.add('selected');
          }
          
          // Highlight row if it matches highlightedIndex
          if (idx === highlightedIndex) {
            row.style.background = '#dbeafe';
          }

          const nameCell = row.insertCell();
          const playerName = `${player.firstName} ${player.lastName}`;
          const playerStatus = scores[player.reg]?.status || '';
          
          // Check if player has a signed digital scorecard available
          const hasDigitalScorecard = digitalScorecardData[player.reg] !== undefined;
          const isImportedFromDigital = scores[player.reg]?.syncedFromDigitalScorecard;
          
          // Show reimport button if digital scorecard is available
          const reimportBtn = hasDigitalScorecard ? 
            `<button onclick="event.stopPropagation(); reimportDigitalScorecard('${player.reg}')" 
              style="margin-left: 6px; padding: 2px 6px; font-size: 10px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer;" 
              title="Reimport from digital scorecard">üì±</button>` : '';
          
          // Show badge if already imported from digital
          const digitalBadge = isImportedFromDigital ? '<span style="color: #8b5cf6; font-size: 11px; margin-left: 4px;" title="Imported from Digital Scorecard">‚úì</span>' : '';
          
          if (playerStatus) {
            nameCell.innerHTML = `${playerName}${digitalBadge}${reimportBtn} <span class="player-total-score" style="color: #dc2626;">(${playerStatus})</span>`;
            row.style.background = '#fee2e2'; // Light red background for status players
          } else if (isComplete) {
            // Add total score if complete and no status
            const totalScore = playerScores.reduce((sum, score) => {
              const numScore = parseInt(score);
              return sum + (isNaN(numScore) ? 0 : numScore);
            }, 0);
            nameCell.innerHTML = `${playerName}${digitalBadge}${reimportBtn} <span class="player-total-score">(${totalScore})</span>`;
          } else {
            nameCell.innerHTML = `${playerName}${digitalBadge}${reimportBtn}`;
          }
          
          const phcpCell = row.insertCell();
          let phcpDisplay = '-';
          // Use stored PHCP or calculate it as fallback
          let phcpValue = player.phcp;
          if (phcpValue === undefined || phcpValue === null || phcpValue === '') {
            phcpValue = calculatePlayingHcp(player);
            // Store calculated PHCP back to player for consistency
            if (phcpValue !== '' && phcpValue !== undefined) {
              player.phcp = phcpValue;
            }
          }
          if (phcpValue !== '' && phcpValue !== undefined && phcpValue !== null) {
            phcpDisplay = phcpValue < 0 ? '+' + Math.abs(phcpValue) : phcpValue;
          }
          phcpCell.textContent = phcpDisplay;
          phcpCell.style.textAlign = 'center';

          row.addEventListener('click', () => {
            selectPlayer(player);
            highlightedIndex = -1;
          });
        });

        updateStatus();
      }

      function selectPlayer(player) {
        selectedPlayer = player;
        
        console.log('Selected player:', player);
        console.log('Player PHCP value:', player.phcp, 'Type:', typeof player.phcp);
        
        // Update selection in players list
        document.querySelectorAll('.players-table tr').forEach(tr => tr.classList.remove('selected'));
        const selectedRow = document.querySelector(`[data-player-reg="${player.reg}"]`);
        if (selectedRow) {
          selectedRow.classList.add('selected');
        }

        // Show player info
        document.getElementById('player-info').style.display = 'block';
        document.getElementById('player-name').textContent = `${player.firstName} ${player.lastName}`;
        document.getElementById('player-reg').textContent = player.reg;
        
        // Format HCP: negative values display with +, positive as-is
        let hcpDisplay = '-';
        if (player.hcp !== undefined && player.hcp !== null && player.hcp !== '') {
          const hcp = parseFloat(player.hcp);
          hcpDisplay = hcp < 0 ? '+' + Math.abs(hcp).toFixed(1) : hcp.toFixed(1);
        }
        document.getElementById('player-hcp').textContent = hcpDisplay;
        
        // Use stored playing HCP from admissions (already calculated and rounded)
        // If not stored, calculate it now as fallback
        let phcpValue = player.phcp;
        if (phcpValue === undefined || phcpValue === null || phcpValue === '') {
          phcpValue = calculatePlayingHcp(player);
          // Store calculated PHCP back to player for consistency
          if (phcpValue !== '' && phcpValue !== undefined) {
            player.phcp = phcpValue;
          }
        }
        // Format: negative numbers get + prefix, positive numbers as-is
        let phcpDisplay = '-';
        if (phcpValue !== '' && phcpValue !== undefined && phcpValue !== null) {
          phcpDisplay = phcpValue < 0 ? '+' + Math.abs(phcpValue) : phcpValue;
        }
        document.getElementById('player-phcp').textContent = phcpDisplay;

        // Recalculate points for digital scorecard imports (they don't have correct PHCP)
        const playerScores = scores[player.reg];
        if (playerScores.syncedFromDigitalScorecard && playerScores.needsRecalculation) {
          recalculateDigitalScorecardPoints(player);
        }

        // Load player status
        const statusSelect = document.getElementById('player-status');
        statusSelect.value = playerScores.status || '';
        
        // Add status change listener
        statusSelect.onchange = (e) => {
          scores[player.reg].status = e.target.value;
          saveScores();
          renderPlayersList(); // Refresh the player list to move player to correct position
          renderScorecard(player);
        };

        // Render scorecard
        renderScorecard(player);
        
        // Focus on first hole input after a short delay (to ensure DOM is ready)
        setTimeout(() => {
          const firstInput = document.querySelector('.score-input[data-hole="0"]');
          if (firstInput && !firstInput.disabled) {
            firstInput.focus();
            firstInput.select();
          }
        }, 100);
      }

      function renderScorecard(player) {
        const content = document.getElementById('scorecard-content');
        
        if (!courseData || !courseData.pars) {
          content.innerHTML = '<div class="empty-state"><p>Course data not available</p></div>';
          return;
        }

        // Ensure PHCP is calculated if not stored
        if (player.phcp === undefined || player.phcp === null || player.phcp === '') {
          const calculatedPhcp = calculatePlayingHcp(player);
          if (calculatedPhcp !== '' && calculatedPhcp !== undefined) {
            player.phcp = calculatedPhcp;
          }
        }

        const playerKey = player.reg;
        const playerScores = scores[playerKey];
        const playerStatus = playerScores.status || '';
        const pars = courseData.pars;
        const strokeIndexes = courseData.strokeIndexes || Array(pars.length).fill('-');
        
        // Show warning if player has special status
        let statusWarning = '';
        if (playerStatus === 'DQ') {
          statusWarning = '<div class="status-warning">‚ö†Ô∏è Player is DISQUALIFIED - scores will not count in results</div>';
        } else if (playerStatus === 'NS') {
          statusWarning = '<div class="status-warning">‚ö†Ô∏è Player is NO SHOW - did not start the round</div>';
        } else if (playerStatus === 'NR') {
          statusWarning = '<div class="status-warning">‚ö†Ô∏è Player is NO RETURN - did not complete the round</div>';
        }

        let html = statusWarning;
        html += '<table class="scorecard-table">';
        
        // Build header row (Hole numbers)
        html += '<thead><tr><th>Hole</th>';
        for (let i = 0; i < 9 && i < pars.length; i++) {
          html += `<th>${i + 1}</th>`;
        }
        html += '<th class="subtotal-cell">OUT</th>';
        for (let i = 9; i < 18 && i < pars.length; i++) {
          html += `<th>${i + 1}</th>`;
        }
        html += '<th class="total-cell">IN</th>';
        html += '<th class="total-cell">TOT</th>';
        html += '</tr></thead><tbody>';

        // Par row with stroke dots
        html += '<tr><td><strong>Par</strong></td>';
        let front9Par = 0, back9Par = 0;
        const phcp = player.phcp || 0;
        
        for (let i = 0; i < 9 && i < pars.length; i++) {
          const si = strokeIndexes[i];
          const strokes = getStrokesForHole(phcp, si);
          const absStrokes = Math.abs(strokes);
          let strokeMarker = '';
          if (strokes > 0) {
            // Receives strokes - blue dots
            strokeMarker = '<span style="color: #3b82f6; font-weight: bold;">' + '‚Ä¢'.repeat(absStrokes) + '</span>';
          } else if (strokes < 0) {
            // Gives strokes - red minus signs
            strokeMarker = '<span style="color: #ef4444; font-weight: bold;">' + '‚àí'.repeat(absStrokes) + '</span>';
          }
          html += `<td>${pars[i]}${strokeMarker}</td>`;
          front9Par += pars[i];
        }
        html += `<td class="subtotal-cell">${front9Par}</td>`;
        for (let i = 9; i < 18 && i < pars.length; i++) {
          const si = strokeIndexes[i];
          const strokes = getStrokesForHole(phcp, si);
          const absStrokes = Math.abs(strokes);
          let strokeMarker = '';
          if (strokes > 0) {
            // Receives strokes - blue dots
            strokeMarker = '<span style="color: #3b82f6; font-weight: bold;">' + '‚Ä¢'.repeat(absStrokes) + '</span>';
          } else if (strokes < 0) {
            // Gives strokes - red minus signs
            strokeMarker = '<span style="color: #ef4444; font-weight: bold;">' + '‚àí'.repeat(absStrokes) + '</span>';
          }
          html += `<td>${pars[i]}${strokeMarker}</td>`;
          back9Par += pars[i];
        }
        html += `<td class="subtotal-cell">${back9Par}</td>`;
        html += `<td class="total-cell">${front9Par + back9Par}</td>`;
        html += '</tr>';

        // SI row
        html += '<tr><td><strong>SI</strong></td>';
        for (let i = 0; i < 9 && i < pars.length; i++) {
          html += `<td>${strokeIndexes[i]}</td>`;
        }
        html += '<td class="subtotal-cell">-</td>';
        for (let i = 9; i < 18 && i < pars.length; i++) {
          html += `<td>${strokeIndexes[i]}</td>`;
        }
        html += '<td class="subtotal-cell">-</td>';
        html += '<td class="total-cell">-</td>';
        html += '</tr>';

        // Helper function to get score color class
        function getScoreColorClass(score, holeIndex, isIncomplete) {
          if (isIncomplete) return 'score-zero';
          if (!score || !courseData || !courseData.pars) return '';
          
          const par = courseData.pars[holeIndex];
          const diff = score - par;
          
          if (diff === 0) return 'score-par';
          if (diff === -1) return 'score-birdie';
          if (diff <= -2) return 'score-eagle';
          if (diff === 1) return 'score-bogey';
          if (diff >= 2) return 'score-double-bogey';
          return '';
        }

        // Score row
        html += '<tr><td><strong>Score</strong></td>';
        let front9Score = 0, back9Score = 0;
        const disableInputs = playerStatus === 'NS' ? 'disabled' : '';
        
        for (let i = 0; i < 9 && i < pars.length; i++) {
          const score = playerScores.holes[i];
          const isIncomplete = playerScores.isIncompleteHole?.[i];
          const displayValue = isIncomplete ? 'X' : (score || '');
          if (score) front9Score += parseInt(score);
          const colorClass = getScoreColorClass(score, i, isIncomplete);
          html += `<td><input type="text" class="score-input ${colorClass}" value="${displayValue}" 
                    data-hole="${i}" ${disableInputs}></td>`;
        }
        html += `<td class="subtotal-cell" id="front9-score">${front9Score || '-'}</td>`;
        for (let i = 9; i < 18 && i < pars.length; i++) {
          const score = playerScores.holes[i];
          const isIncomplete = playerScores.isIncompleteHole?.[i];
          const displayValue = isIncomplete ? 'X' : (score || '');
          if (score) back9Score += parseInt(score);
          const colorClass = getScoreColorClass(score, i, isIncomplete);
          html += `<td><input type="text" class="score-input ${colorClass}" value="${displayValue}" 
                    data-hole="${i}" ${disableInputs}></td>`;
        }
        html += `<td class="subtotal-cell" id="back9-score">${back9Score || '-'}</td>`;
        html += `<td class="total-cell" id="total-score">${(front9Score + back9Score) || '-'}</td>`;
        html += '</tr>';

        // Medal Net row
        html += '<tr><td><strong>Medal Net</strong></td>';
        let front9Net = 0, back9Net = 0;
        for (let i = 0; i < 9 && i < pars.length; i++) {
          const net = playerScores.points[i];
          if (net !== '' && net !== undefined && net !== null) front9Net += parseInt(net);
          html += `<td id="points-${i}">${net !== '' && net !== undefined && net !== null ? net : '-'}</td>`;
        }
        html += `<td class="subtotal-cell" id="front9-points">${front9Net || '-'}</td>`;
        for (let i = 9; i < 18 && i < pars.length; i++) {
          const net = playerScores.points[i];
          if (net !== '' && net !== undefined && net !== null) back9Net += parseInt(net);
          html += `<td id="points-${i}">${net !== '' && net !== undefined && net !== null ? net : '-'}</td>`;
        }
        html += `<td class="subtotal-cell" id="back9-points">${back9Net || '-'}</td>`;
        html += `<td class="total-cell" id="total-points">${(front9Net + back9Net) || '-'}</td>`;
        html += '</tr>';

        // Stableford Net row
        html += '<tr><td><strong>Stableford Net</strong></td>';
        let front9Stableford = 0, back9Stableford = 0;
        for (let i = 0; i < 9 && i < pars.length; i++) {
          const stableford = playerScores.stablefordPoints[i];
          if (stableford !== '' && stableford !== undefined && stableford !== null) front9Stableford += parseInt(stableford);
          html += `<td id="stableford-${i}">${stableford !== '' && stableford !== undefined && stableford !== null ? stableford : '-'}</td>`;
        }
        html += `<td class="subtotal-cell" id="front9-stableford">${front9Stableford || '-'}</td>`;
        for (let i = 9; i < 18 && i < pars.length; i++) {
          const stableford = playerScores.stablefordPoints[i];
          if (stableford !== '' && stableford !== undefined && stableford !== null) back9Stableford += parseInt(stableford);
          html += `<td id="stableford-${i}">${stableford !== '' && stableford !== undefined && stableford !== null ? stableford : '-'}</td>`;
        }
        html += `<td class="subtotal-cell" id="back9-stableford">${back9Stableford || '-'}</td>`;
        html += `<td class="total-cell" id="total-stableford">${(front9Stableford + back9Stableford) || '-'}</td>`;
        html += '</tr>';

        html += '</tbody></table>';
        content.innerHTML = html;

        // Add event listeners to score inputs
        content.querySelectorAll('.score-input').forEach(input => {
          input.addEventListener('input', (e) => {
            handleScoreInput(e, playerKey);
          });

          input.addEventListener('focus', (e) => {
            // Select all text when clicking on an input with existing value
            if (e.target.value) {
              e.target.select();
            }
          });

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              const allInputs = Array.from(content.querySelectorAll('.score-input'));
              const currentIdx = allInputs.indexOf(e.target);
              if (currentIdx < allInputs.length - 1) {
                allInputs[currentIdx + 1].focus();
                allInputs[currentIdx + 1].select();
              }
            }
          });
        });
      }

      function handleScoreInput(e, playerKey) {
        const holeIndex = parseInt(e.target.dataset.hole);
        const rawValue = e.target.value.trim().toUpperCase();
        
        // Handle X input (no score / incomplete hole) - treat as 0
        if (rawValue === 'X') {
          processScore(e.target, playerKey, holeIndex, 0);
          return;
        }
        
        let score = e.target.value ? parseInt(e.target.value) : '';
        
        // If not a valid number, ignore
        if (e.target.value && isNaN(score)) {
          return;
        }
        
        // Handle score of 1 - ask if hole-in-one or double digit
        if (score === 1 && e.target.value.length === 1) {
          showScoreModal(e.target, playerKey, holeIndex);
          return;
        }
        
        // Process score (including empty/deleted scores)
        processScore(e.target, playerKey, holeIndex, score);
      }

      function showScoreModal(inputElement, playerKey, holeIndex) {
        const modal = document.getElementById('score-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalInputContainer = document.getElementById('modal-input-container');
        const modalInput = document.getElementById('modal-input');
        const modalConfirm = document.getElementById('modal-confirm');
        const modalCancel = document.getElementById('modal-cancel');
        
        let stage = 1; // Stage 1: Ask if hole-in-one, Stage 2: Enter double digit
        
        // Stage 1: Is this a hole-in-one?
        modalTitle.textContent = 'Score Entry';
        modalMessage.textContent = 'Is this a Hole-in-One?';
        modalInputContainer.style.display = 'none';
        modalConfirm.textContent = 'Yes, Hole-in-One';
        modalCancel.textContent = 'No, Double Digit';
        modal.classList.add('active');
        
        const handleConfirm = () => {
          if (stage === 1) {
            // Hole-in-one confirmed
            cleanup();
            inputElement.value = 1;
            processScore(inputElement, playerKey, holeIndex, 1);
          } else {
            // Stage 2: Validate and save double digit
            const doubleDigit = parseInt(modalInput.value);
            if (doubleDigit && doubleDigit >= 10) {
              cleanup();
              inputElement.value = doubleDigit;
              processScore(inputElement, playerKey, holeIndex, doubleDigit);
            } else {
              modalInput.focus();
            }
          }
        };
        
        const handleCancel = () => {
          if (stage === 1) {
            // Move to stage 2: Enter double digit
            stage = 2;
            modalTitle.textContent = 'Enter Double-Digit Score';
            modalMessage.textContent = 'Enter the score (10 or higher):';
            modalInputContainer.style.display = 'block';
            modalInput.value = '10';
            modalInput.focus();
            modalInput.select();
            modalConfirm.textContent = 'Confirm';
            modalCancel.textContent = 'Cancel';
          } else {
            // Cancel double digit entry
            cleanup();
            inputElement.value = '';
          }
        };
        
        const cleanup = () => {
          modal.classList.remove('active');
          modalConfirm.removeEventListener('click', handleConfirm);
          modalCancel.removeEventListener('click', handleCancel);
          modalInput.removeEventListener('keydown', handleEnter);
        };
        
        const handleEnter = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleConfirm();
          }
        };
        
        modalConfirm.addEventListener('click', handleConfirm);
        modalCancel.addEventListener('click', handleCancel);
        modalInput.addEventListener('keydown', handleEnter);
      }

      function playerHasStablefordCategory(player) {
        // Check if player has any Stableford category assigned
        console.log('Checking Stableford for player:', player.firstName, player.lastName);
        console.log('Player categories:', player.categories);
        
        if (!player.categories || !Array.isArray(player.categories)) {
          console.log('No categories array found');
          return false;
        }
        
        const categories = getCategories();
        console.log('All tournament categories:', categories);
        
        for (const catCode of player.categories) {
          const category = categories.find(c => c.code === catCode);
          console.log(`Category ${catCode}:`, category);
          if (category && category.tournamentType) {
            console.log('Tournament type:', category.tournamentType);
            if (category.tournamentType.toLowerCase().includes('stableford')) {
              console.log('‚úì Player HAS Stableford category!');
              return true;
            }
          }
        }
        
        console.log('‚úó Player does NOT have Stableford category');
        return false;
      }
      
      function getCategories() {
        try {
          // Categories are stored in tournament.categories
          return currentTournament?.categories || [];
        } catch (err) {
          console.error('Error loading categories:', err);
          return [];
        }
      }

      function getMaxScoreForHole(holeIndex, player) {
        const maxScoreSetting = currentTournament?.meta?.maxScore;
        if (!maxScoreSetting || maxScoreSetting === 'na' || !courseData || !courseData.pars) {
          return null;
        }
        
        const par = courseData.pars[holeIndex];
        const si = courseData.strokeIndexes?.[holeIndex] || 999;
        const phcp = player.phcp || 0;
        
        switch(maxScoreSetting) {
          case 'net_double_bogey':
            // Net double bogey = par + 2 + strokes received
            const strokesReceived = getStrokesForHole(phcp, si);
            return par + 2 + strokesReceived;
          case 'par_plus_4':
            return par + 4;
          case 'double_par':
            return par * 2;
          case '10':
            return 10;
          default:
            return null;
        }
      }

      function processScore(inputElement, playerKey, holeIndex, score) {
        // Handle empty/deleted score
        if (score === '' || score === null || score === undefined) {
          scores[playerKey].holes[holeIndex] = '';
          scores[playerKey].points[holeIndex] = '';
          scores[playerKey].stablefordPoints[holeIndex] = '';
          
          // Remove from incomplete holes
          if (scores[playerKey].incompleteHoles) {
            scores[playerKey].incompleteHoles = scores[playerKey].incompleteHoles.filter(h => h !== holeIndex);
          }
          
          // Clear max score flag
          if (scores[playerKey].isMaxScoreApplied) {
            scores[playerKey].isMaxScoreApplied[holeIndex] = false;
          }
          
          // Clear styling
          inputElement.classList.remove('has-value', 'score-par', 'score-birdie', 'score-eagle', 'score-bogey', 'score-double-bogey');
          
          // Update displays
          const pointsCell = document.getElementById(`points-${holeIndex}`);
          if (pointsCell) pointsCell.textContent = '-';
          
          const stablefordCell = document.getElementById(`stableford-${holeIndex}`);
          if (stablefordCell) stablefordCell.textContent = '-';
          
          // Update totals
          updateTotals();
          return;
        }
        
        let isMaxScoreApplied = false;
        let isIncompleteHole = false;
        
        // Track if 0 was originally entered (player did not complete hole)
        if (score === 0) {
          isIncompleteHole = true;
          
          // Check if max score option is NOT activated
          const maxScore = getMaxScoreForHole(holeIndex, selectedPlayer);
          if (maxScore === null) {
            // No max score option - check if player has Stableford category
            const hasStableford = playerHasStablefordCategory(selectedPlayer);
            
            if (!hasStableford) {
              // Player doesn't have Stableford category - show warning
              const playerName = `${selectedPlayer.firstName} ${selectedPlayer.lastName}`;
              const confirmed = confirm(
                `Player ${playerName} is not assigned to a category which allows no score for a hole.\n\n` +
                `Player will be disqualified.\n\n` +
                `Click OK to mark as DQ, or Cancel to enter a proper score.`
              );
              
              if (confirmed) {
                // Mark player as DQ
                scores[playerKey].status = 'DQ';
                
                // Update status dropdown
                const statusSelect = document.getElementById('player-status');
                if (statusSelect) {
                  statusSelect.value = 'DQ';
                }
                
                // Auto-save the DQ status
                saveScores();
                
                inputElement.value = '';
                renderScorecard(selectedPlayer);
                return;
              } else {
                // Cancel - clear the input and don't process
                inputElement.value = '';
                return;
              }
            }
          }
          
          // Track incomplete hole
          if (!scores[playerKey].incompleteHoles) {
            scores[playerKey].incompleteHoles = [];
          }
          if (!scores[playerKey].incompleteHoles.includes(holeIndex)) {
            scores[playerKey].incompleteHoles.push(holeIndex);
          }
        } else {
          // Remove from incomplete holes if a real score is entered
          if (scores[playerKey].incompleteHoles) {
            scores[playerKey].incompleteHoles = scores[playerKey].incompleteHoles.filter(h => h !== holeIndex);
          }
        }
        
        // Check if max score is activated and should be applied
        const maxScore = getMaxScoreForHole(holeIndex, selectedPlayer);
        if (maxScore !== null) {
          // Apply max score if score is 0 or exceeds max score
          if (score === 0 || score > maxScore) {
            score = maxScore;
            inputElement.value = maxScore;
            isMaxScoreApplied = true;
          }
        } else if (score === 0) {
          // Max score not activated but 0 entered - use net double bogey for calculations
          // Net double bogey = par + 2 + strokes received on this hole
          const par = courseData.pars[holeIndex];
          const si = courseData.strokeIndexes?.[holeIndex] || 999;
          const phcp = selectedPlayer.phcp || 0;
          const strokesReceived = getStrokesForHole(phcp, si);
          const netDoubleBogey = par + 2 + Math.max(0, strokesReceived); // Only add positive strokes
          
          score = netDoubleBogey;
          inputElement.value = 'X'; // Display X instead of 0
          isMaxScoreApplied = true; // Mark so net calculation doesn't subtract strokes again
          isIncompleteHole = true;
        }
        
        scores[playerKey].holes[holeIndex] = score;
        scores[playerKey].isMaxScoreApplied = scores[playerKey].isMaxScoreApplied || {};
        scores[playerKey].isMaxScoreApplied[holeIndex] = isMaxScoreApplied;
        
        // Track incomplete holes for display purposes
        scores[playerKey].isIncompleteHole = scores[playerKey].isIncompleteHole || {};
        scores[playerKey].isIncompleteHole[holeIndex] = isIncompleteHole;
        
        // Apply score type styling based on par
        inputElement.classList.remove('has-value', 'score-par', 'score-birdie', 'score-eagle', 'score-bogey', 'score-double-bogey', 'score-zero');
        
        if (isIncompleteHole) {
          // Special styling for incomplete hole (X)
          inputElement.classList.add('score-zero');
        } else if (score && courseData && courseData.pars) {
          const par = courseData.pars[holeIndex];
          const diff = score - par;
          
          if (diff === 0) {
            inputElement.classList.add('score-par');
          } else if (diff === -1) {
            inputElement.classList.add('score-birdie');
          } else if (diff <= -2) {
            inputElement.classList.add('score-eagle');
          } else if (diff === 1) {
            inputElement.classList.add('score-bogey');
          } else if (diff >= 2) {
            inputElement.classList.add('score-double-bogey');
          }
        }

        // Calculate Medal Net
        const points = calculatePoints(holeIndex, score, selectedPlayer);
        scores[playerKey].points[holeIndex] = points;
        
        // Update Medal Net display
        const pointsCell = document.getElementById(`points-${holeIndex}`);
        if (pointsCell) {
          pointsCell.textContent = points || '-';
        }

        // Calculate Stableford Net
        const stablefordPoints = calculateStablefordPoints(holeIndex, score, selectedPlayer);
        scores[playerKey].stablefordPoints[holeIndex] = stablefordPoints;
        
        // Update Stableford Net display
        const stablefordCell = document.getElementById(`stableford-${holeIndex}`);
        if (stablefordCell) {
          stablefordCell.textContent = stablefordPoints !== '' ? stablefordPoints : '-';
        }

        // Update totals
        updateTotals(playerKey);

        // Auto-advance to next hole (advance for any number including 0)
        if (score !== '' && score !== null && score !== undefined) {
          const allInputs = Array.from(document.querySelectorAll('.score-input'));
          const currentIdx = allInputs.indexOf(inputElement);
          if (currentIdx < allInputs.length - 1) {
            allInputs[currentIdx + 1].focus();
            allInputs[currentIdx + 1].select();
          }
        }
      }

      function getStrokesForHole(phcp, strokeIndex) {
        // Calculate how many strokes a player receives/gives on this hole
        const si = parseInt(strokeIndex);
        if (isNaN(si) || si > 18 || si < 1) return 0;
        
        // Convert phcp to number, handling both old string format ("+2") and new numeric format (-2)
        let numPhcp;
        if (typeof phcp === 'string') {
          if (phcp.startsWith('+')) {
            // Plus handicap: "+2" becomes -2
            numPhcp = -parseInt(phcp.substring(1));
          } else {
            numPhcp = parseInt(phcp) || 0;
          }
        } else {
          numPhcp = phcp || 0;
        }
        
        const absPhcp = Math.abs(numPhcp);
        const fullStrokes = Math.floor(absPhcp / 18);
        const remainingStrokes = absPhcp % 18;
        
        if (numPhcp >= 0) {
          // Positive handicap - receives strokes on easiest holes (lowest SI)
          // SI 1, 2, 3... up to remainingStrokes
          return fullStrokes + (si <= remainingStrokes ? 1 : 0);
        } else {
          // Plus handicap - gives strokes on hardest holes (highest SI)
          // For PHCP -2: gives on SI 17 and 18 (the 2 hardest)
          // For PHCP -5: gives on SI 14, 15, 16, 17, 18 (the 5 hardest)
          // SI must be >= (19 - remainingStrokes) to give a stroke
          const givesStroke = si >= (19 - remainingStrokes) ? 1 : 0;
          return -(fullStrokes + givesStroke);
        }
      }

      function calculatePoints(holeIndex, score, player) {
        if (!score || !courseData || !courseData.pars) return '';
        
        const playerKey = player.reg;
        const isMaxScoreApplied = scores[playerKey]?.isMaxScoreApplied?.[holeIndex];
        
        // If max score was applied (0 entered or score exceeded max), don't subtract strokes
        if (isMaxScoreApplied) {
          return score; // Medal Net = Gross (no handicap adjustment)
        }
        
        const si = courseData.strokeIndexes?.[holeIndex] || 999;
        const phcp = player.phcp || 0;
        
        // Calculate strokes received/given on this hole
        const strokesReceived = getStrokesForHole(phcp, si);
        
        // Medal Net score = Gross score - strokes received
        // For plus handicaps, strokesReceived is negative, so subtracting adds to the score
        // Example: score=4, strokes=-1 (gives 1), net = 4 - (-1) = 5
        const netScore = score - strokesReceived;
        
        return netScore;
      }

      function calculateStablefordPoints(holeIndex, score, player) {
        if (score === '' || score === null || score === undefined || !courseData || !courseData.pars) return '';
        
        // If score is 0, return 0 Stableford points
        if (score === 0) return 0;
        
        const par = courseData.pars[holeIndex];
        const si = courseData.strokeIndexes?.[holeIndex] || 999;
        const phcp = player.phcp || 0;
        
        // Calculate strokes received/given on this hole
        const strokesReceived = getStrokesForHole(phcp, si);
        
        // Net score for this hole
        const netScore = score - strokesReceived;
        
        // Stableford points calculation
        // Par or better: 2 + (par - netScore)
        // Over par: max(0, 2 - (netScore - par))
        const scoreDiff = netScore - par;
        
        if (scoreDiff <= 0) {
          // Par or better: Birdie = 3, Eagle = 4, etc.
          return 2 - scoreDiff;
        } else {
          // Over par: Bogey = 1, Double+ = 0
          return Math.max(0, 2 - scoreDiff);
        }
      }

      function updateTotals(playerKey) {
        const playerScores = scores[playerKey];
        
        let front9Score = 0, front9Points = 0, front9Stableford = 0;
        let back9Score = 0, back9Points = 0, back9Stableford = 0;

        for (let i = 0; i < 9; i++) {
          if (playerScores.holes[i]) front9Score += parseInt(playerScores.holes[i]);
          if (playerScores.points[i]) front9Points += parseInt(playerScores.points[i]);
          if (playerScores.stablefordPoints[i] !== '' && playerScores.stablefordPoints[i] !== undefined) {
            front9Stableford += parseInt(playerScores.stablefordPoints[i]);
          }
        }

        for (let i = 9; i < 18; i++) {
          if (playerScores.holes[i]) back9Score += parseInt(playerScores.holes[i]);
          if (playerScores.points[i]) back9Points += parseInt(playerScores.points[i]);
          if (playerScores.stablefordPoints[i] !== '' && playerScores.stablefordPoints[i] !== undefined) {
            back9Stableford += parseInt(playerScores.stablefordPoints[i]);
          }
        }

        const front9El = document.getElementById('front9-score');
        const back9El = document.getElementById('back9-score');
        const totalEl = document.getElementById('total-score');
        const front9PtsEl = document.getElementById('front9-points');
        const back9PtsEl = document.getElementById('back9-points');
        const totalPtsEl = document.getElementById('total-points');
        const front9StablefordEl = document.getElementById('front9-stableford');
        const back9StablefordEl = document.getElementById('back9-stableford');
        const totalStablefordEl = document.getElementById('total-stableford');
        
        if (front9El) front9El.textContent = front9Score || '-';
        if (back9El) back9El.textContent = back9Score || '-';
        if (totalEl) totalEl.textContent = (front9Score + back9Score) || '-';
        if (front9PtsEl) front9PtsEl.textContent = front9Points || '-';
        if (back9PtsEl) back9PtsEl.textContent = back9Points || '-';
        if (totalPtsEl) totalPtsEl.textContent = (front9Points + back9Points) || '-';
        if (front9StablefordEl) front9StablefordEl.textContent = front9Stableford || '-';
        if (back9StablefordEl) back9StablefordEl.textContent = back9Stableford || '-';
        if (totalStablefordEl) totalStablefordEl.textContent = (front9Stableford + back9Stableford) || '-';
      }

      function updateStatus() {
        const playersWithScores = Object.values(scores).filter(data => 
          data.holes && data.holes.some(s => s !== '')
        ).length;
        
        document.getElementById('status-text').textContent = 
          `${admittedPlayers.length} players | ${playersWithScores} with scores entered`;
      }

      function saveScores() {
        // If in match-score mode, save match scores instead
        if (scoreEntryMethod === 'match-score') {
          saveCurrentMatchScores();
          alert('Match scores saved!');
          return;
        }
        
        const scoresData = getScoresData();
        scoresData[currentRoundId] = scores;
        saveScoresData(scoresData);
        
        // Auto-unpublish draw list when results are saved
        unpublishDrawListForRound(currentRoundId);
        
        // Refresh player list to update positions
        renderPlayersList();
        
        // Focus search bar for next player
        const searchInput = document.getElementById('player-search');
        if (searchInput) {
          searchInput.focus();
          searchInput.select();
        }
      }
      
      function unpublishDrawListForRound(roundId) {
        // Unpublish the draw list when results are entered
        try {
          const tournaments = getTournaments();
          const tournament = tournaments.find(t => t.tournamentId === tournamentIdParam);
          
          if (tournament && tournament.published) {
            // Check if this is the published round
            const publishedRoundId = tournament.meta?.roundIds?.[0] || `${tournamentIdParam}-1`;
            if (roundId === publishedRoundId) {
              tournament.published = false;
              delete tournament.publishedHTML;
              delete tournament.publishedDate;
              
              const idx = tournaments.findIndex(t => t.tournamentId === tournamentIdParam);
              if (idx !== -1) {
                tournaments[idx] = tournament;
                saveTournaments(tournaments);
                console.log('‚úì Draw list auto-unpublished (results entered for this round)');
              }
            }
          }
        } catch(e) {
          console.error('Error unpublishing draw list:', e);
        }
      }

      function forceSyncToCloud() {
        if (typeof syncToFirebase === 'undefined') {
          alert('Firebase sync not available. Please refresh the page.');
          return;
        }
        
        // Sync both regular scores and match scores
        const scoresData = getScoresData();
        const matchScoresData = getMatchScoresData();
        
        Promise.all([
          syncToFirebase('scores', scoresData),
          syncToFirebase('matchScores', matchScoresData)
        ])
          .then(() => {
            alert('‚úì Successfully synced all scores to cloud!');
          })
          .catch(e => {
            alert('‚úó Sync failed: ' + e.message);
          });
      }

      // Search functionality
      const searchInput = document.getElementById('player-search');
      
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase().trim();
        highlightedIndex = query ? 0 : -1;
        renderPlayersList();
      });
      
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (highlightedIndex >= 0 && filteredPlayers[highlightedIndex]) {
            selectPlayer(filteredPlayers[highlightedIndex]);
            searchInput.value = '';
            highlightedIndex = -1;
            renderPlayersList();
          }
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (filteredPlayers.length > 0) {
            highlightedIndex = Math.min(highlightedIndex + 1, filteredPlayers.length - 1);
            renderPlayersList();
            // Scroll highlighted row into view
            const rows = document.querySelectorAll('.players-table tbody tr');
            if (rows[highlightedIndex]) {
              rows[highlightedIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (filteredPlayers.length > 0) {
            highlightedIndex = Math.max(highlightedIndex - 1, 0);
            renderPlayersList();
            // Scroll highlighted row into view
            const rows = document.querySelectorAll('.players-table tbody tr');
            if (rows[highlightedIndex]) {
              rows[highlightedIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
          }
        }
      });

      // Setup table header sorting
      function setupTableSorting() {
        document.querySelectorAll('.players-table th[data-sort]').forEach(header => {
          header.addEventListener('click', () => {
            const column = header.getAttribute('data-sort');
            
            // Toggle direction if same column, otherwise default to asc
            if (sortColumn === column) {
              sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
              sortColumn = column;
              sortDirection = 'asc';
            }
            
            // Update sort indicators
            document.querySelectorAll('.players-table th span').forEach(span => {
              span.textContent = '';
            });
            
            const indicator = sortDirection === 'asc' ? '‚ñ≤' : '‚ñº';
            document.getElementById(`sort-${column}`).textContent = indicator;
            
            renderPlayersList();
          });
        });
      }

      // Initialize on load
      init();
      setupTableSorting();
    </script>
  </body>
</html>
