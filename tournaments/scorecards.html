<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Scorecards</title>
    <link rel="stylesheet" href="../styles.css">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>
    <style>
      * { font-family: 'Arial', 'Helvetica', sans-serif; }
      body{padding-top:70px}
      .scorecards-container { max-width: 1200px; margin: 24px auto; padding: 16px; }
      .options-card { background: white; border-radius: 16px; padding: 24px; margin-bottom: 24px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .form-group { margin-bottom: 20px; }
      .form-group label { display: block; font-weight: 600; margin-bottom: 8px; color: #1e293b; }
      .form-group select, .form-group input[type="file"] { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 15px; }
      .logo-preview { margin-top: 12px; display: flex; gap: 12px; flex-wrap: wrap; }
      .logo-preview img { max-width: 100px; max-height: 60px; object-fit: contain; border: 1px solid #e6e9ef; border-radius: 6px; padding: 4px; }
      .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top: 12px; }
      .checkbox-group input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; }
      .checkbox-group label { margin: 0; font-weight: 500; cursor: pointer; }
      .btn-generate { background: linear-gradient(180deg, #0b6efd, #0952cc); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; width: 100%; margin-top: 12px; }
      .btn-generate:hover { opacity: 0.9; }
      
      /* Print Styles */
      @media print {
        @page {
          margin: 8mm;
        }
        
        * {
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        html, body {
          padding: 0 !important;
          margin: 0 !important;
          background: white !important;
          padding-top: 0 !important;
        }
        
        /* Hide non-scorecard elements */
        .navbar, 
        nav,
        header, 
        .print-bar,
        .options-card, 
        .action-buttons, 
        .logo-edit-hint, 
        h1.page-title,
        .cut-line,
        #options-panel,
        .top-nav,
        .btn-back-top {
          display: none !important;
        }
        
        .scorecards-container {
          max-width: none !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        
        #scorecards-output {
          display: block !important;
        }
        
        .scorecard {
          page-break-inside: avoid;
          break-inside: avoid;
          border: 2px solid #000 !important;
          margin: 0 auto 5mm auto !important;
          padding: 12px !important;
          box-shadow: none !important;
        }
        
        /* Logo container for print - clip overflow */
        .scorecard-logo-container {
          width: 100px !important;
          height: 80px !important;
          overflow: hidden !important;
        }
        
        /* Reset logo transform for print - fit within container */
        .scorecard-logo {
          transform: none !important;
          max-width: 100% !important;
          max-height: 100% !important;
          width: auto !important;
          height: auto !important;
          object-fit: contain !important;
        }
        
        /* Reduce gap between header and table */
        .scorecard-top {
          margin-bottom: 6px !important;
          display: block !important;
          position: relative !important;
        }
        
        .scorecard-top-left {
          padding-right: 110px !important;
        }
        
        /* Position title absolutely to center across full width */
        .scorecard-title {
          position: absolute !important;
          left: 0 !important;
          right: 0 !important;
          top: 0 !important;
          text-align: center !important;
          margin: 0 !important;
          padding: 0 !important;
          z-index: 1 !important;
        }
        
        .scorecard-header {
          margin-top: 28px !important;
        }
        
        /* Position logo absolutely in top right */
        .scorecard-logo-container {
          position: absolute !important;
          top: 0 !important;
          right: 0 !important;
          width: 100px !important;
          height: 80px !important;
          overflow: hidden !important;
        }
        
        /* Reset logo transform for print - fit within container */
        .scorecard-logo {
          transform: none !important;
          max-width: 100% !important;
          max-height: 100% !important;
          width: auto !important;
          height: auto !important;
          object-fit: contain !important;
        }
        
        /* Hide editable border on logo */
        .scorecard-logo-container.editable {
          border: none !important;
        }
        
        .scorecard-logo-container.editable::after {
          display: none !important;
        }
        
        /* Include signature inside the card */
        .scorecard-footer {
          margin-top: 8px !important;
          padding-bottom: 3px !important;
        }
        
        /* Hide cut line */
        .cut-line {
          display: none !important;
        }
        
        /* Match play specific print styles */
        .team-separator td {
          background: #000 !important;
          height: 4px !important;
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        .player-score-row.team1,
        .player-score-row.team2 {
          background: #dbeafe !important;
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        .player-score-row .score-entry-cell {
          background: white !important;
        }
        
        .player-score-row .total-cell.score-total {
          background: #bfdbfe !important;
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        .match-footer {
          margin-top: 8px !important;
        }
        
        .match-footer .sig-line {
          width: 120px !important;
        }
        
        .pace-row td {
          font-size: 8px !important;
        }
        
        /* Portrait mode - 2 cards per page */
        @media (orientation: portrait) {
          .scorecard {
            max-height: 135mm;
            font-size: 10px !important;
          }
          
          .scorecard-table {
            font-size: 9px !important;
          }
          
          .scorecard-table th,
          .scorecard-table td {
            padding: 3px 2px !important;
            min-width: 22px !important;
          }
          
          .scorecard-title {
            font-size: 18px !important;
            margin-bottom: 6px !important;
          }
          
          .scorecard-info-left,
          .scorecard-info-center {
            font-size: 11px !important;
          }
          
          .scorecard-footer {
            font-size: 10px !important;
          }
        }
        
        /* Landscape mode - 2 cards per page with wider columns */
        @media (orientation: landscape) {
          .scorecard {
            max-height: 92mm;
            font-size: 9px !important;
          }
          
          .scorecard-table {
            font-size: 9px !important;
          }
          
          .scorecard-table th,
          .scorecard-table td {
            padding: 2px 3px !important;
            min-width: 28px !important;
          }
          
          .scorecard-title {
            font-size: 16px !important;
            margin-bottom: 4px !important;
          }
          
          .scorecard-info-left,
          .scorecard-info-center {
            font-size: 10px !important;
          }
          
          .scorecard-footer {
            font-size: 9px !important;
          }
          
          .scorecard-top {
            margin-bottom: 6px !important;
          }
        }
      }
      
      /* Print bar styles */
      .print-bar {
        display: none;
        background: #1e293b;
        padding: 12px 20px;
        position: fixed;
        top: 70px;
        left: 0;
        right: 0;
        z-index: 100;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      }
      
      .print-bar.visible {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .print-bar-left {
        display: flex;
        align-items: center;
        gap: 16px;
      }
      
      .print-bar .btn-print {
        background: linear-gradient(180deg, #22c55e, #16a34a);
        color: white;
        border: none;
        padding: 10px 24px;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .print-bar .btn-back {
        background: #475569;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        text-decoration: none;
      }
      
      .print-bar .print-info {
        color: #94a3b8;
        font-size: 13px;
      }
      
      /* Scorecard Styling - Stroke Play */
      .scorecard { 
        background: white; 
        border: 3px solid #000; 
        margin-bottom: 24px; 
        padding: 20px; 
        border-radius: 0; 
        font-family: 'Arial', sans-serif;
        font-size: 12px;
        position: relative;
      }
      
      .scorecard-top {
        display: block;
        position: relative;
        margin-bottom: 16px;
      }
      
      .scorecard-top-left {
        display: flex;
        flex-direction: column;
        padding-right: 160px;
      }
      
      .scorecard-title {
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        font-style: italic;
        color: #000;
        margin-bottom: 12px;
      }
      
      .scorecard-header {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 40px;
        align-items: start;
        justify-items: center;
      }
      
      .scorecard-info-center {
        justify-self: center;
      }
      
      .scorecard-logo-container {
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 140px;
        height: 120px;
        background: #fff;
        overflow: hidden;
      }
      
      .scorecard-logo {
        object-fit: contain;
        cursor: move;
        user-select: none;
        max-width: 100%;
        max-height: 100%;
      }
      
      .scorecard-logo-container.editable {
        border: 2px dashed #2196F3;
        cursor: move;
      }
      
      .scorecard-logo-container.editable::after {
        content: 'Drag to move, Scroll to resize';
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: #2196F3;
        white-space: nowrap;
      }
      
      .logo-edit-hint {
        background: #2196F3;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        margin-bottom: 10px;
        font-size: 13px;
        display: none;
      }
      
      .logo-edit-hint.visible {
        display: block;
      }
      
      @media print {
        .logo-edit-hint { display: none !important; }
        .scorecard-logo-container.editable { border: 1px solid #ccc; }
        .scorecard-logo-container.editable::after { display: none; }
        
        /* Print styles for players-hcp-table */
        .players-hcp-table {
          margin: 0 auto;
          border-collapse: collapse;
          font-size: 12px;
        }
        
        .players-hcp-table th {
          font-weight: bold;
          padding: 2px 16px;
          text-align: left;
          border-bottom: 1px solid #999;
        }
        
        .players-hcp-table th:last-child {
          text-align: right;
        }
        
        .players-hcp-table td {
          padding: 2px 16px;
        }
        
        .players-hcp-table td:last-child {
          text-align: right;
          font-weight: 600;
        }
        
        /* Singles/Foursomes need extra space */
        .match-scorecard-new.singles-card .match-table-new,
        .match-scorecard-new.foursomes-card .match-table-new {
          margin-top: 50px;
        }
      }
      
      .scorecard-info-center {
        display: flex;
        flex-direction: column;
        gap: 2px;
        font-size: 14px;
        justify-self: center;
      }
      
      .scorecard-info-center .info-row {
        display: flex;
        gap: 4px;
      }
      
      .scorecard-info-center .label {
        font-weight: 700;
      }
      
      .scorecard-info-center .value {
        color: #000;
        font-weight: 700;
      }
      
      .scorecard-info-left {
        display: flex;
        flex-direction: column;
        gap: 2px;
        font-size: 14px;
      }
      
      .scorecard-info-left .info-row {
        display: flex;
        gap: 4px;
      }
      
      .scorecard-info-left .label {
        font-weight: 700;
        min-width: 60px;
      }
      
      .scorecard-info-left .value {
        color: #000;
        font-weight: 700;
      }
      
      .scorecard-table {
        width: 100%;
        border-collapse: collapse;
        margin: 8px 0;
        font-size: 12px;
        font-weight: 600;
      }
      
      .scorecard-table th {
        background: #e0e0e0;
        color: #000;
        padding: 6px 3px;
        text-align: center;
        font-weight: bold;
        font-size: 13px;
        border: 2px solid #000;
        min-width: 30px;
      }
      
      .scorecard-table th.header-label {
        background: #fff;
        text-align: left;
        padding-left: 8px;
        width: 85px;
        font-size: 12px;
      }
      
      .scorecard-table td {
        padding: 5px 3px;
        text-align: center;
        border: 1.5px solid #000;
        height: 24px;
        font-size: 12px;
        font-weight: 600;
      }
      
      .scorecard-table .row-label {
        text-align: left;
        font-weight: 700;
        background: #fff;
        padding-left: 8px;
        white-space: nowrap;
        font-size: 12px;
      }
      
      .scorecard-table .total-cell {
        background: #d4e8f7;
        font-weight: bold;
        font-size: 13px;
        color: #000;
      }
      
      .scorecard-table .par-row td {
        background: #fff;
        font-size: 13px;
        font-weight: bold;
      }
      
      .scorecard-table .meters-row td {
        background: #fffde7;
        color: #000;
        font-weight: bold;
      }
      
      .scorecard-table .si-row td {
        background: #f8f8f8;
        font-weight: 600;
      }
      
      .scorecard-table .netpar-row td {
        background: #f0f0f0;
        font-weight: 600;
      }
      
      .scorecard-table .player-row td {
        background: #fff;
        height: 32px;
      }
      
      .scorecard-table .empty-row td {
        background: #fff;
        height: 28px;
      }
      
      .scorecard-table .separator-row td {
        background: #000;
        height: 8px;
        padding: 0;
      }
      
      .scorecard-table .marker-row td {
        background: #fff;
        height: 32px;
      }
      
      .scorecard-table .pace-row td {
        background: #fff;
        color: #000;
        font-size: 10px;
        font-weight: 600;
      }
      
      .scorecard-footer {
        margin-top: 16px;
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        padding: 0 10px;
      }
      
      .signature-section {
        display: flex;
        align-items: baseline;
        gap: 10px;
      }
      
      .signature-label {
        font-weight: 700;
        font-size: 13px;
      }
      
      .signature-name {
        color: #c00;
        min-width: 160px;
        border-bottom: 1px solid #000;
        padding-bottom: 2px;
        font-weight: 700;
        font-size: 13px;
      }
      
      .cut-line {
        border-top: 2px dashed #000;
        margin-top: 20px;
      }
      
      /* Match Play Scorecard Styling */
      .match-scorecard { background: white; border: 2px solid #000; margin-bottom: 24px; padding: 16px; border-radius: 12px; font-family: 'Arial', sans-serif; }
      .match-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
      .match-header-left { flex: 1; }
      .match-header-right { text-align: right; }
      .match-players-header { display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; margin: 16px 0; padding: 16px; background: #f0f0f0; border-radius: 8px; align-items: center; }
      .match-player-box { padding: 12px; background: white; border-radius: 8px; border: 2px solid #333; }
      .match-player-box.left { border-left: 5px solid #3b82f6; }
      .match-player-box.right { border-right: 5px solid #ec4899; text-align: right; }
      .match-player-name { font-size: 16px; font-weight: bold; }
      .match-player-details { font-size: 12px; color: #666; margin-top: 4px; }
      .match-vs-box { font-size: 20px; font-weight: bold; color: #666; }
      .match-table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 11px; }
      .match-table th { background: #000; color: white; padding: 6px 3px; text-align: center; font-weight: bold; border: 1px solid #000; }
      .match-table td { padding: 6px 3px; text-align: center; border: 1px solid #666; }
      .match-table .row-label { text-align: left; font-weight: bold; background: #f5f5f5; padding-left: 8px; white-space: nowrap; width: 80px; }
      .match-table .total-cell { background: #e8e8e8; font-weight: bold; }
      .match-table .score-box { height: 30px; background: white; }
      .match-table .player-row-1 { background: #dbeafe; }
      .match-table .player-row-2 { background: #fce7f3; }
      .match-table .status-row { background: #fef9c3; }
      .match-result-section { margin-top: 16px; padding: 12px; background: #f5f5f5; border-radius: 8px; }
      .match-result-label { font-weight: bold; margin-bottom: 8px; }
      .match-result-box { border: 2px solid #333; padding: 12px; background: white; min-height: 40px; border-radius: 4px; }
      .match-signatures { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 16px; font-size: 12px; }
      .match-sig-box { display: flex; flex-direction: column; }
      .match-sig-label { font-weight: bold; margin-bottom: 4px; }
      .match-sig-line { border-bottom: 1.5px solid #000; height: 30px; }
      
      /* NEW Match Play Scorecard Styling (Same layout as stroke play) */
      /* .match-scorecard-new uses same .scorecard base styles */
      /* .match-table-new uses same .scorecard-table base styles */
      
      /* Singles/Foursomes need extra space due to fewer rows - prevent logo overlap */
      .match-scorecard-new.singles-card .match-table-new,
      .match-scorecard-new.foursomes-card .match-table-new {
        margin-top: 50px;
      }
      
      /* Centered players and match HCP table */
      .players-hcp-table {
        margin: 0 auto;
        border-collapse: collapse;
        font-size: 12px;
      }
      
      .players-hcp-table th {
        font-weight: bold;
        padding: 2px 16px;
        text-align: left;
        border-bottom: 1px solid #999;
      }
      
      .players-hcp-table th:last-child {
        text-align: right;
      }
      
      .players-hcp-table td {
        padding: 2px 16px;
      }
      
      .players-hcp-table td:last-child {
        text-align: right;
        font-weight: 600;
      }
      
      /* Team separator - black bar between teams */
      .team-separator td {
        background: #000 !important;
        height: 6px !important;
        padding: 0 !important;
        border: none !important;
      }
      
      /* Player score rows for match play */
      .player-score-row.team1 {
        background: #dbeafe; /* Light blue for Team 1 */
      }
      
      .player-score-row.team2 {
        background: #dbeafe; /* Light blue for Team 2 */
      }
      
      .player-score-row .score-entry-cell {
        background: white;
        height: 28px;
        min-width: 28px;
        position: relative;
      }
      
      .player-score-row .score-entry-cell sup {
        color: #1e40af;
        font-size: 10px;
        position: absolute;
        top: 2px;
        right: 3px;
      }
      
      .player-score-row .total-cell.score-total {
        background: #bfdbfe; /* Slightly darker blue for totals */
      }
      
      .player-score-row .player-name-cell {
        background: white;
        font-weight: normal;
        text-align: left;
        padding-left: 6px;
        white-space: nowrap;
      }
      
      /* Pace of play row styling */
      .pace-row td {
        font-size: 9px;
        color: #666;
        background: #f8fafc;
      }
      
      .pace-row .row-label {
        background: #f1f5f9;
        font-weight: 600;
        font-size: 9px;
      }
      
      /* Match footer signatures */
      .match-footer {
        display: flex;
        justify-content: space-between;
        margin-top: 16px;
        padding-top: 12px;
      }
      
      .match-footer .signature-area {
        display: flex;
        align-items: baseline;
        gap: 8px;
      }
      
      .match-footer .sig-label {
        color: #666;
        font-size: 12px;
        white-space: nowrap;
      }
      
      .match-footer .sig-line {
        width: 150px;
        border-bottom: 1px solid #000;
      }
      
      .scorecard-top { display: grid; grid-template-columns: 1fr auto; gap: 16px; margin-bottom: 12px; align-items: start; }
      .scorecard-info { flex: 1; }
      .scorecard-title { font-size: 26px; font-weight: bold; text-align: center; margin: 0 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px; }
      .scorecard-details { font-size: 13px; line-height: 1.6; }
      .scorecard-details div { margin: 2px 0; }
      .scorecard-logos { display: flex; gap: 8px; align-items: center; }
      .scorecard-logos img { max-width: 80px; max-height: 60px; object-fit: contain; }
      
      .scorecard-table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 11px; }
      .scorecard-table th { background: #000; color: white; padding: 6px 2px; text-align: center; font-weight: bold; border: 1px solid #000; }
      .scorecard-table td { padding: 6px 2px; text-align: center; border: 1px solid #666; line-height: 1.3; }
      .scorecard-table .row-label { text-align: left; font-weight: bold; background: #f5f5f5; padding-left: 8px; white-space: nowrap; }
      .scorecard-table .total-cell { background: #e8e8e8; font-weight: bold; }
      .scorecard-table .score-box { height: 35px; background: white; }
      .scorecard-table .player-row { background: #e3f2fd; height: 40px; }
      .scorecard-table .marker-row { background: white; height: 40px; }
      .scorecard-table .pace-row { background: white; }
      
      /* QR Code Grid Styles */
      .qr-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 20px; padding: 20px; }
      .qr-card { background: white; border: 2px solid #e5e7eb; border-radius: 12px; padding: 16px; text-align: center; box-shadow: 0 2px 8px rgba(0,0,0,0.06); break-inside: avoid; }
      .qr-card canvas { max-width: 140px; height: auto; margin: 0 auto 12px; }
      .qr-card .player-name { font-weight: 700; font-size: 14px; color: #1e293b; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .qr-card .player-details { font-size: 12px; color: #64748b; margin-bottom: 4px; }
      .qr-card .marker-info { font-size: 11px; color: #059669; font-weight: 500; }
      .qr-card .group-info { font-size: 10px; color: #94a3b8; margin-top: 6px; padding-top: 6px; border-top: 1px solid #e5e7eb; }
      .qr-card .copy-link-btn { margin-top: 8px; padding: 6px 12px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 11px; color: #475569; cursor: pointer; display: inline-flex; align-items: center; gap: 4px; transition: all 0.2s; }
      .qr-card .copy-link-btn:hover { background: #e2e8f0; }
      .qr-card .copy-link-btn.copied { background: #d1fae5; border-color: #10b981; color: #065f46; }
      
      @media print {
        .qr-grid { grid-template-columns: repeat(4, 1fr); gap: 12px; }
        .qr-card { padding: 12px; border: 1px solid #000; box-shadow: none; page-break-inside: avoid; }
        .qr-card canvas { max-width: 120px; }
      }
      
      .logos-section { display: flex; justify-content: center; gap: 20px; margin: 12px 0; padding: 8px; }
      .scorecard-logo { max-height: 60px; max-width: 120px; object-fit: contain; }
      
      .player-info-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin: 12px 0; padding: 12px; background: #f9f9f9; border-radius: 8px; border: 1px solid #ddd; }
      .player-info-item { display: flex; flex-direction: column; }
      .player-info-label { font-size: 11px; font-weight: bold; color: #666; margin-bottom: 4px; }
      .player-info-value { font-size: 14px; font-weight: 600; color: #000; }
      
      .scorecard-footer { margin-top: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 40px; font-size: 12px; }
      .signature-box { display: flex; flex-direction: column; }
      .signature-label { font-weight: bold; margin-bottom: 4px; }
      .signature-line { border-bottom: 1.5px solid #000; padding-bottom: 2px; margin-top: 8px; height: 30px; }
    </style>
  </head>
  <body>
    <div class="top-nav">
      <h1>üèÜ Scorecards</h1>
      <a href="index.html" class="btn-back-top">‚Üê Back</a>
    </div>
    <main class="scorecards-container">
      <header>
        <h1>Generate Scorecards</h1>
        <p class="lead" id="tournament-name">Configure and print scorecards</p>
      </header>

      <div class="options-card" id="options-panel">
        <h2 style="margin-top: 0;">Scorecard Options</h2>
        
        <div class="form-group" id="round-select-group">
          <label for="round-select">Select Round:</label>
          <select id="round-select">
            <option value="">-- Select Round --</option>
          </select>
        </div>

        <div class="form-group" id="match-select-group" style="display: none;">
          <label for="match-select">Select Match:</label>
          <select id="match-select">
            <option value="">-- Select Match --</option>
          </select>
        </div>

        <!-- Bracket tournament tee settings -->
        <div id="bracket-tee-settings" style="display: none;">
          <div class="form-group">
            <label for="bracket-course">Course:</label>
            <select id="bracket-course" onchange="populateBracketTees()">
              <option value="">-- Select Course --</option>
            </select>
          </div>
          <div class="form-group">
            <label for="bracket-tee-men">Men's Tee:</label>
            <select id="bracket-tee-men">
              <option value="">-- Select Tee --</option>
            </select>
          </div>
          <div class="form-group">
            <label for="bracket-tee-women">Women's Tee:</label>
            <select id="bracket-tee-women">
              <option value="">-- Select Tee --</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label for="logo-upload">Upload Logo (optional):</label>
          <input type="file" id="logo-upload" accept="image/*" onchange="handleLogoUpload(event)">
          <div class="logo-preview" id="logo-preview"></div>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="digital-scorecards" onchange="toggleDigitalScorecards()">
          <label for="digital-scorecards">üì± Use Digital Scorecards (QR Codes)</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="auto-assign-marker" checked>
          <label for="auto-assign-marker">Auto-assign markers (next player in flight)</label>
          <span id="marker-required-hint" style="display: none; color: #dc2626; font-size: 12px; margin-left: 8px;">(Required for digital scorecards)</span>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-two-tees">
          <label for="show-two-tees">Show meters for two tees</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-par-net">
          <label for="show-par-net">Show Par Net / Pickup</label>
        </div>

        <button class="btn-generate" onclick="generateScorecards()">üìù Generate Scorecards</button>
        <button class="btn-generate" id="btn-generate-qr" style="display: none; background: linear-gradient(180deg, #059669, #047857); margin-top: 8px;" onclick="generateDigitalScorecards()">üì± Generate QR Codes</button>
        <button class="btn-generate" id="btn-show-scorecards" style="display: none; background: linear-gradient(180deg, #8b5cf6, #7c3aed); margin-top: 8px;" onclick="openDigitalScorecardsAdmin()">üîê Manage Digital Scorecards</button>
      </div>

      <div class="print-bar" id="print-bar">
        <div class="print-bar-left">
          <button class="btn-print" onclick="window.print()">üñ®Ô∏è Print Scorecards</button>
          <span class="print-info">2 scorecards per A4 page (Portrait or Landscape)</span>
        </div>
        <div>
          <button class="btn-back" onclick="window.location.reload()">üîÑ Back to Options</button>
        </div>
      </div>

      <div id="scorecards-output"></div>

      <div class="action-buttons" id="action-buttons" style="display: none;">
        <a href="documents.html" id="back-link" class="btn btn-back">Back to Documents</a>
      </div>
    </main>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');
      
      let tournament = null;
      let courseData = null;
      let uploadedLogos = [];
      let logoSettings = {
        scale: 100,
        x: 0,
        y: 0
      };

      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse courses', err);
          return [];
        }
      }

      function getDraws() {
        try {
          const raw = localStorage.getItem('draws');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse draws', err);
          return {};
        }
      }
      
      function getMatchHCPs() {
        try {
          const raw = localStorage.getItem('matchHCPs');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse matchHCPs', err);
          return {};
        }
      }
      
      // ============================================
      // SETTINGS PERSISTENCE
      // ============================================
      
      const SCORECARD_SETTINGS_KEY = 'scorecardSettings';
      
      function getScorecardSettings() {
        try {
          const raw = localStorage.getItem(SCORECARD_SETTINGS_KEY);
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          return {};
        }
      }
      
      function saveScorecardSettings() {
        const settings = {
          [tournamentId]: {
            roundId: document.getElementById('round-select').value,
            digitalScorecards: document.getElementById('digital-scorecards').checked,
            autoAssignMarker: document.getElementById('auto-assign-marker').checked,
            showTwoTees: document.getElementById('show-two-tees').checked,
            showParNet: document.getElementById('show-par-net').checked,
            logoSettings: logoSettings,
            uploadedLogos: uploadedLogos
          }
        };
        
        // Merge with existing settings for other tournaments
        const existingSettings = getScorecardSettings();
        Object.assign(existingSettings, settings);
        localStorage.setItem(SCORECARD_SETTINGS_KEY, JSON.stringify(existingSettings));
        console.log('Scorecard settings saved');
      }
      
      function loadScorecardSettings() {
        const allSettings = getScorecardSettings();
        const settings = allSettings[tournamentId];
        
        if (!settings) return false;
        
        // Apply saved settings
        if (settings.roundId) {
          document.getElementById('round-select').value = settings.roundId;
        }
        if (settings.digitalScorecards !== undefined) {
          document.getElementById('digital-scorecards').checked = settings.digitalScorecards;
          toggleDigitalScorecards(); // Update UI based on checkbox
        }
        if (settings.autoAssignMarker !== undefined) {
          document.getElementById('auto-assign-marker').checked = settings.autoAssignMarker;
        }
        if (settings.showTwoTees !== undefined) {
          document.getElementById('show-two-tees').checked = settings.showTwoTees;
        }
        if (settings.showParNet !== undefined) {
          document.getElementById('show-par-net').checked = settings.showParNet;
        }
        if (settings.logoSettings) {
          logoSettings = settings.logoSettings;
        }
        if (settings.uploadedLogos && settings.uploadedLogos.length > 0) {
          uploadedLogos = settings.uploadedLogos;
          // Show logo preview
          const preview = document.getElementById('logo-preview');
          preview.innerHTML = uploadedLogos.map(src => `<img src="${src}" />`).join('');
        }
        
        console.log('Scorecard settings loaded:', settings);
        return true;
      }
      
      // Add event listeners to save settings on change
      function setupSettingsAutoSave() {
        document.getElementById('round-select').addEventListener('change', saveScorecardSettings);
        document.getElementById('digital-scorecards').addEventListener('change', saveScorecardSettings);
        document.getElementById('auto-assign-marker').addEventListener('change', saveScorecardSettings);
        document.getElementById('show-two-tees').addEventListener('change', saveScorecardSettings);
        document.getElementById('show-par-net').addEventListener('change', saveScorecardSettings);
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse admittedPlayers', err);
          return {};
        }
      }

      function formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
      }

      // Handle logo uploads
      function handleLogoUpload(event) {
        const files = event.target.files;
        uploadedLogos = [];
        const previewDiv = document.getElementById('logo-preview');
        previewDiv.innerHTML = '';
        
        if (files.length === 0) {
          return;
        }
        
        const file = files[0];
        const reader = new FileReader();
        
        reader.onload = function(e) {
          uploadedLogos = [e.target.result];
          
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '80px';
          img.style.maxHeight = '80px';
          img.style.margin = '5px';
          img.style.border = '1px solid #ddd';
          img.style.borderRadius = '4px';
          previewDiv.appendChild(img);
          
          // Reset logo settings
          logoSettings = { scale: 100, x: 0, y: 0 };
          
          // Save settings with logo
          saveScorecardSettings();
        };
        
        reader.readAsDataURL(file);
      }
      
      // Initialize logo drag/resize on first scorecard
      function initLogoInteraction() {
        const firstLogoContainer = document.querySelector('.scorecard-logo-container');
        if (!firstLogoContainer || !uploadedLogos.length) return;
        
        const firstLogo = firstLogoContainer.querySelector('.scorecard-logo');
        if (!firstLogo) return;
        
        // Mark first container as editable
        firstLogoContainer.classList.add('editable');
        
        // Show hint
        const hint = document.createElement('div');
        hint.className = 'logo-edit-hint visible';
        hint.innerHTML = 'üìç Drag the logo on the first card to position it. Use mouse wheel to resize. Changes apply to all cards.';
        document.getElementById('scorecards-output').insertBefore(hint, document.getElementById('scorecards-output').firstChild);
        
        let isDragging = false;
        let startX, startY;
        
        // Drag functionality
        firstLogo.addEventListener('mousedown', (e) => {
          isDragging = true;
          startX = e.clientX - logoSettings.x;
          startY = e.clientY - logoSettings.y;
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          logoSettings.x = e.clientX - startX;
          logoSettings.y = e.clientY - startY;
          // Clamp values
          logoSettings.x = Math.max(-40, Math.min(40, logoSettings.x));
          logoSettings.y = Math.max(-40, Math.min(40, logoSettings.y));
          applyLogoSettingsToAll();
        });
        
        document.addEventListener('mouseup', () => {
          isDragging = false;
        });
        
        // Scroll to resize
        firstLogoContainer.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -5 : 5;
          logoSettings.scale = Math.max(30, Math.min(200, logoSettings.scale + delta));
          applyLogoSettingsToAll();
        });
      }
      
      function applyLogoSettingsToAll() {
        const allLogos = document.querySelectorAll('.scorecard-logo');
        allLogos.forEach(logo => {
          logo.style.transform = `translate(${logoSettings.x}px, ${logoSettings.y}px) scale(${logoSettings.scale / 100})`;
        });
      }

      function init() {
        const tournaments = getTournaments();
        tournament = tournaments.find(t => t.tournamentId === tournamentId);

        if (!tournament) {
          alert('Tournament not found.');
          window.location.href = 'index.html';
          return;
        }

        document.getElementById('tournament-name').textContent = `Scorecards for ${tournament.name}`;
        document.getElementById('back-link').href = `documents.html?tournamentId=${tournamentId}`;

        console.log('Tournament data:', tournament);

        // Check if this is a bracket tournament
        const isBracketTournament = tournament.type && tournament.type.includes('Bracket');
        
        if (isBracketTournament) {
          // Show match selector, hide round selector
          document.getElementById('round-select-group').style.display = 'none';
          document.getElementById('match-select-group').style.display = 'block';
          document.getElementById('bracket-tee-settings').style.display = 'block';
          populateMatchSelector(tournament);
          populateBracketCourseSelector();
        } else {
          // Show round selector, hide match selector (default)
          document.getElementById('round-select-group').style.display = 'block';
          document.getElementById('match-select-group').style.display = 'none';
          document.getElementById('bracket-tee-settings').style.display = 'none';
          populateRoundSelector(tournament);
        }
        
        // Setup auto-save for settings
        setupSettingsAutoSave();
      }
      
      // Populate bracket course selector
      function populateBracketCourseSelector() {
        const courseSelect = document.getElementById('bracket-course');
        courseSelect.innerHTML = '<option value="">-- Select Course --</option>';
        
        const courses = getCourses();
        courses.forEach(course => {
          const option = document.createElement('option');
          option.value = course.courseId;
          option.textContent = course.fullName || course.name;
          courseSelect.appendChild(option);
        });
        
        // Pre-select the tournament's course if set
        if (tournament.course) {
          courseSelect.value = tournament.course;
          populateBracketTees();
        }
      }
      
      // Populate bracket tee selectors based on selected course
      function populateBracketTees() {
        const courseId = document.getElementById('bracket-course').value;
        const menTeeSelect = document.getElementById('bracket-tee-men');
        const womenTeeSelect = document.getElementById('bracket-tee-women');
        
        menTeeSelect.innerHTML = '<option value="">-- Select Tee --</option>';
        womenTeeSelect.innerHTML = '<option value="">-- Select Tee --</option>';
        
        if (!courseId) return;
        
        const courses = getCourses();
        const course = courses.find(c => c.courseId === courseId);
        if (!course || !course.tees || !course.genders) return;
        
        // Populate tee options based on gender
        course.tees.forEach((teeName, index) => {
          const gender = course.genders[index];
          const teeValue = `${courseId}||${index}`;
          
          // M = Men only, F = Women only, B = Both
          if (gender === 'M' || gender === 'B') {
            const option = document.createElement('option');
            option.value = teeValue;
            option.textContent = teeName;
            menTeeSelect.appendChild(option);
          }
          
          if (gender === 'F' || gender === 'B') {
            const option = document.createElement('option');
            option.value = teeValue;
            option.textContent = teeName;
            womenTeeSelect.appendChild(option);
          }
        });
      }
      
      // Populate match selector for bracket tournaments
      function populateMatchSelector(tournament) {
        const matchSelect = document.getElementById('match-select');
        matchSelect.innerHTML = '<option value="">-- Select Match --</option>';
        
        const bracketData = tournament.bracketData;
        if (!bracketData) {
          console.warn('No bracket data found');
          return;
        }
        
        // Helper to get player name
        function getPlayerName(player) {
          if (!player) return null;
          const name = `${player.firstName || ''} ${player.lastName || ''}`.trim();
          return name || player.name || null;
        }
        
        // Process pre-qual matches (only if both players are defined and no winner yet)
        if (bracketData.preQualMatches && bracketData.preQualMatches.length > 0) {
          bracketData.preQualMatches.forEach((match, idx) => {
            const player1Name = getPlayerName(match.player1);
            const player2Name = getPlayerName(match.player2);
            
            // Only show if both players exist and no winner yet
            if (player1Name && player2Name && !match.winner) {
              const option = document.createElement('option');
              option.value = `prequal-${idx}`;
              option.textContent = `${player1Name} VS ${player2Name}`;
              matchSelect.appendChild(option);
            }
          });
        }
        
        // Process main bracket rounds
        if (bracketData.mainBracket && bracketData.mainBracket.length > 0) {
          bracketData.mainBracket.forEach((round, roundIdx) => {
            if (round.matches) {
              round.matches.forEach((match, matchIdx) => {
                const player1Name = getPlayerName(match.player1);
                const player2Name = getPlayerName(match.player2);
                
                // Only show if both players exist and no winner yet
                if (player1Name && player2Name && !match.winner) {
                  const option = document.createElement('option');
                  option.value = `round-${roundIdx}-${matchIdx}`;
                  option.textContent = `${player1Name} VS ${player2Name}`;
                  matchSelect.appendChild(option);
                }
              });
            }
          });
        }
      }
      
      // Populate round selector for stroke play tournaments
      function populateRoundSelector(tournament) {
        // Populate round selector
        const roundSelect = document.getElementById('round-select');
        
        // Try to get round IDs from different sources
        let roundIds = tournament.meta?.roundIds;
        
        // Fallback: check if draws exist and use those round IDs
        if (!roundIds || roundIds.length === 0) {
          const draws = getDraws();
          const drawKeys = Object.keys(draws).filter(key => key.startsWith(tournament.tournamentId));
          if (drawKeys.length > 0) {
            roundIds = drawKeys;
          }
        }
        
        // Final fallback: create a default round ID
        if (!roundIds || roundIds.length === 0) {
          roundIds = [tournament.tournamentId + '-1'];
        }

        const roundsData = tournament.meta?.roundsData || [];

        console.log('Round IDs:', roundIds);

        roundIds.forEach((rid, idx) => {
          const option = document.createElement('option');
          option.value = rid;
          
          if (roundsData[idx]) {
            const roundDate = roundsData[idx].date ? formatDate(roundsData[idx].date) : '';
            option.textContent = `Round ${idx + 1}${roundDate ? ' - ' + roundDate : ''}`;
          } else {
            option.textContent = `Round ${idx + 1}`;
          }
          
          roundSelect.appendChild(option);
        });
        
        // Try to load saved settings first
        const settingsLoaded = loadScorecardSettings();
        
        // If no saved settings, auto-select round
        if (!settingsLoaded || !document.getElementById('round-select').value) {
          autoSelectRound(roundIds, roundsData);
        }
      }
      
      // Auto-select round based on tournament configuration
      function autoSelectRound(roundIds, roundsData) {
        const roundSelect = document.getElementById('round-select');
        
        // If only one round, select it automatically
        if (roundIds.length === 1) {
          roundSelect.value = roundIds[0];
          console.log('Auto-selected single round:', roundIds[0]);
          return;
        }
        
        // For multi-round tournaments, find the round for today's date
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0]; // YYYY-MM-DD format
        
        let selectedRoundIndex = -1;
        
        for (let i = 0; i < roundsData.length; i++) {
          const roundDate = roundsData[i]?.date;
          if (roundDate) {
            // Normalize date format for comparison
            const normalizedRoundDate = normalizeDate(roundDate);
            if (normalizedRoundDate === todayStr) {
              selectedRoundIndex = i;
              break;
            }
          }
        }
        
        // If no round matches today, select the first round
        if (selectedRoundIndex === -1) {
          selectedRoundIndex = 0;
        }
        
        if (roundIds[selectedRoundIndex]) {
          roundSelect.value = roundIds[selectedRoundIndex];
          console.log('Auto-selected round for today:', roundIds[selectedRoundIndex]);
        }
      }
      
      // Normalize date to YYYY-MM-DD format
      function normalizeDate(dateStr) {
        if (!dateStr) return '';
        
        // If already in YYYY-MM-DD format
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
          return dateStr;
        }
        
        // Try to parse and format
        try {
          const date = new Date(dateStr);
          if (!isNaN(date.getTime())) {
            return date.toISOString().split('T')[0];
          }
        } catch (e) {}
        
        return dateStr;
      }

      // Generate scorecards for bracket match play
      async function generateBracketMatchScorecards(matchId, autoAssignMarker, showTwoTees, showParNet) {
        // Get selected course and tees from the form
        const selectedCourseId = document.getElementById('bracket-course').value;
        const selectedTeeMen = document.getElementById('bracket-tee-men').value;
        const selectedTeeWomen = document.getElementById('bracket-tee-women').value;
        
        if (!selectedCourseId) {
          alert('Please select a course');
          return;
        }
        
        if (!selectedTeeMen && !selectedTeeWomen) {
          alert('Please select at least one tee');
          return;
        }
        
        // Get course data
        const courses = getCourses();
        const courseId = selectedCourseId;

        courseData = courses.find(c => c.courseId === courseId);

        if (!courseData || !courseData.pars) {
          alert(`Course data not available (Course ID: ${courseId}). Please ensure the course is added in the Courses section.`);
          return;
        }

        // Fetch current player data from Firebase (single source of truth)
        // For bracket tournaments, matches can happen months after admission,
        // so we need the current HCP, not the HCP at time of admission
        let allPlayers = [];
        try {
          const snapshot = await db.ref('players').once('value');
          const playersData = snapshot.val();
          if (playersData) {
            allPlayers = Array.isArray(playersData) ? playersData : Object.values(playersData);
          }
        } catch (err) {
          console.error('Failed to fetch players from Firebase', err);
        }
        
        const playersByReg = {};
        const playersById = {};
        allPlayers.forEach(p => { 
          if (p && p.reg) playersByReg[p.reg] = p;
          if (p && p.id) playersById[p.id] = p;
        });

        // Parse matchId to get the match
        const bracketData = tournament.bracketData;
        let match = null;
        
        if (matchId.startsWith('prequal-')) {
          const idx = parseInt(matchId.split('-')[1]);
          match = bracketData.preQualMatches[idx];
        } else if (matchId.startsWith('round-')) {
          const parts = matchId.split('-');
          const roundIdx = parseInt(parts[1]);
          const matchIdx = parseInt(parts[2]);
          match = bracketData.mainBracket[roundIdx].matches[matchIdx];
        }
        
        if (!match || !match.player1 || !match.player2) {
          alert('Invalid match selected');
          return;
        }
        
        // Helper to extract player data - use current player database for up-to-date HCP
        function extractPlayerData(playerData) {
          let playerId = null;
          let playerReg = null;
          
          // Extract ID and reg from player data
          if (playerData && typeof playerData === 'object') {
            playerId = playerData.id;
            playerReg = playerData.reg;
          } else if (typeof playerData === 'string') {
            playerId = playerData;
          }
          
          // First try to find in players database (has most current HCP)
          if (playerReg && playersByReg[playerReg]) {
            // Merge bracket data with current player data (current HCP takes priority)
            const currentPlayer = playersByReg[playerReg];
            if (playerData && typeof playerData === 'object') {
              return { ...playerData, ...currentPlayer };
            }
            return currentPlayer;
          }
          if (playerId && playersById[playerId]) {
            const currentPlayer = playersById[playerId];
            if (playerData && typeof playerData === 'object') {
              return { ...playerData, ...currentPlayer };
            }
            return currentPlayer;
          }
          
          // Fall back to bracket player data (may have outdated HCP)
          if (playerData && typeof playerData === 'object' && playerData.firstName) {
            return playerData;
          }
          
          return { firstName: 'Unknown', lastName: 'Player' };
        }
        
        const player1 = extractPlayerData(match.player1);
        const player2 = extractPlayerData(match.player2);
        
        // Calculate PHCP for bracket tournament players using selected tees
        function calculateBracketPhcp(player) {
          const playerHcp = parseFloat(player.hcp);
          if (isNaN(playerHcp)) return null;
          
          // Determine which tee to use based on player gender
          const playerGender = (player.gender || '').toLowerCase();
          let teeValue = '';
          if (playerGender === 'female' || playerGender === 'f') {
            teeValue = selectedTeeWomen || selectedTeeMen; // Fallback to men's tee if women's not set
          } else {
            teeValue = selectedTeeMen || selectedTeeWomen; // Fallback to women's tee if men's not set
          }
          
          if (!teeValue || !teeValue.includes('||')) {
            return Math.round(playerHcp); // Return raw HCP if no tee selected
          }
          
          const [cId, teeIndexStr] = teeValue.split('||');
          const teeIndex = parseInt(teeIndexStr, 10);
          
          const course = courses.find(c => c.courseId === cId);
          if (!course || !course.teeData || !course.teeData[teeIndex]) {
            return Math.round(playerHcp);
          }
          
          const teeData = course.teeData[teeIndex];
          const teeGender = course.genders?.[teeIndex];
          
          let slope, rating;
          if (teeGender === 'B' && teeData.ratings) {
            if (playerGender === 'male' || playerGender === 'm') {
              slope = teeData.ratings.men?.slope18;
              rating = teeData.ratings.men?.rating18;
            } else {
              slope = teeData.ratings.women?.slope18;
              rating = teeData.ratings.women?.rating18;
            }
          } else {
            slope = teeData.slope18 || teeData.slope;
            rating = teeData.rating18 || teeData.rating;
          }
          
          // Calculate total par
          let par = 0;
          if (course.pars && Array.isArray(course.pars)) {
            par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
          }
          
          if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
            return Math.round(playerHcp);
          }
          
          // Get HCP allowance from tournament settings (default 100%)
          const hcpAllowance = parseFloat(tournament.meta?.hcpAllow || 100) / 100;
          
          // PHCP formula: (HCP √ó (Slope / 113) + (Rating - Par)) √ó Allowance
          const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
          return Math.round(playingHcp);
        }
        
        // Calculate PHCP for both players
        const p1Hcp = parseFloat(player1.hcp) || 0;
        const p2Hcp = parseFloat(player2.hcp) || 0;
        const p1Phcp = calculateBracketPhcp(player1);
        const p2Phcp = calculateBracketPhcp(player2);
        
        // Calculate Match HCP (difference from lowest PHCP)
        let p1MatchHcp = 0, p2MatchHcp = 0;
        if (p1Phcp !== null && p2Phcp !== null) {
          const lowestPhcp = Math.min(p1Phcp, p2Phcp);
          p1MatchHcp = p1Phcp - lowestPhcp;
          p2MatchHcp = p2Phcp - lowestPhcp;
        }
        
        // Build custom scorecard HTML for bracket match
        const pars = courseData.pars || [];
        const strokeIndexes = courseData.strokeIndexes || Array(18).fill('-');
        const courseName = courseData.fullName || courseData.name || 'Golf Course';
        
        // Calculate par totals
        let front9Par = 0, back9Par = 0;
        for (let i = 0; i < 9 && i < pars.length; i++) front9Par += pars[i];
        for (let i = 9; i < 18 && i < pars.length; i++) back9Par += pars[i];
        const totalPar = front9Par + back9Par;
        
        // Format player name as "FirstName LastName"
        function formatFullName(player) {
          return `${player.firstName || ''} ${player.lastName || ''}`.trim() || 'Unknown';
        }
        
        // Format player name as "FirstName L."
        function formatShortName(player) {
          const firstName = player.firstName || player.name || 'Unknown';
          const lastName = player.lastName || '';
          if (lastName) {
            return `${firstName} ${lastName.charAt(0).toUpperCase()}.`;
          }
          return firstName;
        }
        
        // Calculate stroke allocation based on match HCP
        function calculateStrokeAllocation(matchHCP) {
          const allocation = Array(18).fill(0);
          if (matchHCP > 0) {
            for (let stroke = 1; stroke <= matchHCP; stroke++) {
              for (let hole = 0; hole < 18; hole++) {
                const si = parseInt(strokeIndexes[hole]) || 99;
                const targetSI = stroke <= 18 ? stroke : stroke - 18;
                if (si === targetSI) {
                  allocation[hole]++;
                  break;
                }
              }
            }
          }
          return allocation;
        }
        
        const p1Allocation = calculateStrokeAllocation(p1MatchHcp);
        const p2Allocation = calculateStrokeAllocation(p2MatchHcp);
        
        // Build HTML
        let html = `
          <div class="scorecard match-scorecard-new singles-card">
            <div class="scorecard-top">
              <div class="scorecard-top-left">
                <div class="scorecard-title">${tournament.name}</div>
                
                <div class="scorecard-header">
                  <div class="scorecard-info-left">
                    <div class="info-row"><span class="label">Date</span><span class="value">:</span></div>
                    <div class="info-row"><span class="label">Round</span><span class="value">:</span></div>
                    <div class="info-row"><span class="label">Course</span><span class="value">: ${courseName}</span></div>
                  </div>
                  <div class="scorecard-info-center">
                    <table class="players-hcp-table">
                      <thead>
                        <tr><th>Players</th><th>HCP</th><th>PHCP</th><th>Match HCP</th></tr>
                      </thead>
                      <tbody>
                        <tr><td>${formatFullName(player1)}</td><td>${p1Hcp}</td><td>${p1Phcp !== null ? p1Phcp : '-'}</td><td><strong>${p1MatchHcp}</strong></td></tr>
                        <tr><td>${formatFullName(player2)}</td><td>${p2Hcp}</td><td>${p2Phcp !== null ? p2Phcp : '-'}</td><td><strong>${p2MatchHcp}</strong></td></tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
              <div class="scorecard-logo-container">
                ${uploadedLogos.length > 0 ? `<img src="${uploadedLogos[0]}" alt="Logo" class="scorecard-logo" style="transform: translate(${logoSettings.x}px, ${logoSettings.y}px) scale(${logoSettings.scale / 100});">` : ''}
              </div>
            </div>
            
            <table class="scorecard-table match-table-new">
              <thead>
                <tr>
                  <th class="header-label">Hole:</th>`;
        
        // Hole numbers
        for (let i = 1; i <= 9; i++) html += `<th>${i}</th>`;
        html += `<th class="total-cell">Front</th>`;
        for (let i = 10; i <= 18; i++) html += `<th>${i}</th>`;
        html += `<th class="total-cell">Back</th><th class="total-cell">Total</th></tr></thead><tbody>`;
        
        // PAR row
        html += `<tr class="par-row"><td class="row-label">PAR</td>`;
        for (let i = 0; i < 9; i++) html += `<td>${pars[i] || ''}</td>`;
        html += `<td class="total-cell">${front9Par}</td>`;
        for (let i = 9; i < 18; i++) html += `<td>${pars[i] || ''}</td>`;
        html += `<td class="total-cell">${back9Par}</td><td class="total-cell">${totalPar}</td></tr>`;
        
        // Stroke Index row
        html += `<tr class="si-row"><td class="row-label">Str. Indx</td>`;
        for (let i = 0; i < 9; i++) html += `<td>${strokeIndexes[i] || ''}</td>`;
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) html += `<td>${strokeIndexes[i] || ''}</td>`;
        html += `<td class="total-cell"></td><td class="total-cell"></td></tr>`;
        
        // Player 1 score row
        html += `<tr class="player-score-row team1"><td class="row-label player-name-cell">${formatShortName(player1)}</td>`;
        for (let i = 0; i < 9; i++) {
          const dots = p1Allocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(p1Allocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        for (let i = 9; i < 18; i++) {
          const dots = p1Allocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(p1Allocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td><td class="total-cell score-total"></td></tr>`;
        
        // Separator
        html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
        
        // Player 2 score row
        html += `<tr class="player-score-row team2"><td class="row-label player-name-cell">${formatShortName(player2)}</td>`;
        for (let i = 0; i < 9; i++) {
          const dots = p2Allocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(p2Allocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        for (let i = 9; i < 18; i++) {
          const dots = p2Allocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(p2Allocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td><td class="total-cell score-total"></td></tr>`;
        
        // Separator before pace of play
        html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
        
        // Pace of Play row
        html += `<tr class="pace-row"><td class="row-label">Pace of Play</td>`;
        for (let i = 0; i < 9; i++) html += `<td></td>`;
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) html += `<td></td>`;
        html += `<td class="total-cell"></td><td class="total-cell"></td></tr>`;
        
        html += `</tbody></table>`;
        
        // Signature section
        html += `
          <div class="scorecard-footer match-footer">
            <div class="signature-area">
              <span class="sig-label">Signature  ${formatShortName(player1)}</span>
              <span class="sig-line"></span>
            </div>
            <div class="signature-area" style="margin-left: auto;">
              <span class="sig-label">Signature  ${formatShortName(player2)}</span>
              <span class="sig-line"></span>
            </div>
          </div>
        </div>`;
        
        // Display the scorecard
        const output = document.getElementById('scorecards-output');
        output.innerHTML = html;
        
        // Show print bar, hide options
        document.getElementById('options-panel').style.display = 'none';
        document.getElementById('print-bar').style.display = 'flex';
      }

      async function generateScorecards() {
        const isBracketTournament = tournament.type && tournament.type.includes('Bracket');
        
        // For bracket tournaments, use match-select; for others, use round-select
        let roundId, matchId;
        if (isBracketTournament) {
          matchId = document.getElementById('match-select').value;
          if (!matchId) {
            alert('Please select a match');
            return;
          }
        } else {
          roundId = document.getElementById('round-select').value;
          if (!roundId) {
            alert('Please select a round');
            return;
          }
        }
        
        const autoAssignMarker = document.getElementById('auto-assign-marker').checked;
        const showTwoTees = document.getElementById('show-two-tees').checked;
        const showParNet = document.getElementById('show-par-net').checked;

        // For bracket tournaments, handle differently
        if (isBracketTournament) {
          await generateBracketMatchScorecards(matchId, autoAssignMarker, showTwoTees, showParNet);
          return;
        }

        // Load course data for this round (stroke play path)
        const courses = getCourses();
        const roundIndex = tournament.meta?.roundIds?.indexOf(roundId) || 0;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        
        // Detect match type
        const matchType = (roundData?.matchType || '').toLowerCase();
        const isMatchPlay = matchType === 'singles' || matchType === 'fourball' || matchType === 'foursomes';
        
        // Try to get course from round data, or fallback to tournament-level course
        let courseId = roundData?.course || tournament.courseId || tournament.course;
        
        if (!courseId) {
          alert('Course not configured for this tournament/round');
          return;
        }

        courseData = courses.find(c => c.courseId === courseId);

        if (!courseData || !courseData.pars) {
          alert(`Course data not available (Course ID: ${courseId}). Please ensure the course is added in the Courses section.`);
          return;
        }

        // Get draws for this round
        const draws = getDraws();
        const roundDraw = draws[roundId];

        // Get round date
        const roundDate = tournament.meta?.roundsData?.[roundIndex]?.date || '';

        // Generate scorecards based on type
        let html = '';
        
        if (isMatchPlay && roundDraw && roundDraw.groups) {
          // MATCH PLAY: Generate match scorecards from draw groups
          // First, merge fresh admitted player data into groups (same as draw_list.html)
          const admittedPlayers = getAdmittedPlayers()[roundId] || [];
          const admittedByReg = {};
          admittedPlayers.forEach(p => { if (p.reg) admittedByReg[p.reg] = p; });
          
          const enrichedGroups = roundDraw.groups.map(group => {
            const updatedPlayers = (group.players || []).map(player => {
              const freshPlayer = admittedByReg[player.reg];
              if (freshPlayer) {
                return { ...player, ...freshPlayer };
              }
              return player;
            });
            return { ...group, players: updatedPlayers };
          });
          
          html = generateMatchPlayScorecards(enrichedGroups, matchType, roundDate);
        } else {
          // STROKE PLAY: Generate individual scorecards following draw order
          const groups = roundDraw?.groups || roundDraw || [];
          
          if (!groups || groups.length === 0) {
            alert('No draw found for this round. Please create a draw first.');
            return;
          }

          // Generate scorecards in draw order: Group 1 players, then Group 2, etc.
          groups.forEach((group, groupIndex) => {
            const groupPlayers = group.players || [];
            const groupTime = group.time || group.teeTime || '';
            
            groupPlayers.forEach((player, playerIndex) => {
              let marker = null;
              
              if (autoAssignMarker && groupPlayers.length > 1) {
                // Assign next player as marker (wrap around)
                const markerIndex = (playerIndex + 1) % groupPlayers.length;
                marker = groupPlayers[markerIndex];
              }

              html += generateScorecardHTML(player, marker, roundDate, roundIndex, groupTime, showTwoTees, showParNet, autoAssignMarker);
            });
          });
          
          if (!html) {
            alert('No players found in the draw.');
            return;
          }
        }

        document.getElementById('scorecards-output').innerHTML = html;
        document.getElementById('options-panel').style.display = 'none';
        document.getElementById('print-bar').classList.add('visible');
        document.getElementById('action-buttons').style.display = 'flex';
        
        // Initialize logo interaction if logo was uploaded
        if (uploadedLogos.length > 0) {
          initLogoInteraction();
        }
      }

      // Generate match play scorecards
      function generateMatchPlayScorecards(groups, matchType, roundDate) {
        let html = '';
        
        groups.forEach((group, groupIndex) => {
          const players = group.players || [];
          if (players.length < 2) return;
          
          if (matchType === 'singles') {
            // Singles: Create separate match cards for 1v2, 3v4
            const numMatches = Math.floor(players.length / 2);
            
            for (let i = 0; i < numMatches; i++) {
              const player1 = players[i * 2];
              const player2 = players[i * 2 + 1];
              
              if (!player1 || !player2) continue;
              
              html += generateMatchScorecardHTML(
                [player1], 
                [player2], 
                matchType, 
                roundDate, 
                group.time || group.teeTime,
                groupIndex,
                i
              );
            }
          } else {
            // Fourball/Foursomes: Pair vs Pair
            const leftPlayers = players.slice(0, 2);
            const rightPlayers = players.slice(2, 4);
            
            if (leftPlayers.length >= 1 && rightPlayers.length >= 1) {
              html += generateMatchScorecardHTML(
                leftPlayers, 
                rightPlayers, 
                matchType, 
                roundDate, 
                group.time || group.teeTime,
                groupIndex,
                0
              );
            }
          }
        });
        
        return html;
      }

      // Get player tee info for match play (including tee name)
      function getPlayerTeeInfoForMatch(player, roundData) {
        const defaultInfo = {
          teeName: 'N/A',
          distances: Array(18).fill(0),
          courseRating: '-',
          slopeRating: '-'
        };
        
        const courses = getCourses();
        const courseId = roundData?.course || tournament.courseId;
        const course = courses.find(c => c.courseId === courseId);
        if (!course) return defaultInfo;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeIndex = -1;
        
        // Check if player has an assigned tee
        if (player.tee) {
          if (player.tee.includes('||')) {
            const [cId, teeIdxStr] = player.tee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          } else if (course.teeIds) {
            teeIndex = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
          }
        }
        
        // If no assigned tee, use default from round settings
        if (teeIndex === -1) {
          let defaultTee = '';
          if (playerGender === 'male' || playerGender === 'm') {
            defaultTee = roundData?.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            defaultTee = roundData?.teeWomen || '';
          }
          
          if (defaultTee && defaultTee.includes('||')) {
            const [cId, teeIdxStr] = defaultTee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          }
        }
        
        if (teeIndex === -1 || !course.teeData || !course.teeData[teeIndex]) {
          return defaultInfo;
        }
        
        const teeName = course.tees?.[teeIndex] || 'N/A';
        const teeData = course.teeData[teeIndex];
        const distances = teeData.lengths || Array(18).fill(0);
        
        // Get rating/slope based on player gender
        let courseRating, slopeRating;
        const gender = course.genders?.[teeIndex];
        
        if (gender === 'B' && teeData.ratings) {
          if (playerGender === 'male' || playerGender === 'm') {
            courseRating = teeData.ratings.men?.rating18;
            slopeRating = teeData.ratings.men?.slope18;
          } else {
            courseRating = teeData.ratings.women?.rating18;
            slopeRating = teeData.ratings.women?.slope18;
          }
        } else {
          courseRating = teeData.rating18 || teeData.rating;
          slopeRating = teeData.slope18 || teeData.slope;
        }
        
        return {
          teeName,
          distances,
          courseRating: courseRating || '-',
          slopeRating: slopeRating || '-'
        };
      }

      // Get tee data for PHCP calculation (slope, rating, par)
      function getPlayerTeeDataForCalc(player, roundData) {
        const courses = getCourses();
        const courseId = roundData?.course || tournament.courseId;
        const course = courses.find(c => c.courseId === courseId);
        if (!course) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeIndex = -1;
        
        // Check if player has an assigned tee
        if (player.tee) {
          if (player.tee.includes('||')) {
            const [cId, teeIdxStr] = player.tee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          } else if (course.teeIds) {
            teeIndex = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
          }
        }
        
        // If no assigned tee, use default from round settings
        if (teeIndex === -1) {
          let defaultTee = '';
          if (playerGender === 'male' || playerGender === 'm') {
            defaultTee = roundData?.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            defaultTee = roundData?.teeWomen || '';
          }
          
          if (defaultTee && defaultTee.includes('||')) {
            const [cId, teeIdxStr] = defaultTee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          }
        }
        
        if (teeIndex === -1 || !course.teeData || !course.teeData[teeIndex]) {
          return null;
        }
        
        const teeData = course.teeData[teeIndex];
        const gender = course.genders?.[teeIndex];
        
        let slope, rating;
        if (gender === 'B' && teeData.ratings) {
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        // Calculate total par
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        return { slope, rating, par };
      }

      // Generate a single match scorecard HTML (Singles, Fourball, Foursomes)
      function generateMatchScorecardHTML(leftPlayers, rightPlayers, matchType, roundDate, teeTime, groupIndex, subMatchIndex) {
        const pars = courseData.pars || [];
        const strokeIndexes = courseData.strokeIndexes || Array(18).fill('-');
        const roundIndex = tournament.meta?.roundIds?.indexOf(document.getElementById('round-select').value) || 0;
        const roundId = document.getElementById('round-select').value;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        
        // Get course info
        const courseName = courseData.fullName || courseData.name || 'Golf Course';
        
        // Calculate par totals
        let front9Par = 0, back9Par = 0;
        for (let i = 0; i < 9 && i < pars.length; i++) front9Par += pars[i];
        for (let i = 9; i < 18 && i < pars.length; i++) back9Par += pars[i];
        const totalPar = front9Par + back9Par;

        // Get all players in the match
        const allPlayers = [...leftPlayers, ...rightPlayers];

        // Calculate pace of play times
        const paceTimes = calculatePaceTimes(teeTime);

        // Get stored match HCPs (calculated when draw was saved)
        const storedMatchHCPs = getMatchHCPs()[roundId] || {};
        
        // Helper to get consistent player key (prioritize reg since that's what draw.html uses to save)
        function getPlayerKey(player) {
          return player.reg || player.odaId || player.odaid || player.playerId || `${player.firstName}_${player.lastName}`;
        }
        
        // Check if we have stored match HCPs for these players
        let matchHCPs = {};
        let hasStoredHCPs = false;
        
        allPlayers.forEach(p => {
          const pKey = getPlayerKey(p);
          if (storedMatchHCPs[pKey] !== undefined) {
            matchHCPs[pKey] = storedMatchHCPs[pKey];
            hasStoredHCPs = true;
          }
        });
        
        // If no stored HCPs, calculate them (fallback)
        let team1MatchHCP = 0, team2MatchHCP = 0;
        
        // Helper to parse PHCP (handle '+' prefix for plus handicaps)
        function parsePhcp(phcp) {
          if (phcp === '-' || phcp === undefined || phcp === null) return NaN;
          if (typeof phcp === 'string' && phcp.startsWith('+')) {
            return -parseInt(phcp.substring(1));
          }
          return parseInt(phcp);
        }

        // Calculate playing HCP for a player (same logic as draw_list.html)
        function calculatePlayingHcpForPlayer(player) {
          const playerHcp = parseFloat(player.hcp);
          if (isNaN(playerHcp)) return NaN;
          
          const teeData = getPlayerTeeDataForCalc(player, roundData);
          if (!teeData || !teeData.slope || !teeData.rating) {
            return playerHcp; // Return raw HCP if no tee data
          }
          
          const hcpAllowance = parseFloat(tournament.meta?.hcpAllow || 100) / 100;
          const slope = parseFloat(teeData.slope);
          const rating = parseFloat(teeData.rating);
          const par = parseFloat(teeData.par || totalPar);
          
          if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
            return playerHcp;
          }
          
          const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
          return Math.round(playingHcp);
        }
        
        // Always calculate PHCPs for display (need this for the header table)
        const playerPHCPs = {};
        allPlayers.forEach(p => {
          const pKey = getPlayerKey(p);
          const phcp = calculatePlayingHcpForPlayer(p);
          playerPHCPs[pKey] = isNaN(phcp) ? null : Math.round(phcp);
        });
        
        if (!hasStoredHCPs) {
          if (matchType === 'singles') {
            const validPhcps = Object.entries(playerPHCPs).filter(([k, v]) => v !== null);
            if (validPhcps.length >= 2) {
              const lowestPhcp = Math.min(...validPhcps.map(([k, v]) => v));
              validPhcps.forEach(([pKey, phcp]) => {
                matchHCPs[pKey] = Math.round(phcp - lowestPhcp);
              });
            }
          } else if (matchType === 'fourball') {
            const validPhcps = Object.entries(playerPHCPs).filter(([k, v]) => v !== null);
            if (validPhcps.length > 0) {
              const lowestPhcp = Math.min(...validPhcps.map(([k, v]) => v));
              validPhcps.forEach(([pKey, phcp]) => {
                matchHCPs[pKey] = Math.round(phcp - lowestPhcp);
              });
            }
          } else if (matchType === 'foursomes') {
            const team1Phcps = leftPlayers.map(p => playerPHCPs[getPlayerKey(p)]).filter(p => p !== null);
            const team2Phcps = rightPlayers.map(p => playerPHCPs[getPlayerKey(p)]).filter(p => p !== null);
            
            if (team1Phcps.length >= 1 && team2Phcps.length >= 1) {
              const team1Avg = team1Phcps.reduce((a, b) => a + b, 0) / team1Phcps.length;
              const team2Avg = team2Phcps.reduce((a, b) => a + b, 0) / team2Phcps.length;
              const lowestTeamPhcp = Math.min(team1Avg, team2Avg);
              team1MatchHCP = Math.round(team1Avg - lowestTeamPhcp);
              team2MatchHCP = Math.round(team2Avg - lowestTeamPhcp);
            }
          }
        } else if (matchType === 'foursomes') {
          // For foursomes with stored HCPs, get team match HCPs from first player of each team
          const p1Key = getPlayerKey(leftPlayers[0]);
          const p2Key = getPlayerKey(rightPlayers[0]);
          team1MatchHCP = matchHCPs[p1Key] ?? 0;
          team2MatchHCP = matchHCPs[p2Key] ?? 0;
        }

        // Calculate stroke allocation for each player based on their match HCP
        function calculateStrokeAllocation(matchHCP) {
          const allocation = Array(18).fill(0);
          if (matchHCP > 0) {
            for (let stroke = 1; stroke <= matchHCP; stroke++) {
              for (let hole = 0; hole < 18; hole++) {
                const si = parseInt(strokeIndexes[hole]) || 99;
                const targetSI = stroke <= 18 ? stroke : stroke - 18;
                if (si === targetSI) {
                  allocation[hole]++;
                  break;
                }
              }
            }
          }
          return allocation;
        }

        // Format player name as "FirstName L."
        function formatPlayerShortName(player) {
          const firstName = player.firstName || player.name || 'Unknown';
          const lastName = player.lastName || '';
          if (lastName) {
            return `${firstName} ${lastName.charAt(0).toUpperCase()}.`;
          }
          return firstName;
        }

        // Build players info for header with HCP, PHCP, and Match HCP
        const playersInfo = [];
        if (matchType === 'singles') {
          // Singles: show both players with their HCP, PHCP, and match HCP
          const p1Key = getPlayerKey(leftPlayers[0]);
          const p2Key = getPlayerKey(rightPlayers[0]);
          const p1Hcp = parseFloat(leftPlayers[0].hcp) || 0;
          const p2Hcp = parseFloat(rightPlayers[0].hcp) || 0;
          const p1Phcp = playerPHCPs[p1Key] ?? '-';
          const p2Phcp = playerPHCPs[p2Key] ?? '-';
          playersInfo.push({ 
            name: `${leftPlayers[0].firstName || ''} ${leftPlayers[0].lastName || ''}`.trim() || 'Unknown', 
            hcp: p1Hcp,
            phcp: p1Phcp,
            matchHCP: matchHCPs[p1Key] ?? '-' 
          });
          playersInfo.push({ 
            name: `${rightPlayers[0].firstName || ''} ${rightPlayers[0].lastName || ''}`.trim() || 'Unknown', 
            hcp: p2Hcp,
            phcp: p2Phcp,
            matchHCP: matchHCPs[p2Key] ?? '-' 
          });
        } else if (matchType === 'fourball') {
          // Fourball: show all 4 players with individual HCP, PHCP, match HCP
          leftPlayers.forEach(p => {
            const pKey = getPlayerKey(p);
            const pHcp = parseFloat(p.hcp) || 0;
            playersInfo.push({ 
              name: `${p.firstName || ''} ${p.lastName || ''}`.trim() || 'Unknown', 
              hcp: pHcp,
              phcp: playerPHCPs[pKey] ?? '-',
              matchHCP: matchHCPs[pKey] ?? '-' 
            });
          });
          rightPlayers.forEach(p => {
            const pKey = getPlayerKey(p);
            const pHcp = parseFloat(p.hcp) || 0;
            playersInfo.push({ 
              name: `${p.firstName || ''} ${p.lastName || ''}`.trim() || 'Unknown', 
              hcp: pHcp,
              phcp: playerPHCPs[pKey] ?? '-',
              matchHCP: matchHCPs[pKey] ?? '-' 
            });
          });
        } else {
          // Foursomes: show team names with team HCP, PHCP, match HCP
          const team1Names = leftPlayers.map(p => `${p.firstName || ''} ${p.lastName || ''}`.trim()).join(' / ');
          const team2Names = rightPlayers.map(p => `${p.firstName || ''} ${p.lastName || ''}`.trim()).join(' / ');
          const team1Hcps = leftPlayers.map(p => parseFloat(p.hcp) || 0);
          const team2Hcps = rightPlayers.map(p => parseFloat(p.hcp) || 0);
          const team1AvgHcp = team1Hcps.reduce((a, b) => a + b, 0) / team1Hcps.length;
          const team2AvgHcp = team2Hcps.reduce((a, b) => a + b, 0) / team2Hcps.length;
          const team1Phcps = leftPlayers.map(p => playerPHCPs[getPlayerKey(p)]).filter(p => p !== null);
          const team2Phcps = rightPlayers.map(p => playerPHCPs[getPlayerKey(p)]).filter(p => p !== null);
          const team1AvgPhcp = team1Phcps.length > 0 ? Math.round(team1Phcps.reduce((a, b) => a + b, 0) / team1Phcps.length) : '-';
          const team2AvgPhcp = team2Phcps.length > 0 ? Math.round(team2Phcps.reduce((a, b) => a + b, 0) / team2Phcps.length) : '-';
          playersInfo.push({ name: team1Names, hcp: team1AvgHcp.toFixed(1), phcp: team1AvgPhcp, matchHCP: team1MatchHCP });
          playersInfo.push({ name: team2Names, hcp: team2AvgHcp.toFixed(1), phcp: team2AvgPhcp, matchHCP: team2MatchHCP });
        }

        // Determine card class for singles/foursomes extra spacing
        const cardClass = matchType === 'singles' ? 'singles-card' : matchType === 'foursomes' ? 'foursomes-card' : 'fourball-card';
        
        // Start building HTML
        let html = `
          <div class="scorecard match-scorecard-new ${cardClass}">
            <div class="scorecard-top">
              <div class="scorecard-top-left">
                <div class="scorecard-title">${tournament.name}</div>
                
                <div class="scorecard-header">
                  <div class="scorecard-info-left">
                    <div class="info-row"><span class="label">Date</span><span class="value">: ${formatDateDDMMYYYY(roundDate)}</span></div>
                    <div class="info-row"><span class="label">Round</span><span class="value">: ${roundIndex + 1}</span></div>
                    <div class="info-row"><span class="label">Course</span><span class="value">: ${courseName}</span></div>
                  </div>
                  <div class="scorecard-info-center">
                    <table class="players-hcp-table">
                      <thead>
                        <tr><th>Players</th><th>HCP</th><th>PHCP</th><th>Match HCP</th></tr>
                      </thead>
                      <tbody>`;
        
        // Add player rows with HCP, PHCP, and match HCP
        playersInfo.forEach(pi => {
          html += `<tr><td>${pi.name}</td><td>${pi.hcp}</td><td>${pi.phcp}</td><td><strong>${pi.matchHCP}</strong></td></tr>`;
        });
        
        html += `
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
              <div class="scorecard-logo-container">
                ${uploadedLogos.length > 0 ? `<img src="${uploadedLogos[0]}" alt="Logo" class="scorecard-logo" style="transform: translate(${logoSettings.x}px, ${logoSettings.y}px) scale(${logoSettings.scale / 100});">` : ''}
              </div>
            </div>`;

        // Build main table
        html += `
            <table class="scorecard-table match-table-new">
              <thead>
                <tr>
                  <th class="header-label">Hole:</th>`;
        
        // Hole numbers - Front 9
        for (let i = 1; i <= 9; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Front</th>`;
        
        // Back 9
        for (let i = 10; i <= 18; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Back</th>`;
        html += `<th class="total-cell">Total</th>`;
        html += `</tr></thead><tbody>`;

        // PAR row
        html += `<tr class="par-row"><td class="row-label">PAR</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${pars[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${front9Par}</td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${pars[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${back9Par}</td>`;
        html += `<td class="total-cell">${totalPar}</td>`;
        html += `</tr>`;

        // Stroke Index row
        html += `<tr class="si-row"><td class="row-label">Str. Indx</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Generate score rows based on match type
        if (matchType === 'singles') {
          // Singles: 1 row per player
          // Player 1 (Team 1)
          const p1Key = getPlayerKey(leftPlayers[0]);
          const p1Allocation = calculateStrokeAllocation(matchHCPs[p1Key] || 0);
          html += generateMatchPlayerScoreRow(leftPlayers[0], p1Allocation, 'team1');
          
          // Black separator
          html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
          
          // Player 2 (Team 2)
          const p2Key = getPlayerKey(rightPlayers[0]);
          const p2Allocation = calculateStrokeAllocation(matchHCPs[p2Key] || 0);
          html += generateMatchPlayerScoreRow(rightPlayers[0], p2Allocation, 'team2');
          
        } else if (matchType === 'fourball') {
          // Fourball: 2 rows per team
          // Team 1 - Player 1
          const t1p1Key = getPlayerKey(leftPlayers[0]);
          const t1p1Allocation = calculateStrokeAllocation(matchHCPs[t1p1Key] || 0);
          html += generateMatchPlayerScoreRow(leftPlayers[0], t1p1Allocation, 'team1');
          
          // Team 1 - Player 2
          if (leftPlayers[1]) {
            const t1p2Key = getPlayerKey(leftPlayers[1]);
            const t1p2Allocation = calculateStrokeAllocation(matchHCPs[t1p2Key] || 0);
            html += generateMatchPlayerScoreRow(leftPlayers[1], t1p2Allocation, 'team1');
          }
          
          // Black separator
          html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
          
          // Team 2 - Player 1
          const t2p1Key = getPlayerKey(rightPlayers[0]);
          const t2p1Allocation = calculateStrokeAllocation(matchHCPs[t2p1Key] || 0);
          html += generateMatchPlayerScoreRow(rightPlayers[0], t2p1Allocation, 'team2');
          
          // Team 2 - Player 2
          if (rightPlayers[1]) {
            const t2p2Key = getPlayerKey(rightPlayers[1]);
            const t2p2Allocation = calculateStrokeAllocation(matchHCPs[t2p2Key] || 0);
            html += generateMatchPlayerScoreRow(rightPlayers[1], t2p2Allocation, 'team2');
          }
          
        } else {
          // Foursomes: 1 row per team (combined names)
          // Team 1
          const team1Names = leftPlayers.map(p => formatPlayerShortName(p)).join(' / ');
          const t1Allocation = calculateStrokeAllocation(team1MatchHCP);
          html += generateMatchTeamScoreRow(team1Names, t1Allocation, 'team1');
          
          // Black separator
          html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
          
          // Team 2
          const team2Names = rightPlayers.map(p => formatPlayerShortName(p)).join(' / ');
          const t2Allocation = calculateStrokeAllocation(team2MatchHCP);
          html += generateMatchTeamScoreRow(team2Names, t2Allocation, 'team2');
        }

        // Black separator before pace of play
        html += `<tr class="team-separator"><td colspan="22"></td></tr>`;

        // Pace of Play row
        html += `<tr class="pace-row"><td class="row-label">Pace of Play</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        html += `</tbody></table>`;

        // Signature section
        const sig1Label = matchType === 'singles' ? `Signature  ${formatPlayerShortName(leftPlayers[0])}` : 'Signature  Team 1';
        const sig2Label = matchType === 'singles' ? `Signature  ${formatPlayerShortName(rightPlayers[0])}` : 'Signature  Team 2';
        
        html += `
            <div class="scorecard-footer match-footer">
              <div class="signature-area">
                <span class="sig-label">${sig1Label}</span>
                <span class="sig-line"></span>
              </div>
              <div class="signature-area" style="margin-left: auto;">
                <span class="sig-label">${sig2Label}</span>
                <span class="sig-line"></span>
              </div>
            </div>
          </div>`;

        return html;
      }

      // Generate score row for individual player (Singles, Fourball)
      function generateMatchPlayerScoreRow(player, strokeAllocation, teamClass) {
        const firstName = player.firstName || player.name || 'Unknown';
        const lastName = player.lastName || '';
        const playerShortName = lastName ? `${firstName} ${lastName.charAt(0).toUpperCase()}.` : firstName;
        
        let html = `<tr class="player-score-row ${teamClass}"><td class="row-label player-name-cell">${playerShortName}</td>`;
        
        // Front 9 with HCP dots
        for (let i = 0; i < 9; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        
        // Back 9 with HCP dots
        for (let i = 9; i < 18; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        html += `<td class="total-cell score-total"></td>`;
        html += `</tr>`;
        
        return html;
      }

      // Generate score row for team (Foursomes)
      function generateMatchTeamScoreRow(teamNames, strokeAllocation, teamClass) {
        let html = `<tr class="player-score-row ${teamClass}"><td class="row-label player-name-cell" style="font-size: 10px;">${teamNames}</td>`;
        
        // Front 9 with HCP dots
        for (let i = 0; i < 9; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        
        // Back 9 with HCP dots
        for (let i = 9; i < 18; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        html += `<td class="total-cell score-total"></td>`;
        html += `</tr>`;
        
        return html;
      }

      // Format date as DD.MM.YYYY
      function formatDateDDMMYYYY(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}.${month}.${year}`;
      }

      // Calculate pace of play times starting from tee time
      function calculatePaceTimes(teeTime) {
        if (!teeTime) return Array(18).fill('');
        
        const [hours, minutes] = teeTime.split(':').map(Number);
        if (isNaN(hours) || isNaN(minutes)) return Array(18).fill('');
        
        const times = [];
        let totalMinutes = hours * 60 + minutes;
        
        for (let hole = 0; hole < 18; hole++) {
          totalMinutes += 15; // 15 minutes per hole
          const h = Math.floor(totalMinutes / 60);
          const m = totalMinutes % 60;
          times.push(`${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`);
        }
        
        return times;
      }

      // Get player's tee info (name, distances, rating, slope)
      function getPlayerTeeInfo(player) {
        const defaultInfo = {
          teeName: 'N/A',
          distances: Array(18).fill(0),
          courseRating: '-',
          slopeRating: '-'
        };
        
        if (!player.tee) return defaultInfo;
        
        const courses = getCourses();
        let course = null;
        let teeIndex = -1;
        
        // Handle format: courseId||teeIndex (e.g., "C001||1")
        if (player.tee.includes('||')) {
          const [courseId, teeIndexStr] = player.tee.split('||');
          teeIndex = parseInt(teeIndexStr, 10);
          course = courses.find(c => c.courseId === courseId);
        } else {
          // Handle format: unique tee ID (e.g., "C001-01")
          for (const c of courses) {
            if (!c.teeIds) continue;
            
            const idx = c.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              course = c;
              teeIndex = idx;
              break;
            }
          }
        }
        
        if (!course || teeIndex === -1 || !course.teeData || !course.teeData[teeIndex]) {
          return defaultInfo;
        }
        
        const teeName = course.tees?.[teeIndex] || 'N/A';
        const teeData = course.teeData[teeIndex];
        const distances = teeData.lengths || Array(18).fill(0);
        
        // Get rating/slope based on player gender
        let courseRating, slopeRating;
        const gender = course.genders?.[teeIndex];
        const playerGender = (player.gender || '').toLowerCase();
        
        if (gender === 'B' && teeData.ratings) {
          if (playerGender === 'male' || playerGender === 'm') {
            courseRating = teeData.ratings.men?.rating18;
            slopeRating = teeData.ratings.men?.slope18;
          } else {
            courseRating = teeData.ratings.women?.rating18;
            slopeRating = teeData.ratings.women?.slope18;
          }
        } else {
          courseRating = teeData.rating18 || teeData.rating;
          slopeRating = teeData.slope18 || teeData.slope;
        }
        
        return {
          teeName,
          distances,
          courseRating: courseRating || '-',
          slopeRating: slopeRating || '-'
        };
      }

      function generateScorecardHTML(player, marker, roundDate, roundIndex, teeTime, showTwoTees, showParNet, autoAssignMarker = false) {
        const pars = courseData.pars || [];
        const strokeIndexes = courseData.strokeIndexes || Array(18).fill('-');
        
        // Get player's tee info
        const teeInfo = getPlayerTeeInfo(player);
        const meters = teeInfo.distances;
        
        // Marker name formatting (FirstName L.)
        const markerName = marker ? `${marker.firstName} ${marker.lastName}` : '';
        const markerShortName = marker ? `${marker.firstName} ${marker.lastName.charAt(0).toUpperCase()}.` : 'MARKER';
        
        // Calculate front 9 and back 9 par
        let front9Par = 0, back9Par = 0;
        for (let i = 0; i < 9 && i < pars.length; i++) front9Par += pars[i];
        for (let i = 9; i < 18 && i < pars.length; i++) back9Par += pars[i];
        const totalPar = front9Par + back9Par;

        // Calculate total meters
        let front9Meters = 0, back9Meters = 0;
        for (let i = 0; i < 9 && i < meters.length; i++) {
          front9Meters += (typeof meters[i] === 'number' ? meters[i] : 0);
        }
        for (let i = 9; i < 18 && i < meters.length; i++) {
          back9Meters += (typeof meters[i] === 'number' ? meters[i] : 0);
        }
        const totalMeters = front9Meters + back9Meters;

        // Format HCP and PHCP
        let hcpDisplay = '-';
        if (player.hcp !== undefined && player.hcp !== null && player.hcp !== '') {
          const hcp = parseFloat(player.hcp);
          hcpDisplay = hcp < 0 ? '+' + Math.abs(hcp).toFixed(1) : hcp.toFixed(1);
        }

        const phcp = parseInt(player.phcp) || 0;
        let phcpDisplay = phcp;

        // Course info - use player's tee info
        const courseRating = teeInfo.courseRating;
        const slopeRating = teeInfo.slopeRating;
        const teeName = teeInfo.teeName;
        const courseName = courseData.fullName || courseData.name || 'Golf Course';

        // Calculate stroke allocation based on PHCP (for dots on par)
        const strokeAllocation = Array(18).fill(0);
        if (phcp > 0) {
          // Allocate strokes based on stroke index
          for (let stroke = 1; stroke <= phcp; stroke++) {
            // Find hole with this stroke index
            for (let hole = 0; hole < 18; hole++) {
              const si = parseInt(strokeIndexes[hole]) || 99;
              // For PHCP > 18, we need to go through twice
              const targetSI = stroke <= 18 ? stroke : stroke - 18;
              if (si === targetSI) {
                strokeAllocation[hole]++;
                break;
              }
            }
          }
        }

        // Calculate Net Par / Pickup (NetPar = Par + strokes, Pickup = NetPar + 2 = Net Double Bogey)
        const netParPickup = [];
        for (let i = 0; i < 18; i++) {
          const par = pars[i] || 4;
          const strokes = strokeAllocation[i];
          const netPar = par + strokes;
          const pickup = netPar + 2; // Net double bogey = Net Par + 2
          netParPickup.push(`${netPar}/${pickup}`);
        }

        // Calculate pace of play times
        const paceTimes = calculatePaceTimes(teeTime);

        // Player name for row label - format as "FirstName L." (first name + first letter of last name + dot)
        const playerName = `${player.firstName} ${player.lastName}`;
        const playerShortName = `${player.firstName} ${player.lastName.charAt(0).toUpperCase()}.`;

        let html = `
          <div class="scorecard">
            <div class="scorecard-top">
              <div class="scorecard-top-left">
                <div class="scorecard-title">${tournament.name}</div>
                
                <div class="scorecard-header">
                  <div class="scorecard-info-left">
                    <div class="info-row"><span class="label">Date</span><span class="value">: ${formatDateDDMMYYYY(roundDate)}</span></div>
                    <div class="info-row"><span class="label">Round</span><span class="value">: ${roundIndex + 1}</span></div>
                    <div class="info-row"><span class="label">Course</span><span class="value">: ${courseName}</span></div>
                    <div class="info-row"><span class="label">Tee</span><span class="value">: ${teeName}</span><span class="value" style="margin-left: 12px;">(C.Rat=${courseRating} ; Slope=${slopeRating})</span></div>
                  </div>
                  <div class="scorecard-info-center">
                    <div class="info-row"><span class="label">Player :</span><span class="value">${playerName}</span></div>
                    <div class="info-row"><span class="label">HCP / PHCP:</span><span class="value">${hcpDisplay} / ${phcpDisplay}</span></div>
                  </div>
                </div>
              </div>
              <div class="scorecard-logo-container">
                ${uploadedLogos.length > 0 ? `<img src="${uploadedLogos[0]}" alt="Logo" class="scorecard-logo" style="transform: translate(${logoSettings.x}px, ${logoSettings.y}px) scale(${logoSettings.scale / 100});">` : ''}
              </div>
            </div>`;
        
        // Main table
        html += `
            <table class="scorecard-table">
              <thead>
                <tr>
                  <th class="header-label">Hole:</th>`;
        
        // Front 9 holes
        for (let i = 1; i <= 9; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Front</th>`;
        
        // Back 9 holes
        for (let i = 10; i <= 18; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Back</th>`;
        html += `<th class="total-cell">Total</th>`;
        html += `</tr></thead><tbody>`;

        // PAR row with dots
        html += `<tr class="par-row"><td class="row-label">PAR</td>`;
        for (let i = 0; i < 9; i++) {
          const par = pars[i] || '';
          const dots = strokeAllocation[i] > 0 ? ' <sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td>${par}${dots}</td>`;
        }
        html += `<td class="total-cell">${front9Par}</td>`;
        for (let i = 9; i < 18; i++) {
          const par = pars[i] || '';
          const dots = strokeAllocation[i] > 0 ? ' <sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td>${par}${dots}</td>`;
        }
        html += `<td class="total-cell">${back9Par}</td>`;
        html += `<td class="total-cell">${totalPar}</td>`;
        html += `</tr>`;

        // Meters row
        html += `<tr class="meters-row"><td class="row-label">Meters</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${meters[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${front9Meters}</td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${meters[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${back9Meters}</td>`;
        html += `<td class="total-cell">${totalMeters}</td>`;
        html += `</tr>`;

        // Stroke Index row
        html += `<tr class="si-row"><td class="row-label">Str. Indx</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Net Par / Pickup row (conditional)
        if (showParNet) {
          let front9NetPar = 0;
          for (let i = 0; i < 9; i++) front9NetPar += (pars[i] || 0) + strokeAllocation[i];
          let back9NetPar = 0;
          for (let i = 9; i < 18; i++) back9NetPar += (pars[i] || 0) + strokeAllocation[i];
          
          html += `<tr class="netpar-row"><td class="row-label">Net Par/Pick up</td>`;
          for (let i = 0; i < 9; i++) {
            html += `<td>${netParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${front9NetPar}</td>`;
          for (let i = 9; i < 18; i++) {
            html += `<td>${netParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${back9NetPar}</td>`;
          html += `<td class="total-cell"></td>`;
          html += `</tr>`;
        }

        // Player name row (for scores)
        html += `<tr class="player-row"><td class="row-label" style="color: #c00; font-weight: bold;">${playerShortName}</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Black separator row
        html += `<tr class="separator-row"><td colspan="21"></td></tr>`;

        // Marker's Net Par/Pickup row (only show if auto-assign marker is selected and showParNet is true)
        if (autoAssignMarker && showParNet && marker) {
          // Calculate marker's PHCP and stroke allocation
          const markerPhcp = marker.phcp || 0;
          const markerStrokeAllocation = Array(18).fill(0);
          for (let i = 0; i < 18; i++) {
            const si = strokeIndexes[i];
            if (si && markerPhcp >= si) markerStrokeAllocation[i]++;
            if (si && markerPhcp >= si + 18) markerStrokeAllocation[i]++;
          }
          
          // Calculate marker's net par/pickup
          const markerNetParPickup = pars.map((par, i) => {
            const netPar = par + markerStrokeAllocation[i];
            const pickup = netPar + 2;
            return `${netPar}/${pickup}`;
          });
          
          let markerFront9NetPar = 0;
          for (let i = 0; i < 9; i++) markerFront9NetPar += (pars[i] || 0) + markerStrokeAllocation[i];
          let markerBack9NetPar = 0;
          for (let i = 9; i < 18; i++) markerBack9NetPar += (pars[i] || 0) + markerStrokeAllocation[i];
          
          html += `<tr class="netpar-row"><td class="row-label">Net Par/Pick up</td>`;
          for (let i = 0; i < 9; i++) {
            html += `<td>${markerNetParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${markerFront9NetPar}</td>`;
          for (let i = 9; i < 18; i++) {
            html += `<td>${markerNetParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${markerBack9NetPar}</td>`;
          html += `<td class="total-cell"></td>`;
          html += `</tr>`;
        }

        // MARKER row with name (red if auto-assigned)
        html += `<tr class="marker-row"><td class="row-label" style="color: ${autoAssignMarker ? '#c00' : '#000'}; font-weight: bold;">${markerShortName}</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Black separator row
        html += `<tr class="separator-row"><td colspan="21"></td></tr>`;

        // Pace of Play row
        html += `<tr class="pace-row"><td class="row-label">Pace of Play</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        html += `</tbody></table>`;

        // Signature footer
        html += `
          <div class="scorecard-footer">
            <div class="signature-section">
              <span class="signature-label">Signature</span>
              <span class="signature-name">${playerName}</span>
            </div>
            <div class="signature-section">
              <span class="signature-label">Signature</span>
              <span class="signature-name">${markerName || 'Marker'}</span>
            </div>
          </div>
        </div>
        <div class="cut-line"></div>`; // close scorecard, cut line outside

        return html;
      }

      // Toggle digital scorecards option
      function toggleDigitalScorecards() {
        const digitalChecked = document.getElementById('digital-scorecards').checked;
        const autoAssignCheckbox = document.getElementById('auto-assign-marker');
        const hintSpan = document.getElementById('marker-required-hint');
        const qrButton = document.getElementById('btn-generate-qr');
        const showScorecardsButton = document.getElementById('btn-show-scorecards');
        
        // Check if bracket tournament
        const isBracketTournament = tournament && tournament.type && tournament.type.includes('Bracket');
        
        if (digitalChecked) {
          autoAssignCheckbox.checked = true;
          autoAssignCheckbox.disabled = true;
          hintSpan.style.display = 'inline';
          qrButton.style.display = 'block';
          showScorecardsButton.style.display = isBracketTournament ? 'none' : 'block'; // Hide admin for bracket for now
        } else {
          autoAssignCheckbox.disabled = false;
          hintSpan.style.display = 'none';
          qrButton.style.display = 'none';
          showScorecardsButton.style.display = 'none';
        }
      }

      // Open digital scorecards admin page
      function openDigitalScorecardsAdmin() {
        const roundId = document.getElementById('round-select').value;
        
        if (!roundId) {
          alert('Please select a round');
          return;
        }
        
        const url = `digital_scorecards_admin.html?tournamentId=${tournamentId}&roundId=${encodeURIComponent(roundId)}`;
        window.open(url, '_blank');
      }

      // Generate QR codes for digital scorecards
      function generateDigitalScorecards() {
        // Check if bracket tournament
        const isBracketTournament = tournament && tournament.type && tournament.type.includes('Bracket');
        
        if (isBracketTournament) {
          generateBracketDigitalScorecards();
          return;
        }
        
        const roundId = document.getElementById('round-select').value;
        
        if (!roundId) {
          alert('Please select a round');
          return;
        }

        // Get draw data
        const draws = getDraws();
        const roundDraw = draws[roundId];
        const groups = roundDraw?.groups || roundDraw || [];
        
        if (!groups || groups.length === 0) {
          alert('No draw found for this round. Please create a draw first.');
          return;
        }

        // Load course data for this round
        const courses = getCourses();
        const roundIndex = tournament.meta?.roundIds?.indexOf(roundId) || 0;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        let courseId = roundData?.course || tournament.courseId || tournament.course;
        
        if (!courseId) {
          alert('Course not configured for this tournament/round');
          return;
        }

        courseData = courses.find(c => c.courseId === courseId);

        if (!courseData || !courseData.pars) {
          alert(`Course data not available (Course ID: ${courseId}).`);
          return;
        }

        // Get categories to determine tournament type (Stableford allows X score)
        const categories = tournament.categories || [];
        const categoryMap = {};
        categories.forEach(cat => {
          categoryMap[cat.code] = {
            name: cat.name,
            tournamentType: cat.tournamentType || 'Stableford Net'
          };
        });

        // Save digital scorecard data to localStorage for the scoring page to access
        const digitalData = {
          tournamentId: tournament.tournamentId,
          tournamentName: tournament.name,
          roundId: roundId,
          roundIndex: roundIndex,
          roundDate: roundData?.date || '',
          courseId: courseId,
          courseName: courseData.fullName || courseData.name,
          pars: courseData.pars,
          strokeIndexes: courseData.strokeIndexes,
          categories: categoryMap,
          players: {}
        };

        // Build player data with marker assignments
        // In a group of 4: A marks C, B marks D, C marks B, D marks A
        // (No two players can mark each other - asymmetric pairs)
        // In a group of 3: A marks B, B marks C, C marks A (circular, next player)
        // In a group of 2: A marks B, B marks A (only option)
        groups.forEach((group, groupIndex) => {
          const groupPlayers = group.players || [];
          const groupTime = group.time || group.teeTime || '';
          const groupTee = group.tee || ''; // Starting hole info (e.g., "Hole 7", "1st Tee", "10th Tee")
          
          // Extract starting hole number from tee info
          let startingHole = 1;
          if (groupTee) {
            // Handle "Hole X" format (shotgun)
            const holeMatch = String(groupTee).match(/Hole\s*(\d+)/i);
            if (holeMatch) {
              startingHole = parseInt(holeMatch[1]);
            } else {
              // Handle "1st Tee", "10th Tee" format
              const teeMatch = String(groupTee).match(/(\d+)(?:st|nd|rd|th)?\s*Tee/i);
              if (teeMatch) {
                startingHole = parseInt(teeMatch[1]);
              }
            }
          }
          
          groupPlayers.forEach((player, playerIndex) => {
            // Get the player that THIS player marks
            let marksPlayer = null;
            if (groupPlayers.length === 4) {
              // A(0)->C(2), B(1)->D(3), C(2)->B(1), D(3)->A(0)
              const marksMapping = [2, 3, 1, 0]; // index 0 marks 2, index 1 marks 3, index 2 marks 1, index 3 marks 0
              marksPlayer = groupPlayers[marksMapping[playerIndex]];
            } else if (groupPlayers.length >= 2) {
              // For 2 or 3 players, mark the next player (circular)
              const marksIndex = (playerIndex + 1) % groupPlayers.length;
              marksPlayer = groupPlayers[marksIndex];
            }
            
            const playerId = player.reg || player.odaId || `${player.firstName}_${player.lastName}`;
            const marksPlayerId = marksPlayer ? (marksPlayer.reg || marksPlayer.odaId || `${marksPlayer.firstName}_${marksPlayer.lastName}`) : null;
            
            digitalData.players[playerId] = {
              ...player,
              playerId: playerId,
              groupIndex: groupIndex,
              groupTime: groupTime,
              groupTee: groupTee,
              startingHole: startingHole,
              marksPlayerId: marksPlayerId,
              marksPlayerName: marksPlayer ? `${marksPlayer.firstName} ${marksPlayer.lastName}` : null
            };
          });
        });

        // Save to localStorage
        localStorage.setItem(`digitalScorecard_${roundId}`, JSON.stringify(digitalData));

        // Also save to Firebase for mobile access
        initFirebase();
        if (db) {
          db.ref(`digitalScorecards/${roundId}`).set(digitalData)
            .then(() => console.log('Digital scorecard data saved to Firebase'))
            .catch(err => console.error('Failed to save to Firebase:', err));
        }

        // Generate QR codes
        let html = `
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
            <h3 style="margin: 0 0 8px 0; color: #166534;">üì± Digital Scorecards Ready</h3>
            <p style="margin: 0; color: #15803d; font-size: 14px;">Print these QR codes and distribute to players. Each player scans their code to enter scores.</p>
          </div>
          <div class="qr-grid">`;

        // Get base URL for the digital scorecard page
        const baseUrl = window.location.origin + window.location.pathname.replace('scorecards.html', 'digital_scorecard.html');

        groups.forEach((group, groupIndex) => {
          const groupPlayers = group.players || [];
          const groupTime = group.time || group.teeTime || '';
          
          groupPlayers.forEach((player, playerIndex) => {
            const playerId = player.reg || player.odaId || `${player.firstName}_${player.lastName}`;
            const playerData = digitalData.players[playerId];
            
            // Build URL with parameters
            const url = `${baseUrl}?roundId=${encodeURIComponent(roundId)}&playerId=${encodeURIComponent(playerId)}`;
            
            // Create unique canvas ID
            const canvasId = `qr-${groupIndex}-${playerIndex}`;
            
            html += `
              <div class="qr-card">
                <canvas id="${canvasId}"></canvas>
                <div class="player-name">${player.firstName} ${player.lastName}</div>
                <div class="player-details">PHCP: ${player.phcp || '-'}</div>
                ${playerData.markerName ? `<div class="marker-info">Marker: ${playerData.markerName}</div>` : ''}
                <div class="group-info">Group ${groupIndex + 1} ‚Ä¢ ${groupTime || 'TBD'}</div>
                <button class="copy-link-btn" onclick="copyLink(this, '${url}')" data-url="${url}">
                  üìã Copy Link
                </button>
              </div>`;
          });
        });

        html += '</div>';

        document.getElementById('scorecards-output').innerHTML = html;
        document.getElementById('options-panel').style.display = 'none';
        document.getElementById('print-bar').classList.add('visible');
        document.getElementById('action-buttons').style.display = 'flex';

        // Generate QR codes using QRious library
        loadQRLibrary().then(() => {
          groups.forEach((group, groupIndex) => {
            const groupPlayers = group.players || [];
            
            groupPlayers.forEach((player, playerIndex) => {
              const playerId = player.reg || player.odaId || `${player.firstName}_${player.lastName}`;
              const url = `${baseUrl}?roundId=${encodeURIComponent(roundId)}&playerId=${encodeURIComponent(playerId)}`;
              const canvasId = `qr-${groupIndex}-${playerIndex}`;
              
              new QRious({
                element: document.getElementById(canvasId),
                value: url,
                size: 140,
                backgroundAlpha: 1,
                foreground: '#000000',
                background: '#ffffff',
                level: 'M'
              });
            });
          });
        });
      }

      // Generate QR codes for bracket match play digital scorecards
      async function generateBracketDigitalScorecards() {
        const matchId = document.getElementById('match-select').value;
        const selectedCourseId = document.getElementById('bracket-course').value;
        const selectedTeeMen = document.getElementById('bracket-tee-men').value;
        const selectedTeeWomen = document.getElementById('bracket-tee-women').value;
        
        if (!matchId) {
          alert('Please select a match');
          return;
        }
        
        if (!selectedCourseId) {
          alert('Please select a course');
          return;
        }
        
        // Get course data
        const courses = getCourses();
        const course = courses.find(c => c.courseId === selectedCourseId);
        
        if (!course || !course.pars) {
          alert('Course data not available');
          return;
        }
        
        // Parse matchId to get the match
        const bracketData = tournament.bracketData;
        let match = null;
        let roundName = '';
        
        if (matchId.startsWith('prequal-')) {
          const idx = parseInt(matchId.split('-')[1]);
          match = bracketData.preQualMatches[idx];
          roundName = 'Pre-Qualifier';
        } else if (matchId.startsWith('round-')) {
          const parts = matchId.split('-');
          const roundIdx = parseInt(parts[1]);
          const matchIdx = parseInt(parts[2]);
          match = bracketData.mainBracket[roundIdx].matches[matchIdx];
          roundName = bracketData.mainBracket[roundIdx].name || `Round ${roundIdx + 1}`;
        }
        
        if (!match || !match.player1 || !match.player2) {
          alert('Invalid match selected');
          return;
        }
        
        // Fetch current player data from Firebase
        let allPlayers = [];
        try {
          const snapshot = await db.ref('players').once('value');
          const playersData = snapshot.val();
          if (playersData) {
            allPlayers = Array.isArray(playersData) ? playersData : Object.values(playersData);
          }
        } catch (err) {
          console.error('Failed to fetch players from Firebase', err);
        }
        
        const playersByReg = {};
        const playersById = {};
        allPlayers.forEach(p => { 
          if (p && p.reg) playersByReg[p.reg] = p;
          if (p && p.id) playersById[p.id] = p;
        });
        
        // Helper to extract player data
        function extractPlayerData(playerData) {
          let playerId = null;
          let playerReg = null;
          
          if (playerData && typeof playerData === 'object') {
            playerId = playerData.id;
            playerReg = playerData.reg;
          } else if (typeof playerData === 'string') {
            playerId = playerData;
          }
          
          if (playerReg && playersByReg[playerReg]) {
            const currentPlayer = playersByReg[playerReg];
            if (playerData && typeof playerData === 'object') {
              return { ...playerData, ...currentPlayer };
            }
            return currentPlayer;
          }
          if (playerId && playersById[playerId]) {
            const currentPlayer = playersById[playerId];
            if (playerData && typeof playerData === 'object') {
              return { ...playerData, ...currentPlayer };
            }
            return currentPlayer;
          }
          
          if (playerData && typeof playerData === 'object' && playerData.firstName) {
            return playerData;
          }
          
          return { firstName: 'Unknown', lastName: 'Player' };
        }
        
        const player1 = extractPlayerData(match.player1);
        const player2 = extractPlayerData(match.player2);
        
        // Calculate PHCP for players
        function calculateBracketPhcp(player) {
          const playerHcp = parseFloat(player.hcp);
          if (isNaN(playerHcp)) return null;
          
          const playerGender = (player.gender || '').toLowerCase();
          let teeValue = '';
          if (playerGender === 'female' || playerGender === 'f') {
            teeValue = selectedTeeWomen || selectedTeeMen;
          } else {
            teeValue = selectedTeeMen || selectedTeeWomen;
          }
          
          if (!teeValue || !teeValue.includes('||')) {
            return Math.round(playerHcp);
          }
          
          const [cId, teeIndexStr] = teeValue.split('||');
          const teeIndex = parseInt(teeIndexStr, 10);
          
          const teeData = course.teeData?.[teeIndex];
          if (!teeData) return Math.round(playerHcp);
          
          const teeGender = course.genders?.[teeIndex];
          let slope, rating;
          if (teeGender === 'B' && teeData.ratings) {
            if (playerGender === 'male' || playerGender === 'm') {
              slope = teeData.ratings.men?.slope18;
              rating = teeData.ratings.men?.rating18;
            } else {
              slope = teeData.ratings.women?.slope18;
              rating = teeData.ratings.women?.rating18;
            }
          } else {
            slope = teeData.slope18 || teeData.slope;
            rating = teeData.rating18 || teeData.rating;
          }
          
          let par = 0;
          if (course.pars && Array.isArray(course.pars)) {
            par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
          }
          
          if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
            return Math.round(playerHcp);
          }
          
          const hcpAllowance = parseFloat(tournament.meta?.hcpAllow || 100) / 100;
          const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
          return Math.round(playingHcp);
        }
        
        const p1Phcp = calculateBracketPhcp(player1);
        const p2Phcp = calculateBracketPhcp(player2);
        
        // Calculate Match HCP
        let p1MatchHcp = 0, p2MatchHcp = 0;
        if (p1Phcp !== null && p2Phcp !== null) {
          const lowestPhcp = Math.min(p1Phcp, p2Phcp);
          p1MatchHcp = p1Phcp - lowestPhcp;
          p2MatchHcp = p2Phcp - lowestPhcp;
        }
        
        // Create unique match round ID for digital scorecard storage
        const bracketRoundId = `${tournament.tournamentId}_BRACKET_${matchId}`;
        
        // Build digital scorecard data
        // Get tee names for display
        function getTeeName(teeValue) {
          if (!teeValue || !teeValue.includes('||')) return '';
          const [cId, teeIndexStr] = teeValue.split('||');
          const teeIndex = parseInt(teeIndexStr, 10);
          const teeData = course.teeData?.[teeIndex];
          return teeData?.name || '';
        }
        
        const teeMenName = getTeeName(selectedTeeMen);
        const teeWomenName = getTeeName(selectedTeeWomen);
        
        const digitalData = {
          tournamentId: tournament.tournamentId,
          tournamentName: tournament.name,
          roundId: bracketRoundId,
          roundName: roundName,
          matchId: matchId,
          isBracketMatch: true,
          courseId: selectedCourseId,
          courseName: course.fullName || course.name,
          pars: course.pars,
          strokeIndexes: course.strokeIndexes,
          teeMen: selectedTeeMen,
          teeWomen: selectedTeeWomen,
          teeMenName: teeMenName,
          teeWomenName: teeWomenName,
          hcpAllowance: tournament.meta?.hcpAllow || 100,
          players: {}
        };
        
        // Player 1 data - marks Player 2
        const p1Id = player1.reg || player1.id || `${player1.firstName}_${player1.lastName}`;
        const p2Id = player2.reg || player2.id || `${player2.firstName}_${player2.lastName}`;
        
        digitalData.players[p1Id] = {
          ...player1,
          playerId: p1Id,
          phcp: p1Phcp,
          matchHcp: p1MatchHcp,
          marksPlayerId: p2Id,
          marksPlayerName: `${player2.firstName} ${player2.lastName}`,
          opponent: `${player2.firstName} ${player2.lastName}`,
          opponentPhcp: p2Phcp,
          opponentMatchHcp: p2MatchHcp
        };
        
        // Player 2 data - marks Player 1
        digitalData.players[p2Id] = {
          ...player2,
          playerId: p2Id,
          phcp: p2Phcp,
          matchHcp: p2MatchHcp,
          marksPlayerId: p1Id,
          marksPlayerName: `${player1.firstName} ${player1.lastName}`,
          opponent: `${player1.firstName} ${player1.lastName}`,
          opponentPhcp: p1Phcp,
          opponentMatchHcp: p1MatchHcp
        };
        
        // Save to localStorage
        localStorage.setItem(`digitalScorecard_${bracketRoundId}`, JSON.stringify(digitalData));
        
        // Save to Firebase
        if (db) {
          try {
            await db.ref(`digitalScorecards/${bracketRoundId}`).set(digitalData);
            console.log('Bracket digital scorecard data saved to Firebase');
          } catch (err) {
            console.error('Failed to save to Firebase:', err);
          }
        }
        
        // Generate QR codes
        let html = `
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
            <h3 style="margin: 0 0 8px 0; color: #166534;">üì± Match Play Digital Scorecards Ready</h3>
            <p style="margin: 0; color: #15803d; font-size: 14px;">Print these QR codes for the match. Each player scans their code to enter scores.</p>
            <p style="margin: 8px 0 0 0; color: #166534; font-size: 13px;"><strong>${roundName}:</strong> ${player1.firstName} ${player1.lastName} vs ${player2.firstName} ${player2.lastName}</p>
          </div>
          <div class="qr-grid">`;
        
        const baseUrl = window.location.origin + window.location.pathname.replace('scorecards.html', 'digital_scorecard.html');
        
        // Player 1 QR
        const url1 = `${baseUrl}?roundId=${encodeURIComponent(bracketRoundId)}&playerId=${encodeURIComponent(p1Id)}`;
        html += `
          <div class="qr-card">
            <canvas id="qr-p1"></canvas>
            <div class="player-name">${player1.firstName} ${player1.lastName}</div>
            <div class="player-details">HCP: ${player1.hcp || '-'} ‚Ä¢ PHCP: ${p1Phcp !== null ? p1Phcp : '-'} ‚Ä¢ Match: ${p1MatchHcp}</div>
            <div class="marker-info">Opponent: ${player2.firstName} ${player2.lastName}</div>
            <button class="copy-link-btn" onclick="copyLink(this, '${url1}')" data-url="${url1}">
              üìã Copy Link
            </button>
          </div>`;
        
        // Player 2 QR
        const url2 = `${baseUrl}?roundId=${encodeURIComponent(bracketRoundId)}&playerId=${encodeURIComponent(p2Id)}`;
        html += `
          <div class="qr-card">
            <canvas id="qr-p2"></canvas>
            <div class="player-name">${player2.firstName} ${player2.lastName}</div>
            <div class="player-details">HCP: ${player2.hcp || '-'} ‚Ä¢ PHCP: ${p2Phcp !== null ? p2Phcp : '-'} ‚Ä¢ Match: ${p2MatchHcp}</div>
            <div class="marker-info">Opponent: ${player1.firstName} ${player1.lastName}</div>
            <button class="copy-link-btn" onclick="copyLink(this, '${url2}')" data-url="${url2}">
              üìã Copy Link
            </button>
          </div>`;
        
        html += '</div>';
        
        document.getElementById('scorecards-output').innerHTML = html;
        document.getElementById('options-panel').style.display = 'none';
        document.getElementById('print-bar').classList.add('visible');
        document.getElementById('action-buttons').style.display = 'flex';
        
        // Generate QR codes
        loadQRLibrary().then(() => {
          new QRious({
            element: document.getElementById('qr-p1'),
            value: url1,
            size: 140,
            backgroundAlpha: 1,
            foreground: '#000000',
            background: '#ffffff',
            level: 'M'
          });
          
          new QRious({
            element: document.getElementById('qr-p2'),
            value: url2,
            size: 140,
            backgroundAlpha: 1,
            foreground: '#000000',
            background: '#ffffff',
            level: 'M'
          });
        });
      }

      // Load QRious library dynamically
      function loadQRLibrary() {
        return new Promise((resolve, reject) => {
          if (typeof QRious !== 'undefined') {
            resolve();
            return;
          }
          
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }

      // Copy link to clipboard
      function copyLink(button, url) {
        navigator.clipboard.writeText(url).then(() => {
          const originalText = button.innerHTML;
          button.innerHTML = '‚úì Copied!';
          button.classList.add('copied');
          
          setTimeout(() => {
            button.innerHTML = originalText;
            button.classList.remove('copied');
          }, 2000);
        }).catch(err => {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = url;
          textArea.style.position = 'fixed';
          textArea.style.left = '-9999px';
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          
          button.innerHTML = '‚úì Copied!';
          button.classList.add('copied');
          
          setTimeout(() => {
            button.innerHTML = 'üìã Copy Link';
            button.classList.remove('copied');
          }, 2000);
        });
      }

      init();
    </script>
  </body>
</html>