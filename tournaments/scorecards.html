<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Scorecards</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
      * { font-family: 'Arial', 'Helvetica', sans-serif; }
      body{padding-top:70px}
      .scorecards-container { max-width: 1200px; margin: 24px auto; padding: 16px; }
      .options-card { background: white; border-radius: 16px; padding: 24px; margin-bottom: 24px; box-shadow: 0 8px 24px rgba(2,6,23,0.06); }
      .form-group { margin-bottom: 20px; }
      .form-group label { display: block; font-weight: 600; margin-bottom: 8px; color: #1e293b; }
      .form-group select, .form-group input[type="file"] { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e6e9ef; font-size: 15px; }
      .logo-preview { margin-top: 12px; display: flex; gap: 12px; flex-wrap: wrap; }
      .logo-preview img { max-width: 100px; max-height: 60px; object-fit: contain; border: 1px solid #e6e9ef; border-radius: 6px; padding: 4px; }
      .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top: 12px; }
      .checkbox-group input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; }
      .checkbox-group label { margin: 0; font-weight: 500; cursor: pointer; }
      .btn-generate { background: linear-gradient(180deg, #0b6efd, #0952cc); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; width: 100%; margin-top: 12px; }
      .btn-generate:hover { opacity: 0.9; }
      
      /* Print Styles */
      @media print {
        @page {
          margin: 8mm;
        }
        
        * {
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        html, body {
          padding: 0 !important;
          margin: 0 !important;
          background: white !important;
          padding-top: 0 !important;
        }
        
        /* Hide non-scorecard elements */
        .navbar, 
        nav,
        header, 
        .print-bar,
        .options-card, 
        .action-buttons, 
        .logo-edit-hint, 
        h1.page-title,
        .cut-line,
        #options-panel,
        .top-nav,
        .btn-back-top {
          display: none !important;
        }
        
        .scorecards-container {
          max-width: none !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        
        #scorecards-output {
          display: block !important;
        }
        
        .scorecard {
          page-break-inside: avoid;
          break-inside: avoid;
          border: 2px solid #000 !important;
          margin: 0 auto 5mm auto !important;
          padding: 12px !important;
          box-shadow: none !important;
        }
        
        /* Logo container for print - clip overflow */
        .scorecard-logo-container {
          width: 100px !important;
          height: 80px !important;
          overflow: hidden !important;
        }
        
        /* Reset logo transform for print - fit within container */
        .scorecard-logo {
          transform: none !important;
          max-width: 100% !important;
          max-height: 100% !important;
          width: auto !important;
          height: auto !important;
          object-fit: contain !important;
        }
        
        /* Reduce gap between header and table */
        .scorecard-top {
          margin-bottom: 6px !important;
          display: block !important;
          position: relative !important;
        }
        
        .scorecard-top-left {
          padding-right: 110px !important;
        }
        
        /* Position title absolutely to center across full width */
        .scorecard-title {
          position: absolute !important;
          left: 0 !important;
          right: 0 !important;
          top: 0 !important;
          text-align: center !important;
          margin: 0 !important;
          padding: 0 !important;
          z-index: 1 !important;
        }
        
        .scorecard-header {
          margin-top: 28px !important;
        }
        
        /* Position logo absolutely in top right */
        .scorecard-logo-container {
          position: absolute !important;
          top: 0 !important;
          right: 0 !important;
          width: 100px !important;
          height: 80px !important;
          overflow: hidden !important;
        }
        
        /* Reset logo transform for print - fit within container */
        .scorecard-logo {
          transform: none !important;
          max-width: 100% !important;
          max-height: 100% !important;
          width: auto !important;
          height: auto !important;
          object-fit: contain !important;
        }
        
        /* Hide editable border on logo */
        .scorecard-logo-container.editable {
          border: none !important;
        }
        
        .scorecard-logo-container.editable::after {
          display: none !important;
        }
        
        /* Include signature inside the card */
        .scorecard-footer {
          margin-top: 8px !important;
          padding-bottom: 3px !important;
        }
        
        /* Hide cut line */
        .cut-line {
          display: none !important;
        }
        
        /* Match play specific print styles */
        .team-separator td {
          background: #000 !important;
          height: 4px !important;
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        .player-score-row.team1,
        .player-score-row.team2 {
          background: #dbeafe !important;
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        .player-score-row .score-entry-cell {
          background: white !important;
        }
        
        .player-score-row .total-cell.score-total {
          background: #bfdbfe !important;
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
        
        .match-footer {
          margin-top: 8px !important;
        }
        
        .match-footer .sig-line {
          width: 120px !important;
        }
        
        .pace-row td {
          font-size: 8px !important;
        }
        
        /* Portrait mode - 2 cards per page */
        @media (orientation: portrait) {
          .scorecard {
            max-height: 135mm;
            font-size: 10px !important;
          }
          
          .scorecard-table {
            font-size: 9px !important;
          }
          
          .scorecard-table th,
          .scorecard-table td {
            padding: 3px 2px !important;
            min-width: 22px !important;
          }
          
          .scorecard-title {
            font-size: 18px !important;
            margin-bottom: 6px !important;
          }
          
          .scorecard-info-left,
          .scorecard-info-center {
            font-size: 11px !important;
          }
          
          .scorecard-footer {
            font-size: 10px !important;
          }
        }
        
        /* Landscape mode - 2 cards per page with wider columns */
        @media (orientation: landscape) {
          .scorecard {
            max-height: 92mm;
            font-size: 9px !important;
          }
          
          .scorecard-table {
            font-size: 9px !important;
          }
          
          .scorecard-table th,
          .scorecard-table td {
            padding: 2px 3px !important;
            min-width: 28px !important;
          }
          
          .scorecard-title {
            font-size: 16px !important;
            margin-bottom: 4px !important;
          }
          
          .scorecard-info-left,
          .scorecard-info-center {
            font-size: 10px !important;
          }
          
          .scorecard-footer {
            font-size: 9px !important;
          }
          
          .scorecard-top {
            margin-bottom: 6px !important;
          }
        }
      }
      
      /* Print bar styles */
      .print-bar {
        display: none;
        background: #1e293b;
        padding: 12px 20px;
        position: fixed;
        top: 70px;
        left: 0;
        right: 0;
        z-index: 100;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      }
      
      .print-bar.visible {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .print-bar-left {
        display: flex;
        align-items: center;
        gap: 16px;
      }
      
      .print-bar .btn-print {
        background: linear-gradient(180deg, #22c55e, #16a34a);
        color: white;
        border: none;
        padding: 10px 24px;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .print-bar .btn-back {
        background: #475569;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        text-decoration: none;
      }
      
      .print-bar .print-info {
        color: #94a3b8;
        font-size: 13px;
      }
      
      /* Scorecard Styling - Stroke Play */
      .scorecard { 
        background: white; 
        border: 3px solid #000; 
        margin-bottom: 24px; 
        padding: 20px; 
        border-radius: 0; 
        font-family: 'Arial', sans-serif;
        font-size: 12px;
        position: relative;
      }
      
      .scorecard-top {
        display: block;
        position: relative;
        margin-bottom: 16px;
      }
      
      .scorecard-top-left {
        display: flex;
        flex-direction: column;
        padding-right: 160px;
      }
      
      .scorecard-title {
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        font-style: italic;
        color: #000;
        margin-bottom: 12px;
      }
      
      .scorecard-header {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 40px;
        align-items: start;
        justify-items: center;
      }
      
      .scorecard-info-center {
        justify-self: center;
      }
      
      .scorecard-logo-container {
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 140px;
        height: 120px;
        background: #fff;
        overflow: hidden;
      }
      
      .scorecard-logo {
        object-fit: contain;
        cursor: move;
        user-select: none;
        max-width: 100%;
        max-height: 100%;
      }
      
      .scorecard-logo-container.editable {
        border: 2px dashed #2196F3;
        cursor: move;
      }
      
      .scorecard-logo-container.editable::after {
        content: 'Drag to move, Scroll to resize';
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: #2196F3;
        white-space: nowrap;
      }
      
      .logo-edit-hint {
        background: #2196F3;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        margin-bottom: 10px;
        font-size: 13px;
        display: none;
      }
      
      .logo-edit-hint.visible {
        display: block;
      }
      
      @media print {
        .logo-edit-hint { display: none !important; }
        .scorecard-logo-container.editable { border: 1px solid #ccc; }
        .scorecard-logo-container.editable::after { display: none; }
        
        /* Print styles for players-hcp-table */
        .players-hcp-table {
          margin: 0 auto;
          border-collapse: collapse;
          font-size: 12px;
        }
        
        .players-hcp-table th {
          font-weight: bold;
          padding: 2px 16px;
          text-align: left;
          border-bottom: 1px solid #999;
        }
        
        .players-hcp-table th:last-child {
          text-align: right;
        }
        
        .players-hcp-table td {
          padding: 2px 16px;
        }
        
        .players-hcp-table td:last-child {
          text-align: right;
          font-weight: 600;
        }
        
        /* Singles/Foursomes need extra space */
        .match-scorecard-new.singles-card .match-table-new,
        .match-scorecard-new.foursomes-card .match-table-new {
          margin-top: 50px;
        }
      }
      
      .scorecard-info-center {
        display: flex;
        flex-direction: column;
        gap: 2px;
        font-size: 14px;
        justify-self: center;
      }
      
      .scorecard-info-center .info-row {
        display: flex;
        gap: 4px;
      }
      
      .scorecard-info-center .label {
        font-weight: 700;
      }
      
      .scorecard-info-center .value {
        color: #000;
        font-weight: 700;
      }
      
      .scorecard-info-left {
        display: flex;
        flex-direction: column;
        gap: 2px;
        font-size: 14px;
      }
      
      .scorecard-info-left .info-row {
        display: flex;
        gap: 4px;
      }
      
      .scorecard-info-left .label {
        font-weight: 700;
        min-width: 60px;
      }
      
      .scorecard-info-left .value {
        color: #000;
        font-weight: 700;
      }
      
      .scorecard-table {
        width: 100%;
        border-collapse: collapse;
        margin: 8px 0;
        font-size: 12px;
        font-weight: 600;
      }
      
      .scorecard-table th {
        background: #e0e0e0;
        color: #000;
        padding: 6px 3px;
        text-align: center;
        font-weight: bold;
        font-size: 13px;
        border: 2px solid #000;
        min-width: 30px;
      }
      
      .scorecard-table th.header-label {
        background: #fff;
        text-align: left;
        padding-left: 8px;
        width: 85px;
        font-size: 12px;
      }
      
      .scorecard-table td {
        padding: 5px 3px;
        text-align: center;
        border: 1.5px solid #000;
        height: 24px;
        font-size: 12px;
        font-weight: 600;
      }
      
      .scorecard-table .row-label {
        text-align: left;
        font-weight: 700;
        background: #fff;
        padding-left: 8px;
        white-space: nowrap;
        font-size: 12px;
      }
      
      .scorecard-table .total-cell {
        background: #d4e8f7;
        font-weight: bold;
        font-size: 13px;
        color: #000;
      }
      
      .scorecard-table .par-row td {
        background: #fff;
        font-size: 13px;
        font-weight: bold;
      }
      
      .scorecard-table .meters-row td {
        background: #fffde7;
        color: #000;
        font-weight: bold;
      }
      
      .scorecard-table .si-row td {
        background: #f8f8f8;
        font-weight: 600;
      }
      
      .scorecard-table .netpar-row td {
        background: #f0f0f0;
        font-weight: 600;
      }
      
      .scorecard-table .player-row td {
        background: #fff;
        height: 32px;
      }
      
      .scorecard-table .empty-row td {
        background: #fff;
        height: 28px;
      }
      
      .scorecard-table .separator-row td {
        background: #000;
        height: 8px;
        padding: 0;
      }
      
      .scorecard-table .marker-row td {
        background: #fff;
        height: 32px;
      }
      
      .scorecard-table .pace-row td {
        background: #fff;
        color: #000;
        font-size: 10px;
        font-weight: 600;
      }
      
      .scorecard-footer {
        margin-top: 16px;
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        padding: 0 10px;
      }
      
      .signature-section {
        display: flex;
        align-items: baseline;
        gap: 10px;
      }
      
      .signature-label {
        font-weight: 700;
        font-size: 13px;
      }
      
      .signature-name {
        color: #c00;
        min-width: 160px;
        border-bottom: 1px solid #000;
        padding-bottom: 2px;
        font-weight: 700;
        font-size: 13px;
      }
      
      .cut-line {
        border-top: 2px dashed #000;
        margin-top: 20px;
      }
      
      /* Match Play Scorecard Styling */
      .match-scorecard { background: white; border: 2px solid #000; margin-bottom: 24px; padding: 16px; border-radius: 12px; font-family: 'Arial', sans-serif; }
      .match-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
      .match-header-left { flex: 1; }
      .match-header-right { text-align: right; }
      .match-players-header { display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; margin: 16px 0; padding: 16px; background: #f0f0f0; border-radius: 8px; align-items: center; }
      .match-player-box { padding: 12px; background: white; border-radius: 8px; border: 2px solid #333; }
      .match-player-box.left { border-left: 5px solid #3b82f6; }
      .match-player-box.right { border-right: 5px solid #ec4899; text-align: right; }
      .match-player-name { font-size: 16px; font-weight: bold; }
      .match-player-details { font-size: 12px; color: #666; margin-top: 4px; }
      .match-vs-box { font-size: 20px; font-weight: bold; color: #666; }
      .match-table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 11px; }
      .match-table th { background: #000; color: white; padding: 6px 3px; text-align: center; font-weight: bold; border: 1px solid #000; }
      .match-table td { padding: 6px 3px; text-align: center; border: 1px solid #666; }
      .match-table .row-label { text-align: left; font-weight: bold; background: #f5f5f5; padding-left: 8px; white-space: nowrap; width: 80px; }
      .match-table .total-cell { background: #e8e8e8; font-weight: bold; }
      .match-table .score-box { height: 30px; background: white; }
      .match-table .player-row-1 { background: #dbeafe; }
      .match-table .player-row-2 { background: #fce7f3; }
      .match-table .status-row { background: #fef9c3; }
      .match-result-section { margin-top: 16px; padding: 12px; background: #f5f5f5; border-radius: 8px; }
      .match-result-label { font-weight: bold; margin-bottom: 8px; }
      .match-result-box { border: 2px solid #333; padding: 12px; background: white; min-height: 40px; border-radius: 4px; }
      .match-signatures { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 16px; font-size: 12px; }
      .match-sig-box { display: flex; flex-direction: column; }
      .match-sig-label { font-weight: bold; margin-bottom: 4px; }
      .match-sig-line { border-bottom: 1.5px solid #000; height: 30px; }
      
      /* NEW Match Play Scorecard Styling (Same layout as stroke play) */
      /* .match-scorecard-new uses same .scorecard base styles */
      /* .match-table-new uses same .scorecard-table base styles */
      
      /* Singles/Foursomes need extra space due to fewer rows - prevent logo overlap */
      .match-scorecard-new.singles-card .match-table-new,
      .match-scorecard-new.foursomes-card .match-table-new {
        margin-top: 50px;
      }
      
      /* Centered players and match HCP table */
      .players-hcp-table {
        margin: 0 auto;
        border-collapse: collapse;
        font-size: 12px;
      }
      
      .players-hcp-table th {
        font-weight: bold;
        padding: 2px 16px;
        text-align: left;
        border-bottom: 1px solid #999;
      }
      
      .players-hcp-table th:last-child {
        text-align: right;
      }
      
      .players-hcp-table td {
        padding: 2px 16px;
      }
      
      .players-hcp-table td:last-child {
        text-align: right;
        font-weight: 600;
      }
      
      /* Team separator - black bar between teams */
      .team-separator td {
        background: #000 !important;
        height: 6px !important;
        padding: 0 !important;
        border: none !important;
      }
      
      /* Player score rows for match play */
      .player-score-row.team1 {
        background: #dbeafe; /* Light blue for Team 1 */
      }
      
      .player-score-row.team2 {
        background: #dbeafe; /* Light blue for Team 2 */
      }
      
      .player-score-row .score-entry-cell {
        background: white;
        height: 28px;
        min-width: 28px;
        position: relative;
      }
      
      .player-score-row .score-entry-cell sup {
        color: #1e40af;
        font-size: 10px;
        position: absolute;
        top: 2px;
        right: 3px;
      }
      
      .player-score-row .total-cell.score-total {
        background: #bfdbfe; /* Slightly darker blue for totals */
      }
      
      .player-score-row .player-name-cell {
        background: white;
        font-weight: normal;
        text-align: left;
        padding-left: 6px;
        white-space: nowrap;
      }
      
      /* Pace of play row styling */
      .pace-row td {
        font-size: 9px;
        color: #666;
        background: #f8fafc;
      }
      
      .pace-row .row-label {
        background: #f1f5f9;
        font-weight: 600;
        font-size: 9px;
      }
      
      /* Match footer signatures */
      .match-footer {
        display: flex;
        justify-content: space-between;
        margin-top: 16px;
        padding-top: 12px;
      }
      
      .match-footer .signature-area {
        display: flex;
        align-items: baseline;
        gap: 8px;
      }
      
      .match-footer .sig-label {
        color: #666;
        font-size: 12px;
        white-space: nowrap;
      }
      
      .match-footer .sig-line {
        width: 150px;
        border-bottom: 1px solid #000;
      }
      
      .scorecard-top { display: grid; grid-template-columns: 1fr auto; gap: 16px; margin-bottom: 12px; align-items: start; }
      .scorecard-info { flex: 1; }
      .scorecard-title { font-size: 26px; font-weight: bold; text-align: center; margin: 0 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px; }
      .scorecard-details { font-size: 13px; line-height: 1.6; }
      .scorecard-details div { margin: 2px 0; }
      .scorecard-logos { display: flex; gap: 8px; align-items: center; }
      .scorecard-logos img { max-width: 80px; max-height: 60px; object-fit: contain; }
      
      .scorecard-table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 11px; }
      .scorecard-table th { background: #000; color: white; padding: 6px 2px; text-align: center; font-weight: bold; border: 1px solid #000; }
      .scorecard-table td { padding: 6px 2px; text-align: center; border: 1px solid #666; line-height: 1.3; }
      .scorecard-table .row-label { text-align: left; font-weight: bold; background: #f5f5f5; padding-left: 8px; white-space: nowrap; }
      .scorecard-table .total-cell { background: #e8e8e8; font-weight: bold; }
      .scorecard-table .score-box { height: 35px; background: white; }
      .scorecard-table .player-row { background: #e3f2fd; height: 40px; }
      .scorecard-table .marker-row { background: white; height: 40px; }
      .scorecard-table .pace-row { background: white; }
      
      .logos-section { display: flex; justify-content: center; gap: 20px; margin: 12px 0; padding: 8px; }
      .scorecard-logo { max-height: 60px; max-width: 120px; object-fit: contain; }
      
      .player-info-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin: 12px 0; padding: 12px; background: #f9f9f9; border-radius: 8px; border: 1px solid #ddd; }
      .player-info-item { display: flex; flex-direction: column; }
      .player-info-label { font-size: 11px; font-weight: bold; color: #666; margin-bottom: 4px; }
      .player-info-value { font-size: 14px; font-weight: 600; color: #000; }
      
      .scorecard-footer { margin-top: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 40px; font-size: 12px; }
      .signature-box { display: flex; flex-direction: column; }
      .signature-label { font-weight: bold; margin-bottom: 4px; }
      .signature-line { border-bottom: 1.5px solid #000; padding-bottom: 2px; margin-top: 8px; height: 30px; }
    </style>
  </head>
  <body>
    <div class="top-nav">
      <h1>üèÜ Scorecards</h1>
      <a href="index.html" class="btn-back-top">‚Üê Back</a>
    </div>
    <main class="scorecards-container">
      <header>
        <h1>Generate Scorecards</h1>
        <p class="lead" id="tournament-name">Configure and print scorecards</p>
      </header>

      <div class="options-card" id="options-panel">
        <h2 style="margin-top: 0;">Scorecard Options</h2>
        
        <div class="form-group">
          <label for="round-select">Select Round:</label>
          <select id="round-select">
            <option value="">-- Select Round --</option>
          </select>
        </div>

        <div class="form-group">
          <label for="logo-upload">Upload Logo (optional):</label>
          <input type="file" id="logo-upload" accept="image/*" onchange="handleLogoUpload(event)">
          <div class="logo-preview" id="logo-preview"></div>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="auto-assign-marker" checked>
          <label for="auto-assign-marker">Auto-assign markers (next player in flight)</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-two-tees">
          <label for="show-two-tees">Show meters for two tees</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-par-net">
          <label for="show-par-net">Show Par Net / Pickup</label>
        </div>

        <button class="btn-generate" onclick="generateScorecards()">üìù Generate Scorecards</button>
      </div>

      <div class="print-bar" id="print-bar">
        <div class="print-bar-left">
          <button class="btn-print" onclick="window.print()">üñ®Ô∏è Print Scorecards</button>
          <span class="print-info">2 scorecards per A4 page (Portrait or Landscape)</span>
        </div>
        <div>
          <button class="btn-back" onclick="window.location.reload()">üîÑ Back to Options</button>
        </div>
      </div>

      <div id="scorecards-output"></div>

      <div class="action-buttons" id="action-buttons" style="display: none;">
        <a href="documents.html" id="back-link" class="btn btn-back">Back to Documents</a>
      </div>
    </main>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const tournamentId = urlParams.get('tournamentId');
      
      let tournament = null;
      let courseData = null;
      let uploadedLogos = [];
      let logoSettings = {
        scale: 100,
        x: 0,
        y: 0
      };

      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse tournaments', err);
          return [];
        }
      }

      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Failed to parse courses', err);
          return [];
        }
      }

      function getDraws() {
        try {
          const raw = localStorage.getItem('draws');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse draws', err);
          return {};
        }
      }
      
      function getMatchHCPs() {
        try {
          const raw = localStorage.getItem('matchHCPs');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse matchHCPs', err);
          return {};
        }
      }

      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          console.error('Failed to parse admittedPlayers', err);
          return {};
        }
      }

      function formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
      }

      // Handle logo uploads
      function handleLogoUpload(event) {
        const files = event.target.files;
        uploadedLogos = [];
        const previewDiv = document.getElementById('logo-preview');
        previewDiv.innerHTML = '';
        
        if (files.length === 0) {
          return;
        }
        
        const file = files[0];
        const reader = new FileReader();
        
        reader.onload = function(e) {
          uploadedLogos = [e.target.result];
          
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '80px';
          img.style.maxHeight = '80px';
          img.style.margin = '5px';
          img.style.border = '1px solid #ddd';
          img.style.borderRadius = '4px';
          previewDiv.appendChild(img);
          
          // Reset logo settings
          logoSettings = { scale: 100, x: 0, y: 0 };
        };
        
        reader.readAsDataURL(file);
      }
      
      // Initialize logo drag/resize on first scorecard
      function initLogoInteraction() {
        const firstLogoContainer = document.querySelector('.scorecard-logo-container');
        if (!firstLogoContainer || !uploadedLogos.length) return;
        
        const firstLogo = firstLogoContainer.querySelector('.scorecard-logo');
        if (!firstLogo) return;
        
        // Mark first container as editable
        firstLogoContainer.classList.add('editable');
        
        // Show hint
        const hint = document.createElement('div');
        hint.className = 'logo-edit-hint visible';
        hint.innerHTML = 'üìç Drag the logo on the first card to position it. Use mouse wheel to resize. Changes apply to all cards.';
        document.getElementById('scorecards-output').insertBefore(hint, document.getElementById('scorecards-output').firstChild);
        
        let isDragging = false;
        let startX, startY;
        
        // Drag functionality
        firstLogo.addEventListener('mousedown', (e) => {
          isDragging = true;
          startX = e.clientX - logoSettings.x;
          startY = e.clientY - logoSettings.y;
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          logoSettings.x = e.clientX - startX;
          logoSettings.y = e.clientY - startY;
          // Clamp values
          logoSettings.x = Math.max(-40, Math.min(40, logoSettings.x));
          logoSettings.y = Math.max(-40, Math.min(40, logoSettings.y));
          applyLogoSettingsToAll();
        });
        
        document.addEventListener('mouseup', () => {
          isDragging = false;
        });
        
        // Scroll to resize
        firstLogoContainer.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -5 : 5;
          logoSettings.scale = Math.max(30, Math.min(200, logoSettings.scale + delta));
          applyLogoSettingsToAll();
        });
      }
      
      function applyLogoSettingsToAll() {
        const allLogos = document.querySelectorAll('.scorecard-logo');
        allLogos.forEach(logo => {
          logo.style.transform = `translate(${logoSettings.x}px, ${logoSettings.y}px) scale(${logoSettings.scale / 100})`;
        });
      }

      function init() {
        const tournaments = getTournaments();
        tournament = tournaments.find(t => t.tournamentId === tournamentId);

        if (!tournament) {
          alert('Tournament not found.');
          window.location.href = 'index.html';
          return;
        }

        document.getElementById('tournament-name').textContent = `Scorecards for ${tournament.name}`;
        document.getElementById('back-link').href = `documents.html?tournamentId=${tournamentId}`;

        console.log('Tournament data:', tournament);

        // Populate round selector
        const roundSelect = document.getElementById('round-select');
        
        // Try to get round IDs from different sources
        let roundIds = tournament.meta?.roundIds;
        
        // Fallback: check if draws exist and use those round IDs
        if (!roundIds || roundIds.length === 0) {
          const draws = getDraws();
          const drawKeys = Object.keys(draws).filter(key => key.startsWith(tournament.tournamentId));
          if (drawKeys.length > 0) {
            roundIds = drawKeys;
          }
        }
        
        // Final fallback: create a default round ID
        if (!roundIds || roundIds.length === 0) {
          roundIds = [tournament.tournamentId + '-1'];
        }

        const roundsData = tournament.meta?.roundsData || [];

        console.log('Round IDs:', roundIds);

        roundIds.forEach((rid, idx) => {
          const option = document.createElement('option');
          option.value = rid;
          
          if (roundsData[idx]) {
            const roundDate = roundsData[idx].date ? formatDate(roundsData[idx].date) : '';
            option.textContent = `Round ${idx + 1}${roundDate ? ' - ' + roundDate : ''}`;
          } else {
            option.textContent = `Round ${idx + 1}`;
          }
          
          roundSelect.appendChild(option);
        });
      }

      function generateScorecards() {
        const roundId = document.getElementById('round-select').value;
        const autoAssignMarker = document.getElementById('auto-assign-marker').checked;
        const showTwoTees = document.getElementById('show-two-tees').checked;
        const showParNet = document.getElementById('show-par-net').checked;

        if (!roundId) {
          alert('Please select a round');
          return;
        }

        // Load course data for this round
        const courses = getCourses();
        const roundIndex = tournament.meta?.roundIds?.indexOf(roundId) || 0;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        
        // Detect match type
        const matchType = (roundData?.matchType || '').toLowerCase();
        const isMatchPlay = matchType === 'singles' || matchType === 'fourball' || matchType === 'foursomes';
        
        // Try to get course from round data, or fallback to tournament-level course
        let courseId = roundData?.course || tournament.courseId || tournament.course;
        
        if (!courseId) {
          alert('Course not configured for this tournament/round');
          return;
        }

        courseData = courses.find(c => c.courseId === courseId);

        if (!courseData || !courseData.pars) {
          alert(`Course data not available (Course ID: ${courseId}). Please ensure the course is added in the Courses section.`);
          return;
        }

        // Get draws for this round
        const draws = getDraws();
        const roundDraw = draws[roundId];

        // Get round date
        const roundDate = tournament.meta?.roundsData?.[roundIndex]?.date || '';

        // Generate scorecards based on type
        let html = '';
        
        if (isMatchPlay && roundDraw && roundDraw.groups) {
          // MATCH PLAY: Generate match scorecards from draw groups
          // First, merge fresh admitted player data into groups (same as draw_list.html)
          const admittedPlayers = getAdmittedPlayers()[roundId] || [];
          const admittedByReg = {};
          admittedPlayers.forEach(p => { if (p.reg) admittedByReg[p.reg] = p; });
          
          const enrichedGroups = roundDraw.groups.map(group => {
            const updatedPlayers = (group.players || []).map(player => {
              const freshPlayer = admittedByReg[player.reg];
              if (freshPlayer) {
                return { ...player, ...freshPlayer };
              }
              return player;
            });
            return { ...group, players: updatedPlayers };
          });
          
          html = generateMatchPlayScorecards(enrichedGroups, matchType, roundDate);
        } else {
          // STROKE PLAY: Generate individual scorecards following draw order
          const groups = roundDraw?.groups || roundDraw || [];
          
          if (!groups || groups.length === 0) {
            alert('No draw found for this round. Please create a draw first.');
            return;
          }

          // Generate scorecards in draw order: Group 1 players, then Group 2, etc.
          groups.forEach((group, groupIndex) => {
            const groupPlayers = group.players || [];
            const groupTime = group.time || group.teeTime || '';
            
            groupPlayers.forEach((player, playerIndex) => {
              let marker = null;
              
              if (autoAssignMarker && groupPlayers.length > 1) {
                // Assign next player as marker (wrap around)
                const markerIndex = (playerIndex + 1) % groupPlayers.length;
                marker = groupPlayers[markerIndex];
              }

              html += generateScorecardHTML(player, marker, roundDate, roundIndex, groupTime, showTwoTees, showParNet, autoAssignMarker);
            });
          });
          
          if (!html) {
            alert('No players found in the draw.');
            return;
          }
        }

        document.getElementById('scorecards-output').innerHTML = html;
        document.getElementById('options-panel').style.display = 'none';
        document.getElementById('print-bar').classList.add('visible');
        document.getElementById('action-buttons').style.display = 'flex';
        
        // Initialize logo interaction if logo was uploaded
        if (uploadedLogos.length > 0) {
          initLogoInteraction();
        }
      }

      // Generate match play scorecards
      function generateMatchPlayScorecards(groups, matchType, roundDate) {
        let html = '';
        
        groups.forEach((group, groupIndex) => {
          const players = group.players || [];
          if (players.length < 2) return;
          
          if (matchType === 'singles') {
            // Singles: Create separate match cards for 1v2, 3v4
            const numMatches = Math.floor(players.length / 2);
            
            for (let i = 0; i < numMatches; i++) {
              const player1 = players[i * 2];
              const player2 = players[i * 2 + 1];
              
              if (!player1 || !player2) continue;
              
              html += generateMatchScorecardHTML(
                [player1], 
                [player2], 
                matchType, 
                roundDate, 
                group.time || group.teeTime,
                groupIndex,
                i
              );
            }
          } else {
            // Fourball/Foursomes: Pair vs Pair
            const leftPlayers = players.slice(0, 2);
            const rightPlayers = players.slice(2, 4);
            
            if (leftPlayers.length >= 1 && rightPlayers.length >= 1) {
              html += generateMatchScorecardHTML(
                leftPlayers, 
                rightPlayers, 
                matchType, 
                roundDate, 
                group.time || group.teeTime,
                groupIndex,
                0
              );
            }
          }
        });
        
        return html;
      }

      // Get player tee info for match play (including tee name)
      function getPlayerTeeInfoForMatch(player, roundData) {
        const defaultInfo = {
          teeName: 'N/A',
          distances: Array(18).fill(0),
          courseRating: '-',
          slopeRating: '-'
        };
        
        const courses = getCourses();
        const courseId = roundData?.course || tournament.courseId;
        const course = courses.find(c => c.courseId === courseId);
        if (!course) return defaultInfo;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeIndex = -1;
        
        // Check if player has an assigned tee
        if (player.tee) {
          if (player.tee.includes('||')) {
            const [cId, teeIdxStr] = player.tee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          } else if (course.teeIds) {
            teeIndex = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
          }
        }
        
        // If no assigned tee, use default from round settings
        if (teeIndex === -1) {
          let defaultTee = '';
          if (playerGender === 'male' || playerGender === 'm') {
            defaultTee = roundData?.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            defaultTee = roundData?.teeWomen || '';
          }
          
          if (defaultTee && defaultTee.includes('||')) {
            const [cId, teeIdxStr] = defaultTee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          }
        }
        
        if (teeIndex === -1 || !course.teeData || !course.teeData[teeIndex]) {
          return defaultInfo;
        }
        
        const teeName = course.tees?.[teeIndex] || 'N/A';
        const teeData = course.teeData[teeIndex];
        const distances = teeData.lengths || Array(18).fill(0);
        
        // Get rating/slope based on player gender
        let courseRating, slopeRating;
        const gender = course.genders?.[teeIndex];
        
        if (gender === 'B' && teeData.ratings) {
          if (playerGender === 'male' || playerGender === 'm') {
            courseRating = teeData.ratings.men?.rating18;
            slopeRating = teeData.ratings.men?.slope18;
          } else {
            courseRating = teeData.ratings.women?.rating18;
            slopeRating = teeData.ratings.women?.slope18;
          }
        } else {
          courseRating = teeData.rating18 || teeData.rating;
          slopeRating = teeData.slope18 || teeData.slope;
        }
        
        return {
          teeName,
          distances,
          courseRating: courseRating || '-',
          slopeRating: slopeRating || '-'
        };
      }

      // Get tee data for PHCP calculation (slope, rating, par)
      function getPlayerTeeDataForCalc(player, roundData) {
        const courses = getCourses();
        const courseId = roundData?.course || tournament.courseId;
        const course = courses.find(c => c.courseId === courseId);
        if (!course) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeIndex = -1;
        
        // Check if player has an assigned tee
        if (player.tee) {
          if (player.tee.includes('||')) {
            const [cId, teeIdxStr] = player.tee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          } else if (course.teeIds) {
            teeIndex = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
          }
        }
        
        // If no assigned tee, use default from round settings
        if (teeIndex === -1) {
          let defaultTee = '';
          if (playerGender === 'male' || playerGender === 'm') {
            defaultTee = roundData?.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            defaultTee = roundData?.teeWomen || '';
          }
          
          if (defaultTee && defaultTee.includes('||')) {
            const [cId, teeIdxStr] = defaultTee.split('||');
            teeIndex = parseInt(teeIdxStr, 10);
          }
        }
        
        if (teeIndex === -1 || !course.teeData || !course.teeData[teeIndex]) {
          return null;
        }
        
        const teeData = course.teeData[teeIndex];
        const gender = course.genders?.[teeIndex];
        
        let slope, rating;
        if (gender === 'B' && teeData.ratings) {
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        // Calculate total par
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        return { slope, rating, par };
      }

      // Generate a single match scorecard HTML (Singles, Fourball, Foursomes)
      function generateMatchScorecardHTML(leftPlayers, rightPlayers, matchType, roundDate, teeTime, groupIndex, subMatchIndex) {
        const pars = courseData.pars || [];
        const strokeIndexes = courseData.strokeIndexes || Array(18).fill('-');
        const roundIndex = tournament.meta?.roundIds?.indexOf(document.getElementById('round-select').value) || 0;
        const roundId = document.getElementById('round-select').value;
        const roundData = tournament.meta?.roundsData?.[roundIndex];
        
        // Get course info
        const courseName = courseData.fullName || courseData.name || 'Golf Course';
        
        // Calculate par totals
        let front9Par = 0, back9Par = 0;
        for (let i = 0; i < 9 && i < pars.length; i++) front9Par += pars[i];
        for (let i = 9; i < 18 && i < pars.length; i++) back9Par += pars[i];
        const totalPar = front9Par + back9Par;

        // Get all players in the match
        const allPlayers = [...leftPlayers, ...rightPlayers];

        // Calculate pace of play times
        const paceTimes = calculatePaceTimes(teeTime);

        // Get stored match HCPs (calculated when draw was saved)
        const storedMatchHCPs = getMatchHCPs()[roundId] || {};
        
        // Helper to get consistent player key (prioritize reg since that's what draw.html uses to save)
        function getPlayerKey(player) {
          return player.reg || player.odaId || player.odaid || player.playerId || `${player.firstName}_${player.lastName}`;
        }
        
        // Check if we have stored match HCPs for these players
        let matchHCPs = {};
        let hasStoredHCPs = false;
        
        allPlayers.forEach(p => {
          const pKey = getPlayerKey(p);
          if (storedMatchHCPs[pKey] !== undefined) {
            matchHCPs[pKey] = storedMatchHCPs[pKey];
            hasStoredHCPs = true;
          }
        });
        
        // If no stored HCPs, calculate them (fallback)
        let team1MatchHCP = 0, team2MatchHCP = 0;
        
        if (!hasStoredHCPs) {
          // Helper to parse PHCP (handle '+' prefix for plus handicaps)
          function parsePhcp(phcp) {
            if (phcp === '-' || phcp === undefined || phcp === null) return NaN;
            if (typeof phcp === 'string' && phcp.startsWith('+')) {
              return -parseInt(phcp.substring(1));
            }
            return parseInt(phcp);
          }

          // Calculate playing HCP for a player (same logic as draw_list.html)
          function calculatePlayingHcpForPlayer(player) {
            const playerHcp = parseFloat(player.hcp);
            if (isNaN(playerHcp)) return NaN;
            
            const teeData = getPlayerTeeDataForCalc(player, roundData);
            if (!teeData || !teeData.slope || !teeData.rating) {
              return playerHcp; // Return raw HCP if no tee data
            }
            
            const hcpAllowance = parseFloat(tournament.meta?.hcpAllow || 100) / 100;
            const slope = parseFloat(teeData.slope);
            const rating = parseFloat(teeData.rating);
            const par = parseFloat(teeData.par || totalPar);
            
            if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
              return playerHcp;
            }
            
            const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
            return Math.round(playingHcp);
          }
          
          const playerPHCPs = {};
          allPlayers.forEach(p => {
            const pKey = getPlayerKey(p);
            const phcp = calculatePlayingHcpForPlayer(p);
            playerPHCPs[pKey] = isNaN(phcp) ? null : Math.round(phcp);
          });
          
          if (matchType === 'singles') {
            const validPhcps = Object.entries(playerPHCPs).filter(([k, v]) => v !== null);
            if (validPhcps.length >= 2) {
              const lowestPhcp = Math.min(...validPhcps.map(([k, v]) => v));
              validPhcps.forEach(([pKey, phcp]) => {
                matchHCPs[pKey] = Math.round(phcp - lowestPhcp);
              });
            }
          } else if (matchType === 'fourball') {
            const validPhcps = Object.entries(playerPHCPs).filter(([k, v]) => v !== null);
            if (validPhcps.length > 0) {
              const lowestPhcp = Math.min(...validPhcps.map(([k, v]) => v));
              validPhcps.forEach(([pKey, phcp]) => {
                matchHCPs[pKey] = Math.round(phcp - lowestPhcp);
              });
            }
          } else if (matchType === 'foursomes') {
            const team1Phcps = leftPlayers.map(p => playerPHCPs[getPlayerKey(p)]).filter(p => p !== null);
            const team2Phcps = rightPlayers.map(p => playerPHCPs[getPlayerKey(p)]).filter(p => p !== null);
            
            if (team1Phcps.length >= 1 && team2Phcps.length >= 1) {
              const team1Avg = team1Phcps.reduce((a, b) => a + b, 0) / team1Phcps.length;
              const team2Avg = team2Phcps.reduce((a, b) => a + b, 0) / team2Phcps.length;
              const lowestTeamPhcp = Math.min(team1Avg, team2Avg);
              team1MatchHCP = Math.round(team1Avg - lowestTeamPhcp);
              team2MatchHCP = Math.round(team2Avg - lowestTeamPhcp);
            }
          }
        } else if (matchType === 'foursomes') {
          // For foursomes with stored HCPs, get team match HCPs from first player of each team
          const p1Key = getPlayerKey(leftPlayers[0]);
          const p2Key = getPlayerKey(rightPlayers[0]);
          team1MatchHCP = matchHCPs[p1Key] ?? 0;
          team2MatchHCP = matchHCPs[p2Key] ?? 0;
        }

        // Calculate stroke allocation for each player based on their match HCP
        function calculateStrokeAllocation(matchHCP) {
          const allocation = Array(18).fill(0);
          if (matchHCP > 0) {
            for (let stroke = 1; stroke <= matchHCP; stroke++) {
              for (let hole = 0; hole < 18; hole++) {
                const si = parseInt(strokeIndexes[hole]) || 99;
                const targetSI = stroke <= 18 ? stroke : stroke - 18;
                if (si === targetSI) {
                  allocation[hole]++;
                  break;
                }
              }
            }
          }
          return allocation;
        }

        // Format player name as "FirstName L."
        function formatPlayerShortName(player) {
          return `${player.firstName} ${player.lastName.charAt(0).toUpperCase()}.`;
        }

        // Build players info for header
        const playersInfo = [];
        if (matchType === 'singles') {
          // Singles: show both players with their match HCP
          const p1Key = getPlayerKey(leftPlayers[0]);
          const p2Key = getPlayerKey(rightPlayers[0]);
          playersInfo.push({ name: `${leftPlayers[0].firstName} ${leftPlayers[0].lastName}`, matchHCP: matchHCPs[p1Key] ?? '-' });
          playersInfo.push({ name: `${rightPlayers[0].firstName} ${rightPlayers[0].lastName}`, matchHCP: matchHCPs[p2Key] ?? '-' });
        } else if (matchType === 'fourball') {
          // Fourball: show all 4 players with individual match HCP
          leftPlayers.forEach(p => {
            const pKey = getPlayerKey(p);
            playersInfo.push({ name: `${p.firstName} ${p.lastName}`, matchHCP: matchHCPs[pKey] ?? '-' });
          });
          rightPlayers.forEach(p => {
            const pKey = getPlayerKey(p);
            playersInfo.push({ name: `${p.firstName} ${p.lastName}`, matchHCP: matchHCPs[pKey] ?? '-' });
          });
        } else {
          // Foursomes: show team names with team match HCP
          const team1Names = leftPlayers.map(p => `${p.firstName} ${p.lastName}`).join(' / ');
          const team2Names = rightPlayers.map(p => `${p.firstName} ${p.lastName}`).join(' / ');
          playersInfo.push({ name: team1Names, matchHCP: team1MatchHCP });
          playersInfo.push({ name: team2Names, matchHCP: team2MatchHCP });
        }

        // Determine card class for singles/foursomes extra spacing
        const cardClass = matchType === 'singles' ? 'singles-card' : matchType === 'foursomes' ? 'foursomes-card' : 'fourball-card';
        
        // Start building HTML
        let html = `
          <div class="scorecard match-scorecard-new ${cardClass}">
            <div class="scorecard-top">
              <div class="scorecard-top-left">
                <div class="scorecard-title">${tournament.name}</div>
                
                <div class="scorecard-header">
                  <div class="scorecard-info-left">
                    <div class="info-row"><span class="label">Date</span><span class="value">: ${formatDateDDMMYYYY(roundDate)}</span></div>
                    <div class="info-row"><span class="label">Round</span><span class="value">: ${roundIndex + 1}</span></div>
                    <div class="info-row"><span class="label">Course</span><span class="value">: ${courseName}</span></div>
                  </div>
                  <div class="scorecard-info-center">
                    <table class="players-hcp-table">
                      <thead>
                        <tr><th>Players</th><th>Match HCP</th></tr>
                      </thead>
                      <tbody>`;
        
        // Add player rows with match HCP
        playersInfo.forEach(pi => {
          html += `<tr><td>${pi.name}</td><td>${pi.matchHCP}</td></tr>`;
        });
        
        html += `
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
              <div class="scorecard-logo-container">
                ${uploadedLogos.length > 0 ? `<img src="${uploadedLogos[0]}" alt="Logo" class="scorecard-logo" style="transform: translate(${logoSettings.x}px, ${logoSettings.y}px) scale(${logoSettings.scale / 100});">` : ''}
              </div>
            </div>`;

        // Build main table
        html += `
            <table class="scorecard-table match-table-new">
              <thead>
                <tr>
                  <th class="header-label">Hole:</th>`;
        
        // Hole numbers - Front 9
        for (let i = 1; i <= 9; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Front</th>`;
        
        // Back 9
        for (let i = 10; i <= 18; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Back</th>`;
        html += `<th class="total-cell">Total</th>`;
        html += `</tr></thead><tbody>`;

        // PAR row
        html += `<tr class="par-row"><td class="row-label">PAR</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${pars[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${front9Par}</td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${pars[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${back9Par}</td>`;
        html += `<td class="total-cell">${totalPar}</td>`;
        html += `</tr>`;

        // Stroke Index row
        html += `<tr class="si-row"><td class="row-label">Str. Indx</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Generate score rows based on match type
        if (matchType === 'singles') {
          // Singles: 1 row per player
          // Player 1 (Team 1)
          const p1Key = getPlayerKey(leftPlayers[0]);
          const p1Allocation = calculateStrokeAllocation(matchHCPs[p1Key] || 0);
          html += generateMatchPlayerScoreRow(leftPlayers[0], p1Allocation, 'team1');
          
          // Black separator
          html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
          
          // Player 2 (Team 2)
          const p2Key = getPlayerKey(rightPlayers[0]);
          const p2Allocation = calculateStrokeAllocation(matchHCPs[p2Key] || 0);
          html += generateMatchPlayerScoreRow(rightPlayers[0], p2Allocation, 'team2');
          
        } else if (matchType === 'fourball') {
          // Fourball: 2 rows per team
          // Team 1 - Player 1
          const t1p1Key = getPlayerKey(leftPlayers[0]);
          const t1p1Allocation = calculateStrokeAllocation(matchHCPs[t1p1Key] || 0);
          html += generateMatchPlayerScoreRow(leftPlayers[0], t1p1Allocation, 'team1');
          
          // Team 1 - Player 2
          if (leftPlayers[1]) {
            const t1p2Key = getPlayerKey(leftPlayers[1]);
            const t1p2Allocation = calculateStrokeAllocation(matchHCPs[t1p2Key] || 0);
            html += generateMatchPlayerScoreRow(leftPlayers[1], t1p2Allocation, 'team1');
          }
          
          // Black separator
          html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
          
          // Team 2 - Player 1
          const t2p1Key = getPlayerKey(rightPlayers[0]);
          const t2p1Allocation = calculateStrokeAllocation(matchHCPs[t2p1Key] || 0);
          html += generateMatchPlayerScoreRow(rightPlayers[0], t2p1Allocation, 'team2');
          
          // Team 2 - Player 2
          if (rightPlayers[1]) {
            const t2p2Key = getPlayerKey(rightPlayers[1]);
            const t2p2Allocation = calculateStrokeAllocation(matchHCPs[t2p2Key] || 0);
            html += generateMatchPlayerScoreRow(rightPlayers[1], t2p2Allocation, 'team2');
          }
          
        } else {
          // Foursomes: 1 row per team (combined names)
          // Team 1
          const team1Names = leftPlayers.map(p => formatPlayerShortName(p)).join(' / ');
          const t1Allocation = calculateStrokeAllocation(team1MatchHCP);
          html += generateMatchTeamScoreRow(team1Names, t1Allocation, 'team1');
          
          // Black separator
          html += `<tr class="team-separator"><td colspan="22"></td></tr>`;
          
          // Team 2
          const team2Names = rightPlayers.map(p => formatPlayerShortName(p)).join(' / ');
          const t2Allocation = calculateStrokeAllocation(team2MatchHCP);
          html += generateMatchTeamScoreRow(team2Names, t2Allocation, 'team2');
        }

        // Black separator before pace of play
        html += `<tr class="team-separator"><td colspan="22"></td></tr>`;

        // Pace of Play row
        html += `<tr class="pace-row"><td class="row-label">Pace of Play</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        html += `</tbody></table>`;

        // Signature section
        const sig1Label = matchType === 'singles' ? `Signature  ${formatPlayerShortName(leftPlayers[0])}` : 'Signature  Team 1';
        const sig2Label = matchType === 'singles' ? `Signature  ${formatPlayerShortName(rightPlayers[0])}` : 'Signature  Team 2';
        
        html += `
            <div class="scorecard-footer match-footer">
              <div class="signature-area">
                <span class="sig-label">${sig1Label}</span>
                <span class="sig-line"></span>
              </div>
              <div class="signature-area" style="margin-left: auto;">
                <span class="sig-label">${sig2Label}</span>
                <span class="sig-line"></span>
              </div>
            </div>
          </div>`;

        return html;
      }

      // Generate score row for individual player (Singles, Fourball)
      function generateMatchPlayerScoreRow(player, strokeAllocation, teamClass) {
        const playerShortName = `${player.firstName} ${player.lastName.charAt(0).toUpperCase()}.`;
        
        let html = `<tr class="player-score-row ${teamClass}"><td class="row-label player-name-cell">${playerShortName}</td>`;
        
        // Front 9 with HCP dots
        for (let i = 0; i < 9; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        
        // Back 9 with HCP dots
        for (let i = 9; i < 18; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        html += `<td class="total-cell score-total"></td>`;
        html += `</tr>`;
        
        return html;
      }

      // Generate score row for team (Foursomes)
      function generateMatchTeamScoreRow(teamNames, strokeAllocation, teamClass) {
        let html = `<tr class="player-score-row ${teamClass}"><td class="row-label player-name-cell" style="font-size: 10px;">${teamNames}</td>`;
        
        // Front 9 with HCP dots
        for (let i = 0; i < 9; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        
        // Back 9 with HCP dots
        for (let i = 9; i < 18; i++) {
          const dots = strokeAllocation[i] > 0 ? '<sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td class="score-entry-cell">${dots}</td>`;
        }
        html += `<td class="total-cell score-total"></td>`;
        html += `<td class="total-cell score-total"></td>`;
        html += `</tr>`;
        
        return html;
      }

      // Format date as DD.MM.YYYY
      function formatDateDDMMYYYY(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}.${month}.${year}`;
      }

      // Calculate pace of play times starting from tee time
      function calculatePaceTimes(teeTime) {
        if (!teeTime) return Array(18).fill('');
        
        const [hours, minutes] = teeTime.split(':').map(Number);
        if (isNaN(hours) || isNaN(minutes)) return Array(18).fill('');
        
        const times = [];
        let totalMinutes = hours * 60 + minutes;
        
        for (let hole = 0; hole < 18; hole++) {
          totalMinutes += 15; // 15 minutes per hole
          const h = Math.floor(totalMinutes / 60);
          const m = totalMinutes % 60;
          times.push(`${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`);
        }
        
        return times;
      }

      // Get player's tee info (name, distances, rating, slope)
      function getPlayerTeeInfo(player) {
        const defaultInfo = {
          teeName: 'N/A',
          distances: Array(18).fill(0),
          courseRating: '-',
          slopeRating: '-'
        };
        
        if (!player.tee) return defaultInfo;
        
        const courses = getCourses();
        let course = null;
        let teeIndex = -1;
        
        // Handle format: courseId||teeIndex (e.g., "C001||1")
        if (player.tee.includes('||')) {
          const [courseId, teeIndexStr] = player.tee.split('||');
          teeIndex = parseInt(teeIndexStr, 10);
          course = courses.find(c => c.courseId === courseId);
        } else {
          // Handle format: unique tee ID (e.g., "C001-01")
          for (const c of courses) {
            if (!c.teeIds) continue;
            
            const idx = c.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              course = c;
              teeIndex = idx;
              break;
            }
          }
        }
        
        if (!course || teeIndex === -1 || !course.teeData || !course.teeData[teeIndex]) {
          return defaultInfo;
        }
        
        const teeName = course.tees?.[teeIndex] || 'N/A';
        const teeData = course.teeData[teeIndex];
        const distances = teeData.lengths || Array(18).fill(0);
        
        // Get rating/slope based on player gender
        let courseRating, slopeRating;
        const gender = course.genders?.[teeIndex];
        const playerGender = (player.gender || '').toLowerCase();
        
        if (gender === 'B' && teeData.ratings) {
          if (playerGender === 'male' || playerGender === 'm') {
            courseRating = teeData.ratings.men?.rating18;
            slopeRating = teeData.ratings.men?.slope18;
          } else {
            courseRating = teeData.ratings.women?.rating18;
            slopeRating = teeData.ratings.women?.slope18;
          }
        } else {
          courseRating = teeData.rating18 || teeData.rating;
          slopeRating = teeData.slope18 || teeData.slope;
        }
        
        return {
          teeName,
          distances,
          courseRating: courseRating || '-',
          slopeRating: slopeRating || '-'
        };
      }

      function generateScorecardHTML(player, marker, roundDate, roundIndex, teeTime, showTwoTees, showParNet, autoAssignMarker = false) {
        const pars = courseData.pars || [];
        const strokeIndexes = courseData.strokeIndexes || Array(18).fill('-');
        
        // Get player's tee info
        const teeInfo = getPlayerTeeInfo(player);
        const meters = teeInfo.distances;
        
        // Marker name formatting (FirstName L.)
        const markerName = marker ? `${marker.firstName} ${marker.lastName}` : '';
        const markerShortName = marker ? `${marker.firstName} ${marker.lastName.charAt(0).toUpperCase()}.` : 'MARKER';
        
        // Calculate front 9 and back 9 par
        let front9Par = 0, back9Par = 0;
        for (let i = 0; i < 9 && i < pars.length; i++) front9Par += pars[i];
        for (let i = 9; i < 18 && i < pars.length; i++) back9Par += pars[i];
        const totalPar = front9Par + back9Par;

        // Calculate total meters
        let front9Meters = 0, back9Meters = 0;
        for (let i = 0; i < 9 && i < meters.length; i++) {
          front9Meters += (typeof meters[i] === 'number' ? meters[i] : 0);
        }
        for (let i = 9; i < 18 && i < meters.length; i++) {
          back9Meters += (typeof meters[i] === 'number' ? meters[i] : 0);
        }
        const totalMeters = front9Meters + back9Meters;

        // Format HCP and PHCP
        let hcpDisplay = '-';
        if (player.hcp !== undefined && player.hcp !== null && player.hcp !== '') {
          const hcp = parseFloat(player.hcp);
          hcpDisplay = hcp < 0 ? '+' + Math.abs(hcp).toFixed(1) : hcp.toFixed(1);
        }

        const phcp = parseInt(player.phcp) || 0;
        let phcpDisplay = phcp;

        // Course info - use player's tee info
        const courseRating = teeInfo.courseRating;
        const slopeRating = teeInfo.slopeRating;
        const teeName = teeInfo.teeName;
        const courseName = courseData.fullName || courseData.name || 'Golf Course';

        // Calculate stroke allocation based on PHCP (for dots on par)
        const strokeAllocation = Array(18).fill(0);
        if (phcp > 0) {
          // Allocate strokes based on stroke index
          for (let stroke = 1; stroke <= phcp; stroke++) {
            // Find hole with this stroke index
            for (let hole = 0; hole < 18; hole++) {
              const si = parseInt(strokeIndexes[hole]) || 99;
              // For PHCP > 18, we need to go through twice
              const targetSI = stroke <= 18 ? stroke : stroke - 18;
              if (si === targetSI) {
                strokeAllocation[hole]++;
                break;
              }
            }
          }
        }

        // Calculate Net Par / Pickup (NetPar = Par + strokes, Pickup = NetPar + 2 = Net Double Bogey)
        const netParPickup = [];
        for (let i = 0; i < 18; i++) {
          const par = pars[i] || 4;
          const strokes = strokeAllocation[i];
          const netPar = par + strokes;
          const pickup = netPar + 2; // Net double bogey = Net Par + 2
          netParPickup.push(`${netPar}/${pickup}`);
        }

        // Calculate pace of play times
        const paceTimes = calculatePaceTimes(teeTime);

        // Player name for row label - format as "FirstName L." (first name + first letter of last name + dot)
        const playerName = `${player.firstName} ${player.lastName}`;
        const playerShortName = `${player.firstName} ${player.lastName.charAt(0).toUpperCase()}.`;

        let html = `
          <div class="scorecard">
            <div class="scorecard-top">
              <div class="scorecard-top-left">
                <div class="scorecard-title">${tournament.name}</div>
                
                <div class="scorecard-header">
                  <div class="scorecard-info-left">
                    <div class="info-row"><span class="label">Date</span><span class="value">: ${formatDateDDMMYYYY(roundDate)}</span></div>
                    <div class="info-row"><span class="label">Round</span><span class="value">: ${roundIndex + 1}</span></div>
                    <div class="info-row"><span class="label">Course</span><span class="value">: ${courseName}</span></div>
                    <div class="info-row"><span class="label">Tee</span><span class="value">: ${teeName}</span><span class="value" style="margin-left: 12px;">(C.Rat=${courseRating} ; Slope=${slopeRating})</span></div>
                  </div>
                  <div class="scorecard-info-center">
                    <div class="info-row"><span class="label">Player :</span><span class="value">${playerName}</span></div>
                    <div class="info-row"><span class="label">HCP / PHCP:</span><span class="value">${hcpDisplay} / ${phcpDisplay}</span></div>
                  </div>
                </div>
              </div>
              <div class="scorecard-logo-container">
                ${uploadedLogos.length > 0 ? `<img src="${uploadedLogos[0]}" alt="Logo" class="scorecard-logo" style="transform: translate(${logoSettings.x}px, ${logoSettings.y}px) scale(${logoSettings.scale / 100});">` : ''}
              </div>
            </div>`;
        
        // Main table
        html += `
            <table class="scorecard-table">
              <thead>
                <tr>
                  <th class="header-label">Hole:</th>`;
        
        // Front 9 holes
        for (let i = 1; i <= 9; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Front</th>`;
        
        // Back 9 holes
        for (let i = 10; i <= 18; i++) {
          html += `<th>${i}</th>`;
        }
        html += `<th class="total-cell">Back</th>`;
        html += `<th class="total-cell">Total</th>`;
        html += `</tr></thead><tbody>`;

        // PAR row with dots
        html += `<tr class="par-row"><td class="row-label">PAR</td>`;
        for (let i = 0; i < 9; i++) {
          const par = pars[i] || '';
          const dots = strokeAllocation[i] > 0 ? ' <sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td>${par}${dots}</td>`;
        }
        html += `<td class="total-cell">${front9Par}</td>`;
        for (let i = 9; i < 18; i++) {
          const par = pars[i] || '';
          const dots = strokeAllocation[i] > 0 ? ' <sup>' + '‚Ä¢'.repeat(strokeAllocation[i]) + '</sup>' : '';
          html += `<td>${par}${dots}</td>`;
        }
        html += `<td class="total-cell">${back9Par}</td>`;
        html += `<td class="total-cell">${totalPar}</td>`;
        html += `</tr>`;

        // Meters row
        html += `<tr class="meters-row"><td class="row-label">Meters</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${meters[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${front9Meters}</td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${meters[i] || ''}</td>`;
        }
        html += `<td class="total-cell">${back9Meters}</td>`;
        html += `<td class="total-cell">${totalMeters}</td>`;
        html += `</tr>`;

        // Stroke Index row
        html += `<tr class="si-row"><td class="row-label">Str. Indx</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${strokeIndexes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Net Par / Pickup row (conditional)
        if (showParNet) {
          let front9NetPar = 0;
          for (let i = 0; i < 9; i++) front9NetPar += (pars[i] || 0) + strokeAllocation[i];
          let back9NetPar = 0;
          for (let i = 9; i < 18; i++) back9NetPar += (pars[i] || 0) + strokeAllocation[i];
          
          html += `<tr class="netpar-row"><td class="row-label">Net Par/Pick up</td>`;
          for (let i = 0; i < 9; i++) {
            html += `<td>${netParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${front9NetPar}</td>`;
          for (let i = 9; i < 18; i++) {
            html += `<td>${netParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${back9NetPar}</td>`;
          html += `<td class="total-cell"></td>`;
          html += `</tr>`;
        }

        // Player name row (for scores)
        html += `<tr class="player-row"><td class="row-label" style="color: #c00; font-weight: bold;">${playerShortName}</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Black separator row
        html += `<tr class="separator-row"><td colspan="21"></td></tr>`;

        // Marker's Net Par/Pickup row (only show if auto-assign marker is selected and showParNet is true)
        if (autoAssignMarker && showParNet && marker) {
          // Calculate marker's PHCP and stroke allocation
          const markerPhcp = marker.phcp || 0;
          const markerStrokeAllocation = Array(18).fill(0);
          for (let i = 0; i < 18; i++) {
            const si = strokeIndexes[i];
            if (si && markerPhcp >= si) markerStrokeAllocation[i]++;
            if (si && markerPhcp >= si + 18) markerStrokeAllocation[i]++;
          }
          
          // Calculate marker's net par/pickup
          const markerNetParPickup = pars.map((par, i) => {
            const netPar = par + markerStrokeAllocation[i];
            const pickup = netPar + 2;
            return `${netPar}/${pickup}`;
          });
          
          let markerFront9NetPar = 0;
          for (let i = 0; i < 9; i++) markerFront9NetPar += (pars[i] || 0) + markerStrokeAllocation[i];
          let markerBack9NetPar = 0;
          for (let i = 9; i < 18; i++) markerBack9NetPar += (pars[i] || 0) + markerStrokeAllocation[i];
          
          html += `<tr class="netpar-row"><td class="row-label">Net Par/Pick up</td>`;
          for (let i = 0; i < 9; i++) {
            html += `<td>${markerNetParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${markerFront9NetPar}</td>`;
          for (let i = 9; i < 18; i++) {
            html += `<td>${markerNetParPickup[i]}</td>`;
          }
          html += `<td class="total-cell">${markerBack9NetPar}</td>`;
          html += `<td class="total-cell"></td>`;
          html += `</tr>`;
        }

        // MARKER row with name (red if auto-assigned)
        html += `<tr class="marker-row"><td class="row-label" style="color: ${autoAssignMarker ? '#c00' : '#000'}; font-weight: bold;">${markerShortName}</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td></td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        // Black separator row
        html += `<tr class="separator-row"><td colspan="21"></td></tr>`;

        // Pace of Play row
        html += `<tr class="pace-row"><td class="row-label">Pace of Play</td>`;
        for (let i = 0; i < 9; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        for (let i = 9; i < 18; i++) {
          html += `<td>${paceTimes[i] || ''}</td>`;
        }
        html += `<td class="total-cell"></td>`;
        html += `<td class="total-cell"></td>`;
        html += `</tr>`;

        html += `</tbody></table>`;

        // Signature footer
        html += `
          <div class="scorecard-footer">
            <div class="signature-section">
              <span class="signature-label">Signature</span>
              <span class="signature-name">${playerName}</span>
            </div>
            <div class="signature-section">
              <span class="signature-label">Signature</span>
              <span class="signature-name">${markerName || 'Marker'}</span>
            </div>
          </div>
        </div>
        <div class="cut-line"></div>`; // close scorecard, cut line outside

        return html;
      }

      init();
    </script>
  </body>
</html>
