<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Digital Scorecard</title>
  <link rel="stylesheet" href="../styles.css">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f0f4f8;
      min-height: 100vh;
      padding-bottom: 100px;
      overflow-x: hidden;
    }
    
    /* Header */
    .header {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
      padding: 16px 20px;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .header h1 {
      font-size: 18px;
      font-weight: 700;
    }
    
    .live-badge {
      background: #ef4444;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 700;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .header-info {
      font-size: 13px;
      opacity: 0.95;
    }
    
    .container {
      max-width: 500px;
      margin: 0 auto;
      padding: 12px;
    }
    
    /* Player Card - Compact */
    .player-card {
      background: white;
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }
    
    .player-card h2 {
      font-size: 17px;
      color: #1e293b;
      margin-bottom: 6px;
    }
    
    .player-details {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 12px;
      font-size: 13px;
      color: #64748b;
    }
    
    .player-details .detail-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .player-details .label {
      font-weight: 600;
      color: #475569;
    }
    
    .player-details .marker-inline {
      color: #3b82f6;
      font-weight: 600;
    }
    
    /* Bracket Match Header - VS layout */
    .bracket-match-card {
      background: white;
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }
    
    .bracket-match-card .match-title {
      text-align: center;
      font-size: 16px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 12px;
    }
    
    .bracket-match-card .match-title span {
      color: #dc2626;
      font-weight: 800;
    }
    
    .bracket-match-card .players-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }
    
    .bracket-match-card .player-side {
      flex: 1;
      text-align: center;
    }
    
    .bracket-match-card .player-side.left {
      text-align: left;
    }
    
    .bracket-match-card .player-side.right {
      text-align: right;
    }
    
    .bracket-match-card .player-name {
      font-size: 14px;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 4px;
    }
    
    .bracket-match-card .player-hcp-info {
      font-size: 11px;
      color: #64748b;
      line-height: 1.4;
    }
    
    .bracket-match-card .player-hcp-info .hcp-row {
      display: block;
    }
    
    .bracket-match-card .vs-divider {
      font-size: 14px;
      font-weight: 800;
      color: #dc2626;
      padding: 0 4px;
      align-self: center;
    }
    
    /* Header course info */
    .header-course {
      font-size: 12px;
      opacity: 0.9;
      margin-top: 2px;
    }
    
    /* Match over notice for blocked holes */
    .match-over-notice {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
      text-align: center;
      padding: 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
    }
    
    /* Current Hole Display - Compact Horizontal */
    .current-hole-card {
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 12px;
      color: white;
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.25);
      position: relative;
      overflow: hidden;
      touch-action: pan-y pinch-zoom;
      user-select: none;
    }
    
    .current-hole-card .hole-progress {
      display: flex;
      justify-content: center;
      gap: 3px;
      margin-bottom: 8px;
    }
    
    .current-hole-card .hole-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
    }
    
    .current-hole-card .hole-dot.active {
      background: white;
      width: 8px;
      height: 8px;
    }
    
    .current-hole-card .hole-dot.has-score {
      background: rgba(16, 185, 129, 0.8);
    }
    
    .current-hole-card .hole-dot.active.has-score {
      background: white;
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.8);
    }
    
    /* Dispute indicator on hole dot */
    .current-hole-card .hole-dot.dispute {
      background: #dc2626;
      animation: pulse-dispute 1.5s ease-in-out infinite;
    }
    
    .current-hole-card .hole-dot.active.dispute {
      background: white;
      box-shadow: 0 0 0 2px #dc2626;
    }
    
    @keyframes pulse-dispute {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.3); }
    }
    
    .hole-main-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .hole-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .hole-left .hole-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
    }
    
    .hole-left .hole-number {
      font-size: 48px;
      font-weight: 800;
      line-height: 1;
    }
    
    .hole-right {
      text-align: right;
    }
    
    .hole-right .stat-row {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
      font-size: 15px;
      margin-bottom: 2px;
    }
    
    .hole-right .stat-label {
      opacity: 0.7;
      font-weight: 500;
    }
    
    .hole-right .stat-value {
      font-weight: 700;
      min-width: 24px;
    }
    
    .stroke-info-row {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.2);
      font-size: 12px;
    }
    
    .stroke-info-row .stroke-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .stroke-info-row .stroke-count {
      font-weight: 700;
    }
    
    /* Match Score Display (for bracket match play) */
    .match-score-display {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.2);
      gap: 12px;
    }
    
    .match-score-display .player-side {
      flex: 1;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      opacity: 0.9;
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .match-score-display .player-side.leading {
      opacity: 1;
      color: #fef08a;
    }
    
    .match-score-display .match-status {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255,255,255,0.15);
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 800;
    }
    
    .match-score-display .match-status .arrow {
      font-size: 16px;
      animation: bounce-arrow 1s ease-in-out infinite;
    }
    
    .match-score-display .match-status .arrow.left {
      transform: scaleX(-1);
    }
    
    .match-score-display .match-status.all-square {
      background: rgba(255,255,255,0.25);
    }
    
    .match-score-display .match-status.match-won {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      font-weight: 800;
      animation: pulse-win 2s ease-in-out infinite;
    }
    
    @keyframes pulse-win {
      0%, 100% { box-shadow: 0 2px 8px rgba(5, 150, 105, 0.4); }
      50% { box-shadow: 0 2px 16px rgba(5, 150, 105, 0.8); }
    }

    @keyframes bounce-arrow {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(3px); }
    }
    
    .match-score-display .match-status .arrow.left {
      animation: bounce-arrow-left 1s ease-in-out infinite;
    }
    
    @keyframes bounce-arrow-left {
      0%, 100% { transform: scaleX(-1) translateX(0); }
      50% { transform: scaleX(-1) translateX(3px); }
    }

    /* Legacy styles for compatibility */
    .hole-stats {
      display: none;
    }
    
    .hole-stat {
      text-align: center;
    }
    
    .hole-stat .stat-value {
      font-size: 24px;
      font-weight: 700;
    }
    
    .hole-stat .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
    }
    
    .stroke-info {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.2);
      font-size: 13px;
    }
    
    .stroke-info .stroke-badge {
      display: inline-block;
      background: rgba(255,255,255,0.2);
      padding: 4px 12px;
      border-radius: 20px;
      font-weight: 600;
    }
    
    /* Score Entry */
    .score-entry-card {
      background: white;
      border-radius: 12px;
      padding: 12px 8px;
      margin-bottom: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      overflow: hidden;
    }
    
    /* Side-by-side score sections */
    .score-sections-row {
      display: flex;
      gap: 8px;
      justify-content: center;
    }
    
    .score-section {
      flex: 1;
      text-align: center;
    }
    
    .score-section-header {
      margin-bottom: 8px;
    }
    
    .score-section-title {
      font-size: 13px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .score-section-title.player-title {
      color: #059669;
    }
    
    .score-section-title.marker-title {
      color: #3b82f6;
    }
    
    .score-input-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .score-minus-btn, .score-plus-btn {
      width: 48px;
      height: 48px;
      border: none;
      border-radius: 50%;
      font-size: 32px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      user-select: none;
      line-height: 1;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .score-minus-btn {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
      color: #dc2626;
    }
    
    .score-minus-btn:active {
      transform: scale(0.9);
      background: #fca5a5;
    }
    
    .score-plus-btn {
      background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
      color: #059669;
    }
    
    .score-plus-btn:active {
      transform: scale(0.9);
      background: #6ee7b7;
    }
    
    .score-pickup-btn {
      width: 100%;
      padding: 6px 12px;
      margin-top: 8px;
      border: 1px solid #f59e0b;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      color: #92400e;
      transition: all 0.15s;
      user-select: none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .score-pickup-btn:active {
      transform: scale(0.95);
      background: #fcd34d;
    }
    
    .score-display {
      min-width: 50px;
      width: 50px;
      height: 50px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      font-weight: 700;
      color: #1e293b;
    }
    
    .score-display.eagle {
      background: #fbbf24;
      border-color: #f59e0b;
      color: #78350f;
    }
    
    .score-display.birdie {
      background: #dc2626;
      border-color: #b91c1c;
      color: white;
    }
    
    .score-display.par {
      background: #f8fafc;
      border-color: #94a3b8;
      color: #1e293b;
    }
    
    .score-display.bogey {
      background: #1e293b;
      border-color: #0f172a;
      color: white;
    }
    
    .score-display.double {
      background: #3b82f6;
      border-color: #2563eb;
      color: white;
    }
    
    .score-display.pickup {
      background: #fef3c7;
      border-color: #f59e0b;
      color: #92400e;
      font-size: 22px;
    }
    
    /* Legacy score-row styles - keep for compatibility */
    .score-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid #f1f5f9;
    }
    
    .score-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }
    
    .score-row:first-child {
      padding-top: 0;
    }
    
    .score-player-name {
      font-size: 15px;
      font-weight: 600;
      color: #1e293b;
      flex: 1;
    }
    
    .score-player-name.player-name {
      color: #059669;
    }
    
    .score-player-name.marker-name {
      color: #3b82f6;
    }
    
    .score-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .score-adjust-btn {
      width: 44px;
      height: 44px;
      border: 2px solid #e2e8f0;
      border-radius: 50%;
      background: white;
      font-size: 24px;
      font-weight: 600;
      color: #64748b;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      user-select: none;
    }
    
    .score-adjust-btn:active {
      transform: scale(0.9);
      background: #f1f5f9;
    }
    
    .score-adjust-btn.minus {
      color: #dc2626;
      border-color: #fecaca;
    }
    
    .score-adjust-btn.minus:active {
      background: #fee2e2;
    }
    
    .score-adjust-btn.plus {
      color: #059669;
      border-color: #a7f3d0;
    }
    
    .score-adjust-btn.plus:active {
      background: #d1fae5;
    }
    
    .score-display {
      width: 64px;
      height: 48px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 700;
      color: #1e293b;
      position: relative;
    }
    
    .score-display.empty {
      color: #cbd5e1;
    }
    
    .score-display.eagle {
      background: #fbbf24;
      border-color: #f59e0b;
      color: #78350f;
    }
    
    .score-display.birdie {
      background: #dc2626;
      border-color: #b91c1c;
      color: white;
    }
    
    .score-display.par {
      background: #f8fafc;
      border-color: #94a3b8;
      color: #1e293b;
    }
    
    .score-display.bogey {
      background: #1e293b;
      border-color: #0f172a;
      color: white;
    }
    
    .score-display.double-plus {
      background: #3b82f6;
      border-color: #2563eb;
      color: white;
    }
    
    .score-diff {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #1e293b;
      color: white;
      font-size: 10px;
      font-weight: 700;
      padding: 2px 6px;
      border-radius: 10px;
      min-width: 20px;
      text-align: center;
    }
    
    .score-diff.under {
      background: #dc2626;
    }
    
    .score-diff.over {
      background: #1e293b;
    }
    
    /* View Full Scorecard Button */
    .btn-view-scorecard {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #475569 0%, #334155 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .btn-view-scorecard:active {
      opacity: 0.9;
    }
    
    /* Save Button */
    .save-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 16px;
      box-shadow: 0 -4px 16px rgba(0,0,0,0.1);
      z-index: 100;
    }
    
    .btn-save {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .btn-save:active {
      opacity: 0.9;
    }
    
    .btn-save:disabled {
      background: #94a3b8;
      cursor: not-allowed;
    }
    
    /* Disputes warning state */
    .btn-save.btn-disputes {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    }
    
    /* Marker not logged in state */
    .btn-save.btn-not-logged-in {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    }
    
    /* Waiting for marker state */
    .btn-save.btn-pending {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
    }
    
    /* Sign & Complete state */
    .btn-save.btn-sign {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    }
    
    /* Finish Match state (bracket match play) */
    .btn-save.btn-finish {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      animation: pulse-finish 2s ease-in-out infinite;
    }
    
    @keyframes pulse-finish {
      0%, 100% { box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3); }
      50% { box-shadow: 0 4px 20px rgba(5, 150, 105, 0.6); }
    }
    
    /* Modal for Full Scorecard */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 1000;
    }
    
    .modal-overlay.active {
      display: flex;
    }
    
    .modal-content {
      background: white;
      border-radius: 20px 20px 0 0;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      animation: slideUp 0.3s ease-out;
    }
    
    @keyframes slideUp {
      from { transform: translateY(100%); }
      to { transform: translateY(0); }
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid #e2e8f0;
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
    }
    
    .modal-header h2 {
      font-size: 18px;
      color: #1e293b;
    }
    
    .modal-close {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: none;
      background: #f1f5f9;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .modal-body {
      padding: 20px;
    }
    
    /* Scorecard Table */
    .scorecard-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    
    .scorecard-table th {
      background: #1e293b;
      color: white;
      padding: 8px 4px;
      text-align: center;
      font-weight: 600;
      font-size: 10px;
    }
    
    .scorecard-table td {
      padding: 8px 4px;
      text-align: center;
      border: 1px solid #e2e8f0;
    }
    
    .scorecard-table .row-label {
      text-align: left;
      font-weight: 600;
      background: #f8fafc;
      padding-left: 8px;
      white-space: nowrap;
      font-size: 10px;
    }
    
    .scorecard-table .total-cell {
      background: #dbeafe;
      font-weight: 700;
    }
    
    .scorecard-table .score-cell {
      font-weight: 700;
    }
    
    .scorecard-table .score-cell.eagle { background: #fbbf24; color: #78350f; }
    .scorecard-table .score-cell.birdie { background: #dc2626; color: white; }
    .scorecard-table .score-cell.par { background: white; }
    .scorecard-table .score-cell.bogey { background: #1e293b; color: white; }
    .scorecard-table .score-cell.double { background: #3b82f6; color: white; }
    .scorecard-table .score-cell.pickup { background: #f59e0b; color: #78350f; font-weight: 800; }
    
    /* Separator row */
    .scorecard-table .separator-row td {
      background: #000;
      height: 4px;
      padding: 0;
      border: none;
    }
    
    /* Match Play Scorecard Styles */
    .match-play-table .player-label {
      color: #059669;
      font-weight: 700;
    }
    
    .match-play-table .opponent-label {
      color: #3b82f6;
      font-weight: 700;
    }
    
    .match-play-table .match-label {
      color: #64748b;
      font-weight: 600;
      font-size: 10px;
    }
    
    .match-play-table .hcp-badge {
      background: rgba(0,0,0,0.1);
      padding: 1px 4px;
      border-radius: 4px;
      font-size: 9px;
      margin-left: 2px;
    }
    
    .match-play-table .stroke-dot {
      color: #dc2626;
      font-weight: 800;
      font-size: 10px;
      position: relative;
      top: -4px;
    }
    
    .match-play-table .match-status-row td {
      background: #f1f5f9;
    }
    
    .match-play-table .match-cell {
      font-size: 10px;
      font-weight: 700;
      text-align: center;
    }
    
    .match-play-table .match-cell.match-up {
      color: #059669;
      background: #d1fae5;
    }
    
    .match-play-table .match-cell.match-down {
      color: #dc2626;
      background: #fee2e2;
    }
    
    .match-play-table .match-cell.match-square {
      color: #64748b;
      background: #f1f5f9;
    }
    
    .match-play-table .match-final {
      font-weight: 800;
      font-size: 10px;
    }
    
    .match-play-table .match-final.match-up {
      color: #059669;
      background: #d1fae5;
    }
    
    .match-play-table .match-final.match-down {
      color: #dc2626;
      background: #fee2e2;
    }
    
    /* Loading State */
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
      text-align: center;
    }
    
    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #e2e8f0;
      border-top-color: #059669;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .error-state {
      text-align: center;
      padding: 40px 20px;
      color: #dc2626;
    }
    
    .error-state h2 {
      margin-bottom: 8px;
    }
    
    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: #1e293b;
      color: white;
      padding: 12px 24px;
      border-radius: 30px;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1001;
    }
    
    .toast.show {
      opacity: 1;
    }
    
    .toast.success { background: #059669; }
    .toast.error { background: #dc2626; }
    
    /* Dispute warning banner */
    .dispute-banner {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 2px solid #f59e0b;
      border-radius: 12px;
      padding: 12px 16px;
      margin: 0 16px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }
    
    .dispute-banner.hidden {
      display: none;
    }
    
    .dispute-icon {
      font-size: 28px;
      flex-shrink: 0;
    }
    
    .dispute-content {
      flex: 1;
    }
    
    .dispute-title {
      font-weight: 700;
      color: #92400e;
      font-size: 14px;
      margin-bottom: 4px;
    }
    
    .dispute-holes {
      font-size: 13px;
      color: #b45309;
      font-weight: 600;
    }
    
    .dispute-holes span {
      display: inline-block;
      background: #dc2626;
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      margin-right: 4px;
      margin-bottom: 2px;
      font-size: 12px;
    }
    
    /* Hole indicator with dispute */
    .hole-dispute-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: #dc2626;
      color: white;
      border-radius: 50%;
      font-size: 10px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Current hole dispute warning */
    .current-hole-dispute {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 2px solid #f59e0b;
      border-radius: 8px;
      padding: 10px 14px;
      margin-bottom: 12px;
      font-size: 14px;
      color: #92400e;
      text-align: center;
    }
    
    /* Locked scorecard overlay */
    .locked-banner {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
      padding: 16px;
      margin: 0 16px 12px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
    }
    
    .locked-banner h3 {
      margin: 0 0 8px 0;
      font-size: 18px;
    }
    
    .locked-banner p {
      margin: 0;
      font-size: 13px;
      opacity: 0.9;
    }
    
    .locked-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.3);
      z-index: 50;
      pointer-events: none;
    }
    
    /* Sign modal */
    .sign-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .sign-modal.active {
      display: flex;
    }
    
    .sign-modal-content {
      background: white;
      border-radius: 16px;
      width: 100%;
      max-width: 400px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    .sign-modal-header {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
      padding: 20px;
      border-radius: 16px 16px 0 0;
      text-align: center;
    }
    
    .sign-modal-header h2 {
      margin: 0 0 4px 0;
      font-size: 20px;
    }
    
    .sign-modal-header p {
      margin: 0;
      opacity: 0.9;
      font-size: 14px;
    }
    
    .sign-modal-body {
      padding: 20px;
    }
    
    .score-summary {
      background: #f8fafc;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }
    
    .score-summary-title {
      font-size: 14px;
      color: #64748b;
      margin-bottom: 12px;
      font-weight: 600;
    }
    
    .score-summary-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .score-summary-row:last-child {
      border-bottom: none;
      font-weight: 700;
      font-size: 18px;
      color: #059669;
    }
    
    .score-summary-label {
      color: #475569;
    }
    
    .score-summary-value {
      font-weight: 600;
      color: #1e293b;
    }
    
    /* Signature pad */
    .signature-section {
      margin-bottom: 20px;
    }
    
    .signature-label {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 8px;
    }
    
    .signature-pad-container {
      border: 2px dashed #d1d5db;
      border-radius: 12px;
      background: #fafafa;
      position: relative;
      height: 120px;
      overflow: hidden;
    }
    
    .signature-pad-container.signed {
      border-color: #059669;
      border-style: solid;
      background: #f0fdf4;
    }
    
    .signature-pad {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    .signature-placeholder {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #9ca3af;
      font-size: 14px;
      pointer-events: none;
    }
    
    .signature-pad-container.signed .signature-placeholder {
      display: none;
    }
    
    .clear-signature {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #ef4444;
      color: white;
      border: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      font-size: 14px;
      cursor: pointer;
      display: none;
    }
    
    .signature-pad-container.signed .clear-signature {
      display: block;
    }
    
    /* Confirmation checkbox */
    .confirm-checkbox {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 16px;
      background: #fffbeb;
      border: 1px solid #fcd34d;
      border-radius: 12px;
      margin-bottom: 20px;
    }
    
    .confirm-checkbox input {
      width: 20px;
      height: 20px;
      margin-top: 2px;
      accent-color: #059669;
    }
    
    .confirm-checkbox label {
      font-size: 14px;
      color: #78350f;
      line-height: 1.4;
    }
    
    /* Sign buttons */
    .sign-buttons {
      display: flex;
      gap: 12px;
    }
    
    .sign-btn {
      flex: 1;
      padding: 14px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .sign-btn.cancel {
      background: #f1f5f9;
      color: #475569;
    }
    
    .sign-btn.confirm {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
    }
    
    .sign-btn.confirm:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }
    
    /* Signed status badge */
    .signed-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: #f0fdf4;
      border: 1px solid #86efac;
      border-radius: 8px;
      margin-bottom: 12px;
    }
    
    .signed-status.pending {
      background: #fffbeb;
      border-color: #fcd34d;
    }
    
    .signed-status-icon {
      font-size: 20px;
    }
    
    .signed-status-text {
      flex: 1;
    }
    
    .signed-status-text strong {
      display: block;
      color: #166534;
      font-size: 14px;
    }
    
    .signed-status.pending .signed-status-text strong {
      color: #92400e;
    }
    
    .signed-status-text span {
      font-size: 12px;
      color: #64748b;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="loading">
      <div class="loading-spinner"></div>
      <p>Loading scorecard...</p>
    </div>
  </div>
  
  <div id="toast" class="toast"></div>
  
  <!-- Sign Scorecard Modal -->
  <div id="sign-modal" class="sign-modal" onclick="closeSignModal(event)">
    <div class="sign-modal-content" onclick="event.stopPropagation()">
      <div class="sign-modal-header">
        <h2>‚úçÔ∏è Sign Scorecard</h2>
        <p>Review and sign to confirm your scores</p>
      </div>
      <div class="sign-modal-body">
        <div id="score-summary" class="score-summary">
          <!-- Filled by JS -->
        </div>
        
        <div id="player-sign-section" class="signature-section">
          <div class="signature-label">Your Signature (Player)</div>
          <div id="player-sig-container" class="signature-pad-container">
            <canvas id="player-signature-pad" class="signature-pad"></canvas>
            <span class="signature-placeholder">Sign here with your finger</span>
            <button class="clear-signature" onclick="clearSignature('player')">√ó</button>
          </div>
        </div>
        
        <div id="marker-sign-section" class="signature-section">
          <div class="signature-label">Marker's Signature (<span id="marker-name-sign">Marker</span>)</div>
          <div id="marker-sig-container" class="signature-pad-container">
            <canvas id="marker-signature-pad" class="signature-pad"></canvas>
            <span class="signature-placeholder">Marker signs here</span>
            <button class="clear-signature" onclick="clearSignature('marker')">√ó</button>
          </div>
        </div>
        
        <div class="confirm-checkbox">
          <input type="checkbox" id="confirm-scores-checkbox">
          <label for="confirm-scores-checkbox">
            I confirm that all scores entered are accurate and agree to the final results. 
            Once signed, the scorecard cannot be modified.
          </label>
        </div>
        
        <div class="sign-buttons">
          <button class="sign-btn cancel" onclick="closeSignModal()">Cancel</button>
          <button id="confirm-sign-btn" class="sign-btn confirm" onclick="confirmAndLockScorecard()" disabled>
            Sign & Lock Scorecard
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
  <script src="../firebase-config.js"></script>

  <script>
    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const roundId = urlParams.get('roundId');
    const playerId = urlParams.get('playerId');

    // App state
    let digitalData = null;
    let playerData = null;
    let marksPlayerData = null; // The player THIS player marks (enters score for)
    let markerPlayerId = null; // The player who marks THIS player (enters score for us)
    let markerScoresForMe = Array(18).fill(null); // What my marker entered for me
    let markerHasLoggedIn = false; // Whether marker has started entering scores
    let currentHole = 1;
    let showingFrontNine = true;
    let scores = {
      player: Array(18).fill(null),
      marksPlayer: Array(18).fill(null) // Score of the player we mark
    };
    
    // Scorecard signing state
    let scorecardStatus = {
      playerSigned: false,
      playerSignature: null,
      playerSignedAt: null,
      markerConfirmed: false,
      markerSignature: null,
      markerSignedAt: null,
      locked: false,
      lockedAt: null
    };

    // ============================================
    // OFFLINE SYNC QUEUE - Silent background sync
    // ============================================
    
    const SYNC_QUEUE_KEY = 'scorecard_sync_queue';
    let isOnline = navigator.onLine;
    let isSyncing = false;
    
    // Get pending sync queue from localStorage
    function getSyncQueue() {
      try {
        const queue = localStorage.getItem(SYNC_QUEUE_KEY);
        return queue ? JSON.parse(queue) : [];
      } catch (e) {
        console.error('Error reading sync queue:', e);
        return [];
      }
    }
    
    // Save sync queue to localStorage
    function saveSyncQueue(queue) {
      try {
        localStorage.setItem(SYNC_QUEUE_KEY, JSON.stringify(queue));
      } catch (e) {
        console.error('Error saving sync queue:', e);
      }
    }
    
    // Add item to sync queue
    function addToSyncQueue(data) {
      const queue = getSyncQueue();
      // Replace existing entry for same roundId/playerId to avoid duplicates
      const existingIndex = queue.findIndex(item => 
        item.roundId === data.roundId && item.playerId === data.playerId
      );
      if (existingIndex >= 0) {
        queue[existingIndex] = data;
      } else {
        queue.push(data);
      }
      saveSyncQueue(queue);
      console.log('üìù Added to sync queue:', data.roundId, data.playerId);
    }
    
    // Process sync queue when online
    async function processSyncQueue() {
      if (!isOnline || isSyncing || !db) return;
      
      const queue = getSyncQueue();
      if (queue.length === 0) return;
      
      isSyncing = true;
      console.log('üîÑ Processing sync queue:', queue.length, 'items');
      
      const successfulSyncs = [];
      
      for (const item of queue) {
        try {
          // Sync digital scores
          await db.ref(`digitalScores/${item.roundId}/${item.playerId}`).set(item.digitalScoresData);
          
          // Sync live scores if available
          if (item.liveScoresData) {
            await db.ref(`liveScores/${item.roundId}/${item.liveScoresKey}`).set(item.liveScoresData);
            await db.ref(`scores/${item.roundId}/${item.liveScoresKey}`).set(item.liveScoresData);
          }
          
          successfulSyncs.push(item);
          console.log('‚úÖ Synced:', item.roundId, item.playerId);
        } catch (err) {
          console.error('‚ùå Sync failed for', item.playerId, ':', err);
          // Keep in queue for retry
        }
      }
      
      // Remove successfully synced items from queue
      if (successfulSyncs.length > 0) {
        const remainingQueue = queue.filter(item => 
          !successfulSyncs.some(s => s.roundId === item.roundId && s.playerId === item.playerId)
        );
        saveSyncQueue(remainingQueue);
        console.log('üì§ Sync complete. Remaining in queue:', remainingQueue.length);
      }
      
      isSyncing = false;
    }
    
    // Listen for online/offline events
    window.addEventListener('online', () => {
      console.log('üåê Back online - syncing pending scores...');
      isOnline = true;
      // Small delay to ensure connection is stable
      setTimeout(processSyncQueue, 1000);
    });
    
    window.addEventListener('offline', () => {
      console.log('üì¥ Gone offline - scores will be queued');
      isOnline = false;
    });
    
    // Periodic sync attempt (every 30 seconds if online)
    setInterval(() => {
      if (isOnline && !isSyncing) {
        processSyncQueue();
      }
    }, 30000);

    // Initialize Firebase
    initFirebase();

    // Calculate finish hole based on starting hole (for shotgun/two-tee starts)
    function getFinishHole(startHole) {
      if (startHole === 1) return 18;
      return startHole - 1; // e.g., start 7 -> finish 6, start 10 -> finish 9
    }

    // Get the sequence of holes in play order
    function getHoleSequence(startHole) {
      const sequence = [];
      for (let i = 0; i < 18; i++) {
        const hole = ((startHole - 1 + i) % 18) + 1;
        sequence.push(hole);
      }
      return sequence;
    }

    // Check if all 18 holes have been entered for a player
    function isRoundComplete(scoresArray) {
      return scoresArray.every(s => s !== null && s !== undefined);
    }

    // Check if current hole is the finish hole
    function isFinishHole(currentHole) {
      const startHole = playerData?.startingHole || 1;
      return currentHole === getFinishHole(startHole);
    }

    // Find who marks this player (reverse lookup)
    function findMarkerForPlayer(players, targetPlayerId) {
      for (const [pid, pdata] of Object.entries(players)) {
        if (pdata.marksPlayerId === targetPlayerId) {
          return pid;
        }
      }
      return null;
    }

    // Get disputes (holes where my score differs from what my marker entered)
    function getDisputes() {
      const disputes = [];
      for (let i = 0; i < 18; i++) {
        const myScore = scores.player[i];
        const markerScore = markerScoresForMe[i];
        // Only flag dispute if both have entered a score and they differ
        if (myScore !== null && markerScore !== null && myScore !== markerScore) {
          disputes.push({
            hole: i + 1,
            myScore: myScore,
            markerScore: markerScore
          });
        }
      }
      return disputes;
    }

    // Check if current hole has a dispute
    function hasDisputeOnHole(holeNumber) {
      const idx = holeNumber - 1;
      const myScore = scores.player[idx];
      const markerScore = markerScoresForMe[idx];
      return myScore !== null && markerScore !== null && myScore !== markerScore;
    }

    // Show toast notification
    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast show ${type}`;
      setTimeout(() => toast.classList.remove('show'), 3000);
    }

    // Load data and initialize
    async function init() {
      if (!roundId || !playerId) {
        showError('Invalid QR code. Missing round or player information.');
        return;
      }

      // Always try to load from Firebase first (has latest data)
      if (db) {
        try {
          console.log('Loading digital scorecard data from Firebase...');
          const dataRef = db.ref(`digitalScorecards/${roundId}`);
          const snapshot = await dataRef.once('value');
          digitalData = snapshot.val();
          
          if (digitalData && digitalData.players) {
            playerData = digitalData.players[playerId];
            
            if (playerData && playerData.marksPlayerId) {
              marksPlayerData = digitalData.players[playerData.marksPlayerId];
            }
            
            // Cache locally for offline use
            const localKey = `digitalScorecard_${roundId}`;
            localStorage.setItem(localKey, JSON.stringify(digitalData));
            console.log('Digital scorecard data loaded from Firebase');
          }
        } catch (err) {
          console.error('Could not load scorecard data from Firebase:', err);
        }
      }

      // Fallback to localStorage if Firebase failed
      if (!digitalData) {
        const localKey = `digitalScorecard_${roundId}`;
        const localData = localStorage.getItem(localKey);
        
        if (localData) {
          console.log('Using cached localStorage data');
          digitalData = JSON.parse(localData);
          playerData = digitalData.players[playerId];
          
          if (playerData && playerData.marksPlayerId) {
            marksPlayerData = digitalData.players[playerData.marksPlayerId];
          }
        }
      }

      // Try to load existing scores from Firebase
      if (db) {
        try {
          const scoresRef = db.ref(`digitalScores/${roundId}/${playerId}`);
          const snapshot = await scoresRef.once('value');
          const savedScores = snapshot.val();
          
          if (savedScores) {
            scores.player = savedScores.playerScores || Array(18).fill(null);
            scores.marksPlayer = savedScores.marksPlayerScores || Array(18).fill(null);
            
            // Load scorecard signing status (check both old and new paths)
            if (savedScores.status) {
              scorecardStatus = savedScores.status;
              console.log('Loaded scorecard status from status:', scorecardStatus);
            } else if (savedScores.scorecardStatus) {
              scorecardStatus = savedScores.scorecardStatus;
              console.log('Loaded scorecard status from scorecardStatus:', scorecardStatus);
            }
          }
        } catch (err) {
          console.log('Could not load scores from Firebase:', err);
        }
      }

      // Also check localStorage for scorecard status (for offline or backup)
      const localStatus = localStorage.getItem(`scorecardStatus_${roundId}_${playerId}`);
      if (localStatus) {
        const parsedStatus = JSON.parse(localStatus);
        // Use local status if it shows locked (could be more recent)
        if (parsedStatus.locked && !scorecardStatus.locked) {
          scorecardStatus = parsedStatus;
          console.log('Loaded locked status from localStorage:', scorecardStatus);
        }
      }

      // Also check localStorage for offline scores
      const offlineScores = localStorage.getItem(`scores_${roundId}_${playerId}`);
      if (offlineScores) {
        const parsed = JSON.parse(offlineScores);
        // Merge with Firebase scores (prefer newer)
        if (parsed.timestamp > (scores.timestamp || 0)) {
          scores.player = parsed.playerScores || scores.player;
          scores.marksPlayer = parsed.marksPlayerScores || scores.marksPlayer;
        }
      }

      if (!playerData) {
        showError('Player not found. Please make sure the tournament staff has generated the digital scorecards.');
        return;
      }

      // Find who marks this player (for dispute detection)
      if (digitalData && digitalData.players) {
        markerPlayerId = findMarkerForPlayer(digitalData.players, playerId);
        console.log('Marker for this player:', markerPlayerId);
        
        // Set up real-time listener for marker's scores
        if (markerPlayerId && db) {
          const markerScoresRef = db.ref(`digitalScores/${roundId}/${markerPlayerId}`);
          markerScoresRef.on('value', (snapshot) => {
            const markerData = snapshot.val();
            if (markerData) {
              // Marker has logged in and started entering scores
              markerHasLoggedIn = true;
              if (markerData.marksPlayerScores) {
                // The marker's "marksPlayerScores" are the scores they entered for ME
                markerScoresForMe = markerData.marksPlayerScores;
                console.log('Updated marker scores for me:', markerScoresForMe);
              }
              // Re-render to show any disputes
              render();
            }
          });
        }
      }

      // Set starting hole based on player's tee assignment
      console.log('Starting hole data:', {
        startingHole: playerData.startingHole,
        groupTee: playerData.groupTee,
        playerData: playerData
      });
      currentHole = playerData.startingHole || 1;

      render();
      
      // Process any pending sync queue (silently in background)
      setTimeout(processSyncQueue, 2000);
    }

    // Check if a player's category allows X score (pickup) - only Stableford types
    function canUsePickup(player) {
      // Debug logging
      console.log('canUsePickup check:', {
        player: player?.firstName,
        category: player?.category,
        categories: digitalData?.categories,
        categoryInfo: player?.category ? digitalData?.categories?.[player.category] : null
      });
      
      if (!player || !player.category || !digitalData.categories) {
        // For now, allow X if we can't determine category (temporary for testing)
        console.log('canUsePickup: allowing X (category data missing)');
        return true;
      }
      const categoryInfo = digitalData.categories[player.category];
      if (!categoryInfo) {
        console.log('canUsePickup: allowing X (category not found in list)');
        return true;
      }
      const type = (categoryInfo.tournamentType || '').toLowerCase();
      const result = type.includes('stableford');
      console.log('canUsePickup result:', result, 'type:', type);
      return result;
    }

    // Calculate strokes for the player we mark on a hole
    function getMarksPlayerStrokes(si) {
      if (!marksPlayerData) return 0;
      // For bracket match play, use matchHcp (difference from lowest PHCP)
      // For regular tournaments, use phcp
      const isBracketMatch = digitalData.isBracketMatch;
      const hcpForStrokes = isBracketMatch ? (parseInt(marksPlayerData.matchHcp) || 0) : (parseInt(marksPlayerData.phcp) || 0);
      let strokes = 0;
      if (hcpForStrokes > 0 && si <= hcpForStrokes) strokes++;
      if (hcpForStrokes > 18 && si <= (hcpForStrokes - 18)) strokes++;
      return strokes;
    }
    
    function showError(message) {
      document.getElementById('app').innerHTML = `
        <div class="error-state">
          <h2>‚ö†Ô∏è Error</h2>
          <p>${message}</p>
        </div>
      `;
    }

    // Render dispute banner if there are disputes
    function renderDisputeBanner() {
      const disputes = getDisputes();
      if (disputes.length === 0) {
        return '';
      }
      
      return `
        <div class="dispute-banner">
          <div class="dispute-icon">‚ö†Ô∏è</div>
          <div class="dispute-content">
            <div class="dispute-title">Score Dispute${disputes.length > 1 ? 's' : ''} Detected!</div>
            <div class="dispute-holes">
              ${disputes.map(d => `<span>Hole ${d.hole}: You=${d.myScore === 'X' ? 'X' : d.myScore}, Marker=${d.markerScore === 'X' ? 'X' : d.markerScore}</span>`).join('')}
            </div>
          </div>
        </div>
      `;
    }
    
    // Render regular player card (non-bracket)
    function renderRegularPlayerCard() {
      return `
        <div class="player-card">
          <h2>${playerData.firstName} ${playerData.lastName}</h2>
          <div class="player-details">
            <span class="detail-item"><span class="label">HCP:</span> ${playerData.hcp || '-'}</span>
            <span class="detail-item"><span class="label">PHCP:</span> ${playerData.phcp || '-'}</span>
            <span class="detail-item"><span class="label">Tee:</span> ${playerData.groupTime || 'TBD'}</span>
            ${playerData.marksPlayerName ? `<span class="detail-item"><span class="label">Marking:</span> <span class="marker-inline">${playerData.marksPlayerName}</span></span>` : ''}
          </div>
        </div>
      `;
    }
    
    // Render bracket match header with both players
    function renderBracketMatchHeader() {
      if (!marksPlayerData) return renderRegularPlayerCard();
      
      const player1Name = `${playerData.firstName} ${playerData.lastName?.charAt(0) || ''}.`;
      const player2Name = `${marksPlayerData.firstName} ${marksPlayerData.lastName?.charAt(0) || ''}.`;
      
      return `
        <div class="bracket-match-card">
          <div class="match-title">${player1Name} <span>VS</span> ${player2Name}</div>
          <div class="players-row">
            <div class="player-side left">
              <div class="player-hcp-info">
                <span class="hcp-row">HCP: ${playerData.hcp || '-'}</span>
                <span class="hcp-row">PHCP: ${playerData.phcp || '-'}</span>
                <span class="hcp-row"><strong>Match HCP: ${playerData.matchHcp || 0}</strong></span>
              </div>
            </div>
            <div class="vs-divider"></div>
            <div class="player-side right">
              <div class="player-hcp-info">
                <span class="hcp-row">HCP: ${marksPlayerData.hcp || '-'}</span>
                <span class="hcp-row">PHCP: ${marksPlayerData.phcp || '-'}</span>
                <span class="hcp-row"><strong>Match HCP: ${marksPlayerData.matchHcp || 0}</strong></span>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Calculate match result for bracket matches
    function calculateMatchResult() {
      if (!digitalData.isBracketMatch || !marksPlayerData) return null;
      
      let playerUp = 0;
      let holesPlayed = 0;
      
      const playerMatchHcp = parseInt(playerData.matchHcp) || 0;
      const opponentMatchHcp = parseInt(marksPlayerData.matchHcp) || 0;
      
      for (let i = 0; i < 18; i++) {
        const playerScore = scores.player[i];
        const opponentScore = scores.marksPlayer[i];
        
        // Skip if either score is missing
        if (playerScore === null || opponentScore === null) continue;
        if (playerScore === 'X' || opponentScore === 'X') continue;
        
        holesPlayed++;
        
        const si = digitalData.strokeIndexes[i] || 99;
        
        // Calculate strokes
        let playerStrokes = 0;
        if (playerMatchHcp > 0) {
          playerStrokes = si <= playerMatchHcp ? 1 : 0;
          if (playerMatchHcp > 18 && si <= (playerMatchHcp - 18)) playerStrokes++;
        }
        
        let opponentStrokes = 0;
        if (opponentMatchHcp > 0) {
          opponentStrokes = si <= opponentMatchHcp ? 1 : 0;
          if (opponentMatchHcp > 18 && si <= (opponentMatchHcp - 18)) opponentStrokes++;
        }
        
        // Net scores
        const playerNet = playerScore - playerStrokes;
        const opponentNet = opponentScore - opponentStrokes;
        
        // Determine hole winner
        if (playerNet < opponentNet) {
          playerUp++;
        } else if (opponentNet < playerNet) {
          playerUp--;
        }
      }
      
      const holesRemaining = 18 - holesPlayed;
      const absUp = Math.abs(playerUp);
      
      // Match is finished when lead > remaining holes
      const isFinished = absUp > holesRemaining && holesPlayed > 0;
      
      // Determine winner
      let winner = null;
      let resultText = '';
      if (isFinished) {
        if (playerUp > 0) {
          winner = 'player';
          resultText = `${playerData.firstName} wins ${absUp} & ${holesRemaining}`;
        } else {
          winner = 'opponent';
          resultText = `${marksPlayerData.firstName} wins ${absUp} & ${holesRemaining}`;
        }
      }
      
      return {
        playerUp,
        holesPlayed,
        holesRemaining,
        isFinished,
        winner,
        resultText
      };
    }

    function render() {
      const hole = currentHole;
      const par = digitalData.pars[hole - 1] || 4;
      const si = digitalData.strokeIndexes[hole - 1] || '-';
      const isLocked = scorecardStatus.locked;
      
      // For bracket match play, use matchHcp (difference from lowest PHCP)
      // For regular tournaments, use phcp
      const isBracketMatch = digitalData.isBracketMatch;
      const playerHcpForStrokes = isBracketMatch ? (parseInt(playerData.matchHcp) || 0) : (parseInt(playerData.phcp) || 0);
      
      // Calculate player's strokes on this hole
      let playerStrokes = 0;
      if (playerHcpForStrokes > 0) {
        playerStrokes = si <= playerHcpForStrokes ? 1 : 0;
        if (playerHcpForStrokes > 18 && si <= (playerHcpForStrokes - 18)) playerStrokes++;
      }

      // Get current scores for this hole
      const playerScore = scores.player[hole - 1];
      const marksPlayerScore = scores.marksPlayer[hole - 1];
      
      // Check if match is finished (for bracket matches)
      const matchResult = isBracketMatch ? calculateMatchResult() : null;
      const isMatchFinished = matchResult && matchResult.isFinished;
      
      // For bracket matches: check if this hole already has scores entered
      // If match is finished and this hole has no scores, block entry
      const holeHasScores = playerScore !== null || marksPlayerScore !== null;
      const blockHoleEntry = isBracketMatch && isMatchFinished && !holeHasScores;

      document.getElementById('app').innerHTML = `
        <div class="header">
          <div class="header-top">
            <h1>üì± Digital Scorecard</h1>
            <span class="live-badge">${isLocked ? 'üîí LOCKED' : '‚óè LIVE'}</span>
          </div>
          <div class="header-info">${digitalData.tournamentName} ‚Ä¢ ${isBracketMatch ? (digitalData.roundName || 'Match') : 'Round ' + (digitalData.roundIndex + 1)}</div>
          ${isBracketMatch && digitalData.courseName ? `<div class="header-course">${digitalData.courseName}${digitalData.teeMenName ? ' ‚Ä¢ ' + digitalData.teeMenName : ''}</div>` : ''}
        </div>
        
        ${renderLockedBanner()}
        ${renderDisputeBanner()}
        
        <div class="container">
          ${isBracketMatch ? renderBracketMatchHeader() : renderRegularPlayerCard()}

          <!-- Current Hole Display (Swipeable) -->
          <div class="current-hole-card" id="hole-card">
            <div class="hole-progress">
              ${renderHoleDots()}
            </div>
            
            <div class="hole-main-content">
              <div class="hole-left">
                <div>
                  <div class="hole-label">Hole</div>
                  <div class="hole-number">${hole}</div>
                </div>
              </div>
              <div class="hole-right">
                <div class="stat-row">
                  <span class="stat-label">Par:</span>
                  <span class="stat-value">${par}</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">S.I:</span>
                  <span class="stat-value">${si}</span>
                </div>
              </div>
            </div>
            
            <div class="stroke-info-row">
              <div class="stroke-item">
                <span>You get</span>
                <span class="stroke-count">${playerStrokes}</span>
                <span>stroke${playerStrokes !== 1 ? 's' : ''}</span>
              </div>
              ${marksPlayerData ? `
                <div class="stroke-item">
                  <span>${marksPlayerData.firstName} gets</span>
                  <span class="stroke-count">${getMarksPlayerStrokes(si)}</span>
                  <span>stroke${getMarksPlayerStrokes(si) !== 1 ? 's' : ''}</span>
                </div>
              ` : ''}
            </div>
            ${renderMatchScore()}
          </div>

          <!-- Score Entry -->
          <div class="score-entry-card" ${isLocked || blockHoleEntry ? 'style="opacity: 0.6; pointer-events: none;"' : ''}>
            ${blockHoleEntry ? `
              <div class="match-over-notice">
                üèÜ Match is over - no scores needed for remaining holes
              </div>
            ` : ''}
            ${hasDisputeOnHole(hole) ? `
              <div class="current-hole-dispute">
                ‚ö†Ô∏è <strong>Dispute!</strong> Your marker entered ${markerScoresForMe[hole - 1] === 'X' ? 'X' : markerScoresForMe[hole - 1]} for you
              </div>
            ` : ''}
            <div class="score-sections-row" ${blockHoleEntry ? 'style="display:none;"' : ''}>
              <!-- Player Score -->
              <div class="score-section">
                <div class="score-section-header">
                  <span class="score-section-title player-title">Your Score</span>
                </div>
                <div class="score-input-row">
                  <button class="score-minus-btn" onclick="adjustScore('player', -1, ${par})" ${isLocked ? 'disabled' : ''}>‚àí</button>
                  <div class="score-display ${getScoreDisplayClass(playerScore, par)}" id="player-score-display">
                    ${playerScore === 'X' ? 'X' : (playerScore != null ? playerScore : '')}
                  </div>
                  <button class="score-plus-btn" onclick="adjustScore('player', 1, ${par})" ${isLocked ? 'disabled' : ''}>+</button>
                </div>
                ${!isLocked && canUsePickup(playerData) ? `<button class="score-pickup-btn" onclick="setPickup('player')">Pickup (X)</button>` : ''}
              </div>

              <!-- Score for player we mark -->
              ${playerData.marksPlayerName ? `
                <div class="score-section">
                  <div class="score-section-header">
                    <span class="score-section-title marker-title">${playerData.marksPlayerName.split(' ')[0]}</span>
                  </div>
                  <div class="score-input-row">
                    <button class="score-minus-btn" onclick="adjustScore('marksPlayer', -1, ${par})" ${isLocked ? 'disabled' : ''}>‚àí</button>
                    <div class="score-display ${getScoreDisplayClass(marksPlayerScore, par)}" id="marksPlayer-score-display">
                      ${marksPlayerScore === 'X' ? 'X' : (marksPlayerScore != null ? marksPlayerScore : '')}
                    </div>
                    <button class="score-plus-btn" onclick="adjustScore('marksPlayer', 1, ${par})" ${isLocked ? 'disabled' : ''}>+</button>
                  </div>
                  ${!isLocked && canUsePickup(marksPlayerData) ? `<button class="score-pickup-btn" onclick="setPickup('marksPlayer')">Pickup (X)</button>` : ''}
                </div>
              ` : ''}
            </div>
          </div>

          <!-- View Scorecard Button -->
          <button class="btn-view-scorecard" onclick="openScorecard()">
            üìã View Full Scorecard
          </button>
        </div>

        <!-- Save Bar - transforms based on state -->
        ${renderSaveBar()}

        <!-- Full Scorecard Modal -->
        <div id="scorecard-modal" class="modal-overlay" onclick="closeModal(event)">
          <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2>Full Scorecard</h2>
              <button class="modal-close" onclick="closeScorecard()">√ó</button>
            </div>
            <div class="modal-body">
              ${renderFullScorecard()}
            </div>
          </div>
        </div>
      `;
      
      // Setup swipe gestures after render
      setupSwipeGestures();
    }

    function renderHoleDots() {
      let html = '';
      for (let i = 1; i <= 18; i++) {
        const hasScore = scores.player[i - 1] !== null;
        const isActive = i === currentHole;
        const hasDispute = hasDisputeOnHole(i);
        html += `<span class="hole-dot ${isActive ? 'active' : ''} ${hasScore ? 'has-score' : ''} ${hasDispute ? 'dispute' : ''}"></span>`;
      }
      return html;
    }
    
    // Calculate and render match score for bracket match play
    function renderMatchScore() {
      // Only show for bracket match play tournaments
      if (!digitalData.isBracketMatch) return '';
      if (!marksPlayerData) return '';
      
      // Calculate match score based on holes played
      let playerUp = 0;
      let holesPlayed = 0;
      
      // For bracket match play, use matchHcp (difference) instead of phcp
      const playerMatchHcp = parseInt(playerData.matchHcp) || 0;
      const opponentMatchHcp = parseInt(marksPlayerData.matchHcp) || 0;
      
      for (let i = 0; i < 18; i++) {
        const playerScore = scores.player[i];
        const opponentScore = scores.marksPlayer[i];
        
        // Skip if either score is missing
        if (playerScore === null || opponentScore === null) continue;
        if (playerScore === 'X' || opponentScore === 'X') continue;
        
        holesPlayed++;
        
        const si = digitalData.strokeIndexes[i] || 99;
        
        // Calculate strokes given on this hole using matchHcp
        let playerStrokes = 0;
        if (playerMatchHcp > 0) {
          playerStrokes = si <= playerMatchHcp ? 1 : 0;
          if (playerMatchHcp > 18 && si <= (playerMatchHcp - 18)) playerStrokes++;
        }
        
        let opponentStrokes = 0;
        if (opponentMatchHcp > 0) {
          opponentStrokes = si <= opponentMatchHcp ? 1 : 0;
          if (opponentMatchHcp > 18 && si <= (opponentMatchHcp - 18)) opponentStrokes++;
        }
        
        // Net scores
        const playerNet = playerScore - playerStrokes;
        const opponentNet = opponentScore - opponentStrokes;
        
        // Determine hole winner
        if (playerNet < opponentNet) {
          playerUp++;
        } else if (opponentNet < playerNet) {
          playerUp--;
        }
      }
      
      const holesRemaining = 18 - holesPlayed;
      const playerName = playerData.firstName || 'You';
      const opponentName = marksPlayerData.firstName || 'Opponent';
      
      // Determine match status
      let statusText = '';
      let arrowHtml = '';
      let statusClass = '';
      let leadingPlayerClass = '';
      let trailingPlayerClass = '';
      
      if (playerUp === 0) {
        statusText = 'ALL SQUARE';
        statusClass = 'all-square';
      } else if (playerUp > 0) {
        statusText = `${playerUp} UP`;
        arrowHtml = '<span class="arrow left">‚û§</span>';
        leadingPlayerClass = 'leading';
      } else {
        statusText = `${Math.abs(playerUp)} UP`;
        arrowHtml = '<span class="arrow">‚û§</span>';
        trailingPlayerClass = 'leading';
      }
      
      // Check if match is dormie or won
      let isMatchWon = false;
      if (holesPlayed > 0 && Math.abs(playerUp) > holesRemaining && holesRemaining > 0) {
        statusText = `${Math.abs(playerUp)} & ${holesRemaining}`;
        isMatchWon = true;
        statusClass = 'match-won';
      } else if (holesRemaining === 0 && playerUp !== 0) {
        statusText = `${Math.abs(playerUp)} UP`;
      }
      
      return `
        <div class="match-score-display">
          <div class="player-side ${leadingPlayerClass}">${playerName}</div>
          <div class="match-status ${statusClass}">
            ${playerUp > 0 ? arrowHtml : ''}
            <span>${statusText}</span>
            ${playerUp < 0 ? arrowHtml : ''}
          </div>
          <div class="player-side ${trailingPlayerClass}">${opponentName}</div>
        </div>
      `;
    }

    // Swipe gesture handling
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    
    function setupSwipeGestures() {
      const holeCard = document.getElementById('hole-card');
      if (!holeCard) return;
      
      holeCard.addEventListener('touchstart', handleTouchStart, { passive: true });
      holeCard.addEventListener('touchmove', handleTouchMove, { passive: true });
      holeCard.addEventListener('touchend', handleTouchEnd, { passive: true });
      
      // Also allow clicking on arrows
      holeCard.addEventListener('click', handleCardClick);
    }
    
    function handleTouchStart(e) {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }
    
    function handleTouchMove(e) {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
    }
    
    function handleTouchEnd(e) {
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      
      // Only trigger swipe if horizontal movement is greater than vertical (and > 50px)
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
        if (deltaX > 0) {
          // Swipe right = previous hole
          goToPreviousHole();
        } else {
          // Swipe left = next hole
          goToNextHole();
        }
      }
    }
    
    function handleCardClick(e) {
      const card = document.getElementById('hole-card');
      const rect = card.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const cardWidth = rect.width;
      
      // Click on left 20% = previous, right 20% = next
      if (clickX < cardWidth * 0.2) {
        goToPreviousHole();
      } else if (clickX > cardWidth * 0.8) {
        goToNextHole();
      }
    }
    
    function goToNextHole() {
      // Wrap around: 18 -> 1
      if (currentHole === 18) {
        currentHole = 1;
        showingFrontNine = true;
      } else {
        currentHole++;
        if (currentHole === 10) {
          showingFrontNine = false;
        }
      }
      render();
    }
    
    function goToPreviousHole() {
      // Wrap around: 1 -> 18
      if (currentHole === 1) {
        currentHole = 18;
        showingFrontNine = false;
      } else {
        currentHole--;
        if (currentHole === 9) {
          showingFrontNine = true;
        }
      }
      render();
    }

    function getScoreDisplayClass(score, par) {
      if (score === null || score === undefined) return '';
      if (score === 'X') return 'pickup';
      const diff = score - par;
      if (diff <= -2) return 'eagle';
      if (diff === -1) return 'birdie';
      if (diff === 0) return 'par';
      if (diff === 1) return 'bogey';
      return 'double';
    }

    function setPickup(type) {
      const holeIndex = currentHole - 1;
      scores[type][holeIndex] = 'X';
      
      // Update the display immediately
      const displayId = type === 'player' ? 'player-score-display' : 'marksPlayer-score-display';
      const displayEl = document.getElementById(displayId);
      if (displayEl) {
        displayEl.textContent = 'X';
        displayEl.className = 'score-display pickup';
      }
      
      // Update hole dots
      const dotsContainer = document.querySelector('.hole-progress');
      if (dotsContainer) {
        dotsContainer.innerHTML = renderHoleDots();
      }
      
      // Save to localStorage
      saveScoresToStorage();
    }

    function adjustScore(type, delta, par) {
      const holeIndex = currentHole - 1;
      const currentScore = scores[type][holeIndex];
      
      let newScore;
      if (currentScore === null || currentScore === undefined || currentScore === 'X') {
        // First tap or after X: set to par
        newScore = par;
      } else {
        // Subsequent taps: adjust by delta
        newScore = currentScore + delta;
        // If going below 1, clear the score (set to null)
        if (newScore < 1) {
          newScore = null;
        }
        // Maximum reasonable score is par + 8
        if (newScore !== null && newScore > par + 8) newScore = par + 8;
      }
      
      scores[type][holeIndex] = newScore;
      
      // Save to localStorage
      saveScoresToStorage();
      
      // For bracket matches, do a full re-render to update match score and save bar
      if (digitalData.isBracketMatch) {
        render();
        return;
      }
      
      // For non-bracket matches, update the display immediately without full re-render
      const displayId = type === 'player' ? 'player-score-display' : 'marksPlayer-score-display';
      const displayEl = document.getElementById(displayId);
      if (displayEl) {
        displayEl.textContent = newScore !== null ? newScore : '';
        displayEl.className = 'score-display ' + getScoreDisplayClass(newScore, par);
      }
      
      // Update hole dots
      const dotsContainer = document.querySelector('.hole-progress');
      if (dotsContainer) {
        dotsContainer.innerHTML = renderHoleDots();
      }
    }

    function renderScoreButtons(type, par, currentScore) {
      const scores_to_show = [];
      
      // Eagle or better (par - 2 or less)
      for (let s = Math.max(1, par - 3); s <= par - 2; s++) {
        scores_to_show.push({ value: s, label: s <= par - 2 ? 'Eagle' : '', class: 'eagle' });
      }
      
      // Birdie
      scores_to_show.push({ value: par - 1, label: 'Birdie', class: 'birdie' });
      
      // Par
      scores_to_show.push({ value: par, label: 'Par', class: 'par' });
      
      // Bogey
      scores_to_show.push({ value: par + 1, label: 'Bogey', class: 'bogey' });
      
      // Double+
      for (let s = par + 2; s <= par + 4; s++) {
        scores_to_show.push({ value: s, label: s === par + 2 ? 'Double' : '', class: 'double' });
      }
      
      return scores_to_show.map(s => `
        <button class="score-btn ${s.class} ${currentScore === s.value ? 'selected' : ''}"
                onclick="setScore('${type}', ${s.value})">
          ${s.value}
          ${s.label ? `<span class="score-label">${s.label}</span>` : ''}
        </button>
      `).join('');
    }

    function renderFullScorecard() {
      const pars = digitalData.pars;
      const sis = digitalData.strokeIndexes;
      const isBracketMatch = digitalData.isBracketMatch;
      
      // Helper to calculate strokes received on a hole for a player
      function getStrokesOnHole(matchHcp, holeIndex) {
        const si = sis[holeIndex] || 18;
        let strokes = 0;
        if (matchHcp > 0 && si <= matchHcp) strokes++;
        if (matchHcp > 18 && si <= (matchHcp - 18)) strokes++;
        return strokes;
      }
      
      // For bracket matches, use matchHcp; otherwise use phcp
      const playerMatchHcp = isBracketMatch ? (parseInt(playerData.matchHcp) || 0) : (parseInt(playerData.phcp) || 0);
      const opponentMatchHcp = isBracketMatch ? (parseInt(marksPlayerData?.matchHcp) || 0) : (parseInt(marksPlayerData?.phcp) || 0);
      
      // Helper to get score value for totals (X = net double bogey)
      function getScoreForTotal(score, par, strokes) {
        if (score === null || score === undefined) return null;
        if (score === 'X') {
          return par + 2 + strokes;
        }
        return score;
      }
      
      // Calculate running match score for each hole
      function calculateRunningMatchScore(upToHole) {
        let playerUp = 0;
        for (let i = 0; i <= upToHole; i++) {
          const playerScore = scores.player[i];
          const opponentScore = scores.marksPlayer[i];
          
          if (playerScore === null || opponentScore === null) continue;
          if (playerScore === 'X' || opponentScore === 'X') continue;
          
          const playerStrokes = getStrokesOnHole(playerMatchHcp, i);
          const opponentStrokes = getStrokesOnHole(opponentMatchHcp, i);
          
          const playerNet = playerScore - playerStrokes;
          const opponentNet = opponentScore - opponentStrokes;
          
          if (playerNet < opponentNet) playerUp++;
          else if (opponentNet < playerNet) playerUp--;
        }
        return playerUp;
      }
      
      // Get match status text for a hole
      function getMatchStatusForHole(holeIndex) {
        const playerScore = scores.player[holeIndex];
        const opponentScore = scores.marksPlayer[holeIndex];
        
        // If no scores yet, return empty
        if (playerScore === null || opponentScore === null) return '';
        if (playerScore === 'X' || opponentScore === 'X') return '-';
        
        const matchScore = calculateRunningMatchScore(holeIndex);
        
        if (matchScore === 0) return 'AS';
        if (matchScore > 0) return `${matchScore}‚Üë`;
        return `${Math.abs(matchScore)}‚Üì`;
      }
      
      // Calculate totals
      let front9Par = 0, back9Par = 0;
      let front9Player = 0, back9Player = 0;
      let front9MarksPlayer = 0, back9MarksPlayer = 0;
      let front9PlayerCount = 0, back9PlayerCount = 0;
      let front9MarksPlayerCount = 0, back9MarksPlayerCount = 0;
      
      for (let i = 0; i < 9; i++) {
        front9Par += pars[i] || 0;
        const playerScoreVal = getScoreForTotal(scores.player[i], pars[i] || 4, getStrokesOnHole(playerMatchHcp, i));
        if (playerScoreVal !== null) {
          front9Player += playerScoreVal;
          front9PlayerCount++;
        }
        const marksPlayerScoreVal = getScoreForTotal(scores.marksPlayer[i], pars[i] || 4, getStrokesOnHole(opponentMatchHcp, i));
        if (marksPlayerScoreVal !== null) {
          front9MarksPlayer += marksPlayerScoreVal;
          front9MarksPlayerCount++;
        }
      }
      
      for (let i = 9; i < 18; i++) {
        back9Par += pars[i] || 0;
        const playerScoreVal = getScoreForTotal(scores.player[i], pars[i] || 4, getStrokesOnHole(playerMatchHcp, i));
        if (playerScoreVal !== null) {
          back9Player += playerScoreVal;
          back9PlayerCount++;
        }
        const marksPlayerScoreVal = getScoreForTotal(scores.marksPlayer[i], pars[i] || 4, getStrokesOnHole(opponentMatchHcp, i));
        if (marksPlayerScoreVal !== null) {
          back9MarksPlayer += marksPlayerScoreVal;
          back9MarksPlayerCount++;
        }
      }

      function getScoreClass(score, par) {
        if (score === null || score === undefined) return '';
        if (score === 'X') return 'pickup';
        const diff = score - par;
        if (diff <= -2) return 'eagle';
        if (diff === -1) return 'birdie';
        if (diff === 0) return 'par';
        if (diff === 1) return 'bogey';
        return 'double';
      }
      
      function displayScore(score) {
        if (score === null || score === undefined) return '';
        if (score === 'X') return 'X';
        return score;
      }
      
      // Get match status class
      function getMatchStatusClass(holeIndex) {
        const status = getMatchStatusForHole(holeIndex);
        if (status.includes('‚Üë')) return 'match-up';
        if (status.includes('‚Üì')) return 'match-down';
        if (status === 'AS') return 'match-square';
        return '';
      }

      let html = '<div style="overflow-x: auto;">';
      
      // For bracket matches, show match play format
      if (isBracketMatch && marksPlayerData) {
        // Front 9 table - Match Play format
        html += `
          <table class="scorecard-table match-play-table" style="margin-bottom: 16px;">
            <thead>
              <tr>
                <th style="text-align: left; min-width: 70px;">Hole</th>
                ${[1,2,3,4,5,6,7,8,9].map(h => `<th>${h}</th>`).join('')}
                <th class="total-cell">Out</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="row-label">Par</td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td>${pars[i] || ''}</td>`).join('')}
                <td class="total-cell">${front9Par}</td>
              </tr>
              <tr>
                <td class="row-label">S.I.</td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td>${sis[i] || ''}</td>`).join('')}
                <td class="total-cell"></td>
              </tr>
              <tr class="separator-row"><td colspan="11"></td></tr>
              <tr>
                <td class="row-label player-label">${playerData.firstName} <span class="hcp-badge">${playerMatchHcp}</span></td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td class="score-cell ${getScoreClass(scores.player[i], pars[i])}">${displayScore(scores.player[i])}${getStrokesOnHole(playerMatchHcp, i) > 0 ? '<span class="stroke-dot">‚Ä¢</span>' : ''}</td>`).join('')}
                <td class="total-cell">${front9PlayerCount > 0 ? front9Player : '-'}</td>
              </tr>
              <tr class="match-status-row">
                <td class="row-label match-label">Match</td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td class="match-cell ${getMatchStatusClass(i)}">${getMatchStatusForHole(i)}</td>`).join('')}
                <td class="total-cell"></td>
              </tr>
              <tr>
                <td class="row-label opponent-label">${marksPlayerData.firstName} <span class="hcp-badge">${opponentMatchHcp}</span></td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td class="score-cell ${getScoreClass(scores.marksPlayer[i], pars[i])}">${displayScore(scores.marksPlayer[i])}${getStrokesOnHole(opponentMatchHcp, i) > 0 ? '<span class="stroke-dot">‚Ä¢</span>' : ''}</td>`).join('')}
                <td class="total-cell">${front9MarksPlayerCount > 0 ? front9MarksPlayer : '-'}</td>
              </tr>
            </tbody>
          </table>
        `;
        
        // Back 9 table - Match Play format
        const finalMatchScore = calculateRunningMatchScore(17);
        let finalMatchText = 'AS';
        if (finalMatchScore > 0) finalMatchText = `${finalMatchScore} UP`;
        else if (finalMatchScore < 0) finalMatchText = `${Math.abs(finalMatchScore)} DN`;
        
        html += `
          <table class="scorecard-table match-play-table">
            <thead>
              <tr>
                <th style="text-align: left; min-width: 70px;">Hole</th>
                ${[10,11,12,13,14,15,16,17,18].map(h => `<th>${h}</th>`).join('')}
                <th class="total-cell">In</th>
                <th class="total-cell">Tot</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="row-label">Par</td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td>${pars[i] || ''}</td>`).join('')}
                <td class="total-cell">${back9Par}</td>
                <td class="total-cell">${front9Par + back9Par}</td>
              </tr>
              <tr>
                <td class="row-label">S.I.</td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td>${sis[i] || ''}</td>`).join('')}
                <td class="total-cell"></td>
                <td class="total-cell"></td>
              </tr>
              <tr class="separator-row"><td colspan="12"></td></tr>
              <tr>
                <td class="row-label player-label">${playerData.firstName} <span class="hcp-badge">${playerMatchHcp}</span></td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td class="score-cell ${getScoreClass(scores.player[i], pars[i])}">${displayScore(scores.player[i])}${getStrokesOnHole(playerMatchHcp, i) > 0 ? '<span class="stroke-dot">‚Ä¢</span>' : ''}</td>`).join('')}
                <td class="total-cell">${back9PlayerCount > 0 ? back9Player : '-'}</td>
                <td class="total-cell">${(front9PlayerCount + back9PlayerCount) > 0 ? front9Player + back9Player : '-'}</td>
              </tr>
              <tr class="match-status-row">
                <td class="row-label match-label">Match</td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td class="match-cell ${getMatchStatusClass(i)}">${getMatchStatusForHole(i)}</td>`).join('')}
                <td class="total-cell match-final ${finalMatchScore > 0 ? 'match-up' : finalMatchScore < 0 ? 'match-down' : 'match-square'}">${finalMatchText}</td>
                <td class="total-cell"></td>
              </tr>
              <tr>
                <td class="row-label opponent-label">${marksPlayerData.firstName} <span class="hcp-badge">${opponentMatchHcp}</span></td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td class="score-cell ${getScoreClass(scores.marksPlayer[i], pars[i])}">${displayScore(scores.marksPlayer[i])}${getStrokesOnHole(opponentMatchHcp, i) > 0 ? '<span class="stroke-dot">‚Ä¢</span>' : ''}</td>`).join('')}
                <td class="total-cell">${back9MarksPlayerCount > 0 ? back9MarksPlayer : '-'}</td>
                <td class="total-cell">${(front9MarksPlayerCount + back9MarksPlayerCount) > 0 ? front9MarksPlayer + back9MarksPlayer : '-'}</td>
              </tr>
            </tbody>
          </table>
        `;
      } else {
        // Regular stroke play format for non-bracket matches
        html += `
          <table class="scorecard-table" style="margin-bottom: 16px;">
            <thead>
              <tr>
                <th style="text-align: left; min-width: 60px;">Hole</th>
                ${[1,2,3,4,5,6,7,8,9].map(h => `<th>${h}</th>`).join('')}
                <th class="total-cell">Out</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="row-label">Par</td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td>${pars[i] || ''}</td>`).join('')}
                <td class="total-cell">${front9Par}</td>
              </tr>
              <tr>
                <td class="row-label">S.I.</td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td>${sis[i] || ''}</td>`).join('')}
                <td class="total-cell"></td>
              </tr>
              <tr class="separator-row"><td colspan="11"></td></tr>
              <tr>
                <td class="row-label" style="color: #059669; font-weight: 700;">${playerData.firstName}</td>
                ${[0,1,2,3,4,5,6,7,8].map(i => `<td class="score-cell ${getScoreClass(scores.player[i], pars[i])}">${displayScore(scores.player[i])}</td>`).join('')}
                <td class="total-cell">${front9PlayerCount > 0 ? front9Player : '-'}</td>
              </tr>
              ${playerData.marksPlayerName ? `
                <tr>
                  <td class="row-label" style="color: #3b82f6; font-weight: 700;">${marksPlayerData?.firstName || 'Marked'}</td>
                  ${[0,1,2,3,4,5,6,7,8].map(i => `<td class="score-cell ${getScoreClass(scores.marksPlayer[i], pars[i])}">${displayScore(scores.marksPlayer[i])}</td>`).join('')}
                  <td class="total-cell">${front9MarksPlayerCount > 0 ? front9MarksPlayer : '-'}</td>
                </tr>
              ` : ''}
            </tbody>
          </table>
        `;
        
        // Back 9 table
        html += `
          <table class="scorecard-table">
            <thead>
              <tr>
                <th style="text-align: left; min-width: 60px;">Hole</th>
                ${[10,11,12,13,14,15,16,17,18].map(h => `<th>${h}</th>`).join('')}
                <th class="total-cell">In</th>
                <th class="total-cell">Tot</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="row-label">Par</td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td>${pars[i] || ''}</td>`).join('')}
                <td class="total-cell">${back9Par}</td>
                <td class="total-cell">${front9Par + back9Par}</td>
              </tr>
              <tr>
                <td class="row-label">S.I.</td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td>${sis[i] || ''}</td>`).join('')}
                <td class="total-cell"></td>
                <td class="total-cell"></td>
              </tr>
              <tr class="separator-row"><td colspan="12"></td></tr>
              <tr>
                <td class="row-label" style="color: #059669; font-weight: 700;">${playerData.firstName}</td>
                ${[9,10,11,12,13,14,15,16,17].map(i => `<td class="score-cell ${getScoreClass(scores.player[i], pars[i])}">${displayScore(scores.player[i])}</td>`).join('')}
                <td class="total-cell">${back9PlayerCount > 0 ? back9Player : '-'}</td>
                <td class="total-cell">${(front9PlayerCount + back9PlayerCount) > 0 ? front9Player + back9Player : '-'}</td>
              </tr>
              ${playerData.marksPlayerName ? `
                <tr>
                  <td class="row-label" style="color: #3b82f6; font-weight: 700;">${marksPlayerData?.firstName || 'Marked'}</td>
                  ${[9,10,11,12,13,14,15,16,17].map(i => `<td class="score-cell ${getScoreClass(scores.marksPlayer[i], pars[i])}">${displayScore(scores.marksPlayer[i])}</td>`).join('')}
                  <td class="total-cell">${back9MarksPlayerCount > 0 ? back9MarksPlayer : '-'}</td>
                  <td class="total-cell">${(front9MarksPlayerCount + back9MarksPlayerCount) > 0 ? front9MarksPlayer + back9MarksPlayer : '-'}</td>
                </tr>
              ` : ''}
            </tbody>
          </table>
        `;
      }
      
      html += '</div>';
      return html;
    }

    // Sync scores to liveScores for leaderboard display
    function syncToLiveScores(targetPlayerId, targetPlayerData, scoresArray) {
      if (!targetPlayerId || !targetPlayerData) {
        console.log('syncToLiveScores: missing data', { targetPlayerId, targetPlayerData: !!targetPlayerData });
        return null;
      }
      
      // Convert scores array to liveScores format (convert null to empty string)
      const holesArray = scoresArray.map(s => {
        if (s === null || s === undefined) return '';
        if (s === 'X') return 'X'; // Keep X for pickup
        return s;
      });
      
      // Create player key (same format as live_scoring.html uses)
      const playerKey = targetPlayerData.reg || targetPlayerData.playerId || 
                        `${targetPlayerData.firstName}-${targetPlayerData.lastName}`;
      
      console.log('syncToLiveScores:', {
        roundId: roundId,
        playerKey: playerKey,
        holesArray: holesArray
      });
      
      const liveScoreData = {
        holes: holesArray,
        firstName: targetPlayerData.firstName,
        lastName: targetPlayerData.lastName,
        club: targetPlayerData.club || targetPlayerData.homeClub || '',
        hcp: targetPlayerData.hcp || 0,
        playingHcp: targetPlayerData.phcp || targetPlayerData.playingHcp || targetPlayerData.hcp || 0,
        categories: targetPlayerData.categories ? [targetPlayerData.categories] : 
                    (targetPlayerData.category ? [targetPlayerData.category] : []),
        lastUpdated: new Date().toISOString(),
        scoredBy: 'digital-scorecard',
        scoredByPlayer: `${playerData.firstName} ${playerData.lastName}`
      };
      
      return { playerKey, liveScoreData };
    }
    
    // Attempt to sync to Firebase, queue if offline
    async function trySyncToFirebase(digitalScoresData, liveScoresInfo) {
      const syncData = {
        roundId: roundId,
        playerId: playerId,
        digitalScoresData: digitalScoresData,
        liveScoresKey: liveScoresInfo?.playerKey,
        liveScoresData: liveScoresInfo?.liveScoreData,
        timestamp: Date.now()
      };
      
      if (!isOnline || !db) {
        // Queue for later sync
        addToSyncQueue(syncData);
        console.log('üì¥ Offline - queued for sync');
        return false;
      }
      
      try {
        // Save digital scorecard data
        await db.ref(`digitalScores/${roundId}/${playerId}`).set(digitalScoresData);
        console.log('‚úÖ Digital scores synced');
        
        // Sync to live leaderboard
        if (liveScoresInfo) {
          await db.ref(`liveScores/${roundId}/${liveScoresInfo.playerKey}`).set(liveScoresInfo.liveScoreData);
          await db.ref(`scores/${roundId}/${liveScoresInfo.playerKey}`).set(liveScoresInfo.liveScoreData);
          console.log('‚úÖ Live scores synced');
        }
        
        return true;
      } catch (err) {
        console.error('‚ùå Firebase sync error:', err);
        // Queue for retry
        addToSyncQueue(syncData);
        return false;
      }
    }

    function saveScoresToStorage() {
      // Always save to localStorage first (instant, reliable)
      const offlineData = {
        playerScores: scores.player,
        marksPlayerScores: scores.marksPlayer,
        timestamp: Date.now()
      };
      localStorage.setItem(`scores_${roundId}_${playerId}`, JSON.stringify(offlineData));

      // Prepare data for Firebase
      const digitalScoresData = {
        playerScores: scores.player,
        marksPlayerScores: scores.marksPlayer,
        playerId: playerId,
        playerName: `${playerData.firstName} ${playerData.lastName}`,
        marksPlayerId: playerData.marksPlayerId,
        marksPlayerName: playerData.marksPlayerName,
        lastUpdated: Date.now()
      };
      
      // Get live scores data
      const liveScoresInfo = syncToLiveScores(playerId, playerData, scores.player);
      
      // Try to sync (will queue if offline)
      trySyncToFirebase(digitalScoresData, liveScoresInfo);
    }

    function setScore(type, value) {
      scores[type][currentHole - 1] = value;
      render();
    }

    async function saveAndNext() {
      // Always save to localStorage first (instant, reliable)
      const offlineData = {
        playerScores: scores.player,
        marksPlayerScores: scores.marksPlayer,
        timestamp: Date.now()
      };
      localStorage.setItem(`scores_${roundId}_${playerId}`, JSON.stringify(offlineData));

      // Prepare data for Firebase
      const digitalScoresData = {
        playerScores: scores.player,
        marksPlayerScores: scores.marksPlayer,
        playerId: playerId,
        playerReg: playerData.reg || playerId,
        playerHcp: playerData.handicap || playerData.hcp || 0,
        playerName: `${playerData.firstName} ${playerData.lastName}`,
        marksPlayerId: playerData.marksPlayerId,
        marksPlayerName: playerData.marksPlayerName,
        lastUpdated: Date.now()
      };
      
      // Get live scores data
      const liveScoresInfo = syncToLiveScores(playerId, playerData, scores.player);
      
      // Try to sync (will queue if offline)
      await trySyncToFirebase(digitalScoresData, liveScoresInfo);
      
      // Always show success - user doesn't need to know about offline queue
      showToast('Score saved!', 'success');

      // Move to next hole (with wrap-around)
      if (currentHole === 18) {
        currentHole = 1;
        showingFrontNine = true;
      } else {
        currentHole++;
        if (currentHole === 10) {
          showingFrontNine = false;
        }
      }
      render();
      
      // Check if all holes are now complete
      if (isRoundComplete(scores.player)) {
        showToast('All 18 holes completed! üéâ', 'success');
      }
    }
    
    // Finish and lock bracket match when match is decided
    async function finishBracketMatch() {
      const matchResult = calculateMatchResult();
      if (!matchResult || !matchResult.isFinished) {
        showToast('Match is not yet decided', 'error');
        return;
      }
      
      // Save current scores first
      const offlineData = {
        playerScores: scores.player,
        marksPlayerScores: scores.marksPlayer,
        timestamp: Date.now()
      };
      localStorage.setItem(`scores_${roundId}_${playerId}`, JSON.stringify(offlineData));

      // Determine winner player data
      const winnerId = matchResult.winner === 'player' ? playerId : playerData.marksPlayerId;
      const winnerData = matchResult.winner === 'player' ? playerData : marksPlayerData;

      // Prepare data for Firebase
      const digitalScoresData = {
        playerScores: scores.player,
        marksPlayerScores: scores.marksPlayer,
        playerId: playerId,
        playerReg: playerData.reg || playerId,
        playerHcp: playerData.handicap || playerData.hcp || 0,
        playerName: `${playerData.firstName} ${playerData.lastName}`,
        marksPlayerId: playerData.marksPlayerId,
        marksPlayerName: playerData.marksPlayerName,
        lastUpdated: Date.now(),
        matchFinished: true,
        matchResult: {
          winner: winnerId,
          winnerName: `${winnerData.firstName} ${winnerData.lastName}`,
          resultText: matchResult.resultText,
          holesPlayed: matchResult.holesPlayed
        }
      };
      
      // Get live scores data
      const liveScoresInfo = syncToLiveScores(playerId, playerData, scores.player);
      
      // Sync to Firebase
      await trySyncToFirebase(digitalScoresData, liveScoresInfo);
      
      // Update bracket with winner and advance to next round
      await updateBracketWithWinner(winnerId, winnerData, matchResult);
      
      // Lock the scorecard
      scorecardStatus.locked = true;
      scorecardStatus.lockedAt = Date.now();
      scorecardStatus.matchFinished = true;
      scorecardStatus.matchResult = matchResult;
      
      // Save status
      try {
        if (db) {
          await db.ref(`digitalScores/${roundId}/${playerId}/status`).set({
            locked: true,
            lockedAt: scorecardStatus.lockedAt,
            matchFinished: true,
            matchResult: matchResult
          });
        }
      } catch (err) {
        console.error('Error saving match status:', err);
      }
      
      localStorage.setItem(`scorecardStatus_${roundId}_${playerId}`, JSON.stringify(scorecardStatus));
      
      showToast(`Match Complete! ${matchResult.resultText}`, 'success');
      render();
    }
    
    // Update the bracket data with the match winner and advance them
    async function updateBracketWithWinner(winnerId, winnerData, matchResult) {
      if (!db || !digitalData.matchId || !digitalData.tournamentId) {
        console.log('Cannot update bracket - missing data');
        return;
      }
      
      try {
        // Fetch current tournament data from Firebase
        const tournamentRef = db.ref(`tournaments/${digitalData.tournamentId}`);
        const snapshot = await tournamentRef.once('value');
        const tournament = snapshot.val();
        
        if (!tournament || !tournament.bracketData) {
          console.error('Tournament or bracket data not found');
          return;
        }
        
        const bracketData = tournament.bracketData;
        const matchId = digitalData.matchId;
        
        // Create minimal winner object for bracket
        const winnerForBracket = {
          firstName: winnerData.firstName,
          lastName: winnerData.lastName,
          id: winnerId,
          reg: winnerData.reg || winnerId,
          hcp: winnerData.hcp
        };
        
        // Parse matchId to find the match and update it
        if (matchId.startsWith('prequal-')) {
          const idx = parseInt(matchId.split('-')[1]);
          if (bracketData.preQualMatches && bracketData.preQualMatches[idx]) {
            const match = bracketData.preQualMatches[idx];
            match.winner = winnerId;
            match.matchResult = matchResult.resultText;
            
            // Advance to main bracket first round
            const targetSlot = match.targetSlot;
            if (targetSlot && bracketData.mainBracket && bracketData.mainBracket[0]) {
              const matchNum = Math.floor((targetSlot - 1) / 2);
              const slotNum = (targetSlot - 1) % 2;
              
              if (bracketData.mainBracket[0].matches[matchNum]) {
                if (slotNum === 0) {
                  bracketData.mainBracket[0].matches[matchNum].player1 = winnerForBracket;
                } else {
                  bracketData.mainBracket[0].matches[matchNum].player2 = winnerForBracket;
                }
              }
            }
          }
        } else if (matchId.startsWith('round-')) {
          const parts = matchId.split('-');
          const roundIdx = parseInt(parts[1]);
          const matchIdx = parseInt(parts[2]);
          
          if (bracketData.mainBracket && bracketData.mainBracket[roundIdx] && 
              bracketData.mainBracket[roundIdx].matches[matchIdx]) {
            const match = bracketData.mainBracket[roundIdx].matches[matchIdx];
            match.winner = winnerId;
            match.matchResult = matchResult.resultText;
            
            // Advance to next round (if not final)
            if (roundIdx < bracketData.mainBracket.length - 1) {
              const nextMatchNum = Math.floor(matchIdx / 2);
              const nextSlot = matchIdx % 2;
              
              const nextRound = bracketData.mainBracket[roundIdx + 1];
              if (nextRound && nextRound.matches[nextMatchNum]) {
                if (nextSlot === 0) {
                  nextRound.matches[nextMatchNum].player1 = winnerForBracket;
                } else {
                  nextRound.matches[nextMatchNum].player2 = winnerForBracket;
                }
              }
            }
          }
        }
        
        // Save updated bracket to Firebase
        await tournamentRef.child('bracketData').set(bracketData);
        
        // Also update localStorage for offline access
        try {
          const tournaments = JSON.parse(localStorage.getItem('tournaments') || '[]');
          const tournamentIdx = tournaments.findIndex(t => t.tournamentId === digitalData.tournamentId);
          if (tournamentIdx >= 0) {
            tournaments[tournamentIdx].bracketData = bracketData;
            localStorage.setItem('tournaments', JSON.stringify(tournaments));
          }
        } catch (e) {
          console.error('Error updating localStorage:', e);
        }
        
        console.log('‚úì Bracket updated with winner:', winnerData.firstName, winnerData.lastName);
        
      } catch (err) {
        console.error('Error updating bracket:', err);
        showToast('Match saved but bracket update failed', 'warning');
      }
    }

    function openScorecard() {
      document.getElementById('scorecard-modal').classList.add('active');
    }

    function closeScorecard() {
      document.getElementById('scorecard-modal').classList.remove('active');
    }

    function closeModal(event) {
      if (event.target.classList.contains('modal-overlay')) {
        closeScorecard();
      }
    }

    // ============================================
    // SIGNATURE PAD AND SCORECARD SIGNING
    // ============================================
    
    let playerSignaturePad = null;
    let markerSignaturePad = null;
    
    // Simple signature pad implementation
    class SignaturePad {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.isDrawing = false;
        this.lastX = 0;
        this.lastY = 0;
        this.isEmpty = true;
        
        this.setupCanvas();
        this.bindEvents();
      }
      
      setupCanvas() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        this.ctx.strokeStyle = '#1e293b';
        this.ctx.lineWidth = 2;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
      }
      
      bindEvents() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', () => this.stopDrawing());
        this.canvas.addEventListener('mouseout', () => this.stopDrawing());
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.startDrawing(e.touches[0]);
        });
        this.canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          this.draw(e.touches[0]);
        });
        this.canvas.addEventListener('touchend', () => this.stopDrawing());
      }
      
      getPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
      }
      
      startDrawing(e) {
        this.isDrawing = true;
        const pos = this.getPos(e);
        this.lastX = pos.x;
        this.lastY = pos.y;
      }
      
      draw(e) {
        if (!this.isDrawing) return;
        
        const pos = this.getPos(e);
        this.ctx.beginPath();
        this.ctx.moveTo(this.lastX, this.lastY);
        this.ctx.lineTo(pos.x, pos.y);
        this.ctx.stroke();
        
        this.lastX = pos.x;
        this.lastY = pos.y;
        this.isEmpty = false;
        
        // Update container class
        this.canvas.parentElement.classList.add('signed');
        updateSignButtonState();
      }
      
      stopDrawing() {
        this.isDrawing = false;
      }
      
      clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.isEmpty = true;
        this.canvas.parentElement.classList.remove('signed');
        updateSignButtonState();
      }
      
      toDataURL() {
        return this.isEmpty ? null : this.canvas.toDataURL();
      }
    }
    
    // Initialize signature pads when modal opens
    function initSignaturePads() {
      const playerCanvas = document.getElementById('player-signature-pad');
      const markerCanvas = document.getElementById('marker-signature-pad');
      
      if (playerCanvas && !playerSignaturePad) {
        playerSignaturePad = new SignaturePad(playerCanvas);
      }
      if (markerCanvas && !markerSignaturePad) {
        markerSignaturePad = new SignaturePad(markerCanvas);
      }
    }
    
    function clearSignature(type) {
      if (type === 'player' && playerSignaturePad) {
        playerSignaturePad.clear();
      } else if (type === 'marker' && markerSignaturePad) {
        markerSignaturePad.clear();
      }
    }
    
    function updateSignButtonState() {
      const checkbox = document.getElementById('confirm-scores-checkbox');
      const btn = document.getElementById('confirm-sign-btn');
      
      const playerSigned = playerSignaturePad && !playerSignaturePad.isEmpty;
      const markerSigned = markerSignaturePad && !markerSignaturePad.isEmpty;
      const isChecked = checkbox && checkbox.checked;
      
      if (btn) {
        btn.disabled = !(playerSigned && markerSigned && isChecked);
      }
    }
    
    // Calculate score summary for display
    function getScoreSummary() {
      const pars = digitalData?.pars || [];
      let totalGross = 0;
      let totalPar = 0;
      let holesPlayed = 0;
      
      for (let i = 0; i < 18; i++) {
        const score = scores.player[i];
        const par = pars[i] || 4;
        totalPar += par;
        
        if (score !== null && score !== undefined && score !== 'X') {
          totalGross += score;
          holesPlayed++;
        } else if (score === 'X') {
          // For X, use net double bogey estimate
          totalGross += par + 2;
          holesPlayed++;
        }
      }
      
      const toPar = totalGross - totalPar;
      const toParStr = toPar === 0 ? 'E' : (toPar > 0 ? '+' + toPar : toPar);
      
      return {
        gross: totalGross,
        par: totalPar,
        toPar: toParStr,
        holesPlayed: holesPlayed
      };
    }
    
    // Open sign modal
    function openSignModal() {
      // Check if all holes are complete
      if (!isRoundComplete(scores.player)) {
        showToast('Please complete all 18 holes before signing', 'error');
        return;
      }
      
      // Check for disputes
      const disputes = getDisputes();
      if (disputes.length > 0) {
        showToast('Please resolve score disputes before signing', 'error');
        return;
      }
      
      // Update marker name
      const markerNameEl = document.getElementById('marker-name-sign');
      if (markerNameEl && marksPlayerData) {
        markerNameEl.textContent = marksPlayerData.firstName;
      }
      
      // Populate score summary
      const summary = getScoreSummary();
      const summaryEl = document.getElementById('score-summary');
      if (summaryEl) {
        summaryEl.innerHTML = `
          <div class="score-summary-title">Score Summary</div>
          <div class="score-summary-row">
            <span class="score-summary-label">Holes Played</span>
            <span class="score-summary-value">${summary.holesPlayed}</span>
          </div>
          <div class="score-summary-row">
            <span class="score-summary-label">Course Par</span>
            <span class="score-summary-value">${summary.par}</span>
          </div>
          <div class="score-summary-row">
            <span class="score-summary-label">Gross Score</span>
            <span class="score-summary-value">${summary.gross}</span>
          </div>
          <div class="score-summary-row">
            <span class="score-summary-label">To Par</span>
            <span class="score-summary-value">${summary.toPar}</span>
          </div>
        `;
      }
      
      document.getElementById('sign-modal').classList.add('active');
      
      // Initialize signature pads after modal is visible
      setTimeout(() => {
        initSignaturePads();
      }, 100);
    }
    
    function closeSignModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('sign-modal').classList.remove('active');
    }
    
    // Confirm and lock scorecard
    async function confirmAndLockScorecard() {
      const playerSig = playerSignaturePad?.toDataURL();
      const markerSig = markerSignaturePad?.toDataURL();
      
      if (!playerSig || !markerSig) {
        showToast('Both signatures are required', 'error');
        return;
      }
      
      // Update scorecard status
      scorecardStatus = {
        playerSigned: true,
        playerSignature: playerSig,
        playerSignedAt: Date.now(),
        markerConfirmed: true,
        markerSignature: markerSig,
        markerSignedAt: Date.now(),
        locked: true,
        lockedAt: Date.now(),
        lockedBy: `${playerData.firstName} ${playerData.lastName}`
      };
      
      // Save to Firebase
      if (db) {
        try {
          await db.ref(`digitalScores/${roundId}/${playerId}`).update({
            scorecardStatus: scorecardStatus,
            lastUpdated: Date.now()
          });
          
          // Sync completed scores to main scores system
          await syncToScoresSystem();
          
          showToast('Scorecard signed and locked! ‚úÖ', 'success');
          closeSignModal();
          render();
        } catch (err) {
          console.error('Error locking scorecard:', err);
          showToast('Error saving. Please try again.', 'error');
        }
      } else {
        // Save locally if offline
        localStorage.setItem(`scorecardStatus_${roundId}_${playerId}`, JSON.stringify(scorecardStatus));
        showToast('Scorecard signed (offline). Will sync when connected.', 'info');
        closeSignModal();
        render();
      }
    }
    
    // Sync completed digital scorecard to main scores system
    async function syncToScoresSystem() {
      if (!db || !roundId || !playerId) return;
      
      try {
        // Get player's registration key (used as playerKey in scores)
        const playerKey = playerData.reg || playerId;
        
        // Convert scores to the format used by scores.html
        // scores.player contains the hole scores [score1, score2, ..., score18]
        const holesArray = scores.player.map(score => {
          if (score === null || score === undefined) return '';
          if (score === 'X') return 0; // X (pickup) is stored as 0 in main system
          return score;
        });
        
        // Calculate points and stableford points using course data
        const pointsArray = [];
        const stablefordPointsArray = [];
        const courseHoles = digitalData?.courseData?.holes || [];
        const playerHcp = playerData.handicap || 0;
        
        for (let i = 0; i < 18; i++) {
          const holeScore = holesArray[i];
          if (holeScore === '' || holeScore === 0) {
            pointsArray.push('');
            stablefordPointsArray.push(0);
            continue;
          }
          
          const holePar = courseHoles[i]?.par || 4;
          const holeHcp = courseHoles[i]?.handicap || (i + 1);
          
          // Calculate strokes received on this hole
          const strokesReceived = Math.floor(playerHcp / 18) + (holeHcp <= (playerHcp % 18) ? 1 : 0);
          
          // Net score
          const netScore = holeScore - strokesReceived;
          
          // Points relative to par
          const points = holePar - holeScore;
          pointsArray.push(points);
          
          // Stableford points
          const netToPar = netScore - holePar;
          let stableford = 0;
          if (netToPar <= -3) stableford = 5; // Albatross or better
          else if (netToPar === -2) stableford = 4; // Eagle
          else if (netToPar === -1) stableford = 3; // Birdie
          else if (netToPar === 0) stableford = 2; // Par
          else if (netToPar === 1) stableford = 1; // Bogey
          else stableford = 0; // Double or worse
          stablefordPointsArray.push(stableford);
        }
        
        // Build the score data object
        const scoreData = {
          holes: holesArray,
          points: pointsArray,
          stablefordPoints: stablefordPointsArray,
          incompleteHoles: holesArray.map((s, i) => s === 0 ? i : -1).filter(i => i >= 0),
          status: 'completed',
          digitalScorecard: true,
          signedAt: Date.now(),
          syncedFromDigitalScorecard: true
        };
        
        // Save to Firebase scores path
        await db.ref(`scores/${roundId}/${playerKey}`).set(scoreData);
        
        console.log('‚úÖ Scores synced to main scores system:', playerKey, scoreData);
      } catch (err) {
        console.error('Error syncing to scores system:', err);
        // Don't throw - this is a secondary sync, primary signing already succeeded
      }
    }
    
    // Render locked banner
    function renderLockedBanner() {
      if (!scorecardStatus.locked) return '';
      
      const lockedDate = new Date(scorecardStatus.lockedAt).toLocaleString();
      return `
        <div class="locked-banner">
          <h3>üîí Scorecard Locked</h3>
          <p>Signed and confirmed on ${lockedDate}</p>
        </div>
      `;
    }
    
    // Render complete round button
    function renderSaveBar() {
      // Don't show save bar if scorecard is locked
      if (scorecardStatus.locked) return '';
      
      const allComplete = isRoundComplete(scores.player);
      const disputes = getDisputes();
      const hasDisputes = disputes.length > 0;
      
      // For bracket matches, check if match is finished
      const isBracketMatch = digitalData.isBracketMatch;
      const matchResult = isBracketMatch ? calculateMatchResult() : null;
      const isMatchFinished = matchResult && matchResult.isFinished;
      
      // State 0: Bracket match finished - show "Finish & Submit"
      if (isBracketMatch && isMatchFinished && !allComplete) {
        return `
          <div class="save-bar">
            <button class="btn-save btn-finish" onclick="finishBracketMatch()">
              üèÜ Finish & Submit Match
            </button>
            <div style="text-align:center; font-size:12px; color:#059669; margin-top:6px;">
              ${matchResult.resultText}
            </div>
          </div>
        `;
      }
      
      // State 1: Round not complete - show "Save & Next Hole"
      if (!allComplete) {
        return `
          <div class="save-bar">
            <button class="btn-save" onclick="saveAndNext()">
              ‚úì Save & Next Hole
            </button>
          </div>
        `;
      }
      
      // State 2: Round complete but has disputes - show disabled warning
      if (hasDisputes) {
        return `
          <div class="save-bar">
            <button class="btn-save btn-disputes" disabled>
              ‚ö†Ô∏è Resolve ${disputes.length} Dispute${disputes.length !== 1 ? 's' : ''} First
            </button>
          </div>
        `;
      }
      
      // State 3: Round complete but marker hasn't logged in yet
      if (!markerHasLoggedIn && markerPlayerId) {
        return `
          <div class="save-bar">
            <button class="btn-save btn-not-logged-in" disabled>
              üìµ Marker Has Not Logged In Yet
            </button>
          </div>
        `;
      }
      
      // State 4: Round complete but marker hasn't entered all scores yet
      const markerPendingHoles = getMarkerPendingHoles();
      if (markerPendingHoles.length > 0) {
        return `
          <div class="save-bar">
            <button class="btn-save btn-pending" disabled>
              ‚è≥ Waiting for Marker (${markerPendingHoles.length} hole${markerPendingHoles.length !== 1 ? 's' : ''})
            </button>
          </div>
        `;
      }
      
      // State 5: Round complete, no disputes, marker confirmed - show sign button
      return `
        <div class="save-bar">
          <button class="btn-save btn-sign" onclick="openSignModal()">
            ‚úçÔ∏è Sign & Complete Scorecard
          </button>
        </div>
      `;
    }
    
    // Check if marker has pending scores (player entered but marker hasn't)
    function getMarkerPendingHoles() {
      const pendingHoles = [];
      for (let i = 0; i < 18; i++) {
        const playerScore = scores.player[i];
        const markerScore = markerScoresForMe[i];
        // Player has entered a score but marker hasn't confirmed yet
        if (playerScore !== null && playerScore !== undefined && 
            (markerScore === null || markerScore === undefined)) {
          pendingHoles.push(i + 1);
        }
      }
      return pendingHoles;
    }

    // Initialize app
    init();
    
    // Setup checkbox listener
    document.getElementById('confirm-scores-checkbox')?.addEventListener('change', updateSignButtonState);
  </script>
</body>
</html>
