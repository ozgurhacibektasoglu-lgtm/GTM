<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Player Admissions</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="../firebase-config.js"></script>
    
    <link rel="stylesheet" href="../styles.css">
    <style>
      .admissions-container{max-width:1400px;margin:24px auto;padding:16px}
      .round-selector{background:#fff;border-radius:12px;padding:20px;margin-bottom:20px;box-shadow:0 8px 24px rgba(2,6,23,0.06)}
      .round-selector label{display:block;font-weight:600;margin-bottom:8px}
      .round-selector select{padding:10px;border-radius:8px;border:1px solid #e6e9ef;font-size:15px;min-width:200px}
      .admissions-grid{display:flex;gap:20px}
      .panel{flex:1;background:#fff;border-radius:12px;padding:16px;box-shadow:0 8px 24px rgba(2,6,23,0.06)}
      .panel h2{margin-top:0;font-size:18px;color:#1e293b;margin-bottom:12px}
      .search-box{margin-bottom:12px}
      .search-box input{width:100%;padding:10px;border-radius:8px;border:1px solid #e6e9ef;font-size:15px}
      .table-wrapper{overflow:auto;max-height:calc(100vh - 320px);border-radius:8px}
      table{width:100%;border-collapse:collapse}
      table th{position:sticky;top:0;background:#f8fafc;padding:10px 8px;border-bottom:2px solid #e6e9ef;font-weight:600;text-align:left;font-size:13px;cursor:pointer;user-select:none}
      table th:hover{background:#e2e8f0}
      table th.sort-asc::after{content:' ‚ñ≤';font-size:10px;color:#3b82f6}
      table th.sort-desc::after{content:' ‚ñº';font-size:10px;color:#3b82f6}
      table td{padding:10px 8px;border-bottom:1px solid #f1f5f9;font-size:14px}
      table tr:hover{background:#f8fbff;cursor:pointer}
      table tr.highlighted{background:#fef3c7;font-weight:600}
      table tr.ineligible{background:#fee;color:#999;cursor:not-allowed}
      table tr.ineligible:hover{background:#fdd}
      .btn-back{background:white;border:1px solid #e6e9ef;padding:10px 14px;border-radius:8px;cursor:pointer;font-size:14px;color:#333;text-decoration:none;display:inline-block}
      .status-text{font-size:13px;color:#64748b;margin-bottom:8px}
      .criteria-panel{background:#fff;border-radius:12px;padding:16px 20px;margin-bottom:20px;box-shadow:0 8px 24px rgba(2,6,23,0.06)}
      .criteria-header{display:flex;align-items:center;justify-content:space-between;cursor:pointer}
      .criteria-header h2{margin:0;font-size:16px;color:#1e293b;display:flex;align-items:center;gap:8px}
      .criteria-header .toggle-icon{font-size:12px;color:#64748b;transition:transform 0.2s}
      .criteria-header .toggle-icon.expanded{transform:rotate(180deg)}
      .criteria-content{display:none;margin-top:16px;padding-top:16px;border-top:1px solid #e6e9ef}
      .criteria-content.expanded{display:block}
      .criteria-row{display:flex;flex-wrap:wrap;gap:24px;align-items:flex-end}
      .criteria-group{display:flex;flex-direction:column;gap:4px}
      .criteria-group label{font-weight:600;font-size:12px;color:#64748b;text-transform:uppercase;letter-spacing:0.5px}
      .criteria-group select,.criteria-group input{padding:8px 12px;border-radius:6px;border:1px solid #e6e9ef;font-size:14px;min-width:100px}
      .criteria-group input[type="number"]{width:70px;text-align:center}
      .criteria-group input[type="number"]::-webkit-inner-spin-button,.criteria-group input[type="number"]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}
      .criteria-group input[type="number"]{-moz-appearance:textfield}
      .criteria-inline{display:flex;align-items:center;gap:8px}
      .criteria-inline span{color:#64748b;font-size:13px}
      .criteria-divider{width:1px;height:40px;background:#e6e9ef;margin:0 8px}
      .btn-save-criteria{background:linear-gradient(180deg,var(--accent),#0a58d1);color:white;border:0;padding:8px 20px;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;margin-left:auto}
      .btn-save-criteria:hover{opacity:0.9}
      .btn-save-admissions{position:fixed;bottom:20px;right:20px;background:#28a745;color:white;border:0;padding:12px 24px;border-radius:8px;cursor:pointer;font-size:14px;font-weight:600;box-shadow:0 4px 12px rgba(40,167,69,0.3);transition:all 0.2s}
      .btn-save-admissions:hover{background:#218838;transform:translateY(-2px);box-shadow:0 6px 16px rgba(40,167,69,0.4)}
      .btn-remove-all{position:fixed;bottom:20px;right:180px;background:#dc3545;color:white;border:0;padding:12px 24px;border-radius:8px;cursor:pointer;font-size:14px;font-weight:600;box-shadow:0 4px 12px rgba(220,53,69,0.3);transition:all 0.2s}
      .btn-remove-all:hover{background:#c82333;transform:translateY(-2px);box-shadow:0 6px 16px rgba(220,53,69,0.4)}
      
      /* TGF Import Panel Styles */
      .tgf-panel{background:#fff;border-radius:12px;padding:20px;margin-bottom:20px;box-shadow:0 8px 24px rgba(2,6,23,0.06)}
      .tgf-panel h2{margin-top:0;font-size:18px;color:#1e293b;margin-bottom:16px;cursor:pointer;display:flex;align-items:center;justify-content:space-between}
      .tgf-panel h2 .toggle-icon{font-size:14px;color:#64748b}
      .tgf-content{display:none}
      .tgf-content.expanded{display:block}
      .tgf-search-assist{background:#f0f9ff;padding:15px;border-radius:8px;margin-bottom:15px}
      .tgf-instructions{background:#e0f2fe;border:1px solid #7dd3fc;color:#0c4a6e;padding:15px;border-radius:6px;margin-bottom:15px;font-size:14px}
      .tgf-instructions ol{margin:10px 0 0 0;padding-left:20px}
      .tgf-instructions li{margin-bottom:6px}
      .tgf-paste-area{width:100%;min-height:100px;padding:12px;border:2px dashed #cbd5e1;border-radius:8px;font-family:monospace;font-size:12px;resize:vertical;margin-bottom:15px;box-sizing:border-box}
      .tgf-paste-area:focus{border-color:#0b6efd;outline:none}
      .tgf-results{max-height:250px;overflow-y:auto;border:1px solid #e6e9ef;border-radius:8px;margin-top:15px}
      .tgf-results table{width:100%;border-collapse:collapse;font-size:13px}
      .tgf-results th{position:sticky;top:0;background:#f8fafc;padding:8px;text-align:left;font-weight:600;border-bottom:2px solid #e6e9ef}
      .tgf-results td{padding:8px;border-bottom:1px solid #f1f5f9}
      .tgf-results tr:hover{background:#f8fbff;cursor:pointer}
      .tgf-results tr.tgf-selected{background:#dbeafe}
      .tgf-btn{padding:8px 16px;border:none;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;transition:all 0.2s}
      .tgf-btn-primary{background:#0b6efd;color:white}
      .tgf-btn-primary:hover{background:#0a5ed7}
      .tgf-btn-success{background:#28a745;color:white}
      .tgf-btn-success:hover{background:#218838}
      .tgf-btn-secondary{background:#6c757d;color:white}
      .tgf-btn-secondary:hover{background:#5a6268}
      
      /* Editable HCP cell */
      .hcp-editable{cursor:pointer;position:relative}
      .hcp-editable:hover{background:#e0f2fe;border-radius:4px}
      .hcp-editable::after{content:'‚úé';font-size:10px;margin-left:4px;opacity:0.4}
      .hcp-editable:hover::after{opacity:1}
      .hcp-input{width:60px;padding:4px 6px;border:2px solid #3b82f6;border-radius:4px;font-size:14px;text-align:center}
    </style>
  </head>
  <body>
    <main class="admissions-container">
      <header style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px">
        <div>
          <h1>Player Admissions</h1>
          <p class="lead">Add players to the tournament.</p>
        </div>
        <a href="index.html" class="btn-back">Back to Tournaments</a>
      </header>

      <section id="round-selector" class="round-selector" style="display:none">
        <label for="round-select">Select Round:</label>
        <select id="round-select">
          <!-- Populated dynamically -->
        </select>
      </section>

      <section class="criteria-panel">
        <div class="criteria-header" onclick="toggleCriteriaPanel()">
          <h2>‚öôÔ∏è Admission Criteria</h2>
          <span class="toggle-icon" id="criteria-toggle-icon">‚ñº</span>
        </div>
        <div class="criteria-content" id="criteria-content">
          <div class="criteria-row">
            <!-- HCP Men -->
            <div class="criteria-group">
              <label>HCP Men</label>
              <div class="criteria-inline">
                <select id="criteria-hcp-men">
                  <option value="NA">No Limit</option>
                  <option value="Limit Playing">Limit PHCP</option>
                  <option value="Limit WHS">Limit WHS</option>
                  <option value="Adjust Playing">Adjust PHCP</option>
                  <option value="Adjust WHS">Adjust WHS</option>
                </select>
                <input type="number" id="criteria-hcp-men-value" placeholder="Max" style="display:none;">
              </div>
            </div>

            <!-- HCP Women -->
            <div class="criteria-group">
              <label>HCP Women</label>
              <div class="criteria-inline">
                <select id="criteria-hcp-women">
                  <option value="NA">No Limit</option>
                  <option value="Limit Playing">Limit PHCP</option>
                  <option value="Limit WHS">Limit WHS</option>
                  <option value="Adjust Playing">Adjust PHCP</option>
                  <option value="Adjust WHS">Adjust WHS</option>
                </select>
                <input type="number" id="criteria-hcp-women-value" placeholder="Max" style="display:none;">
              </div>
            </div>

            <div class="criteria-divider"></div>

            <!-- Age -->
            <div class="criteria-group">
              <label>Age Range</label>
              <div class="criteria-inline">
                <input type="number" id="criteria-age-min" placeholder="Min" style="width:60px">
                <span>‚Äì</span>
                <input type="number" id="criteria-age-max" placeholder="Max" style="width:60px">
              </div>
            </div>

            <div class="criteria-divider"></div>

            <!-- Gender -->
            <div class="criteria-group">
              <label>Gender</label>
              <select id="criteria-gender">
                <option value="both">All</option>
                <option value="M">Men Only</option>
                <option value="F">Women Only</option>
              </select>
            </div>

            <!-- Members -->
            <div class="criteria-group">
              <label>Members</label>
              <select id="criteria-members-only">
                <option value="no">All Players</option>
                <option value="yes">Members Only</option>
              </select>
            </div>

            <button id="btn-save-criteria" class="btn-save-criteria">üíæ Save</button>
          </div>
        </div>
      </section>

      <section class="tgf-panel">
        <h2 onclick="toggleTgfPanel()">
          üáπüá∑ Import from TGF & Admit
          <span class="toggle-icon" id="tgf-toggle-icon">‚ñº</span>
        </h2>
        <div class="tgf-content" id="tgf-content">
          <div class="tgf-search-assist">
            <strong>üîç Quick Search:</strong>
            <p style="font-size:13px;color:#64748b;margin:8px 0;">Enter a player name to open TGF search in a new tab</p>
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <input type="text" id="tgf-search-name" placeholder="Enter player name (e.g., √ñzg√ºr)" 
                     style="flex:1;min-width:200px;padding:10px;border:1px solid #ddd;border-radius:6px;font-size:14px;">
              <button class="tgf-btn tgf-btn-primary" onclick="openTGFSearch()">Search TGF</button>
            </div>
          </div>

          <div class="tgf-instructions">
            <strong>How to import & admit:</strong>
            <ol>
              <li>Enter a name above and click "Search TGF" to open the search results</li>
              <li>On the TGF page, find the player you want and select the table row</li>
              <li>Copy it (Ctrl+C or Cmd+C) and paste in the text area below</li>
              <li>Click "Parse Data" then select a player and click "Import & Admit"</li>
            </ol>
          </div>

          <textarea id="tgf-paste-area" class="tgf-paste-area" placeholder="Paste the copied player data here..."></textarea>
          
          <div style="display:flex;gap:10px;flex-wrap:wrap">
            <button class="tgf-btn tgf-btn-primary" onclick="parseTgfData()">üìã Parse Data</button>
            <button class="tgf-btn tgf-btn-secondary" onclick="clearTgfData()">Clear</button>
          </div>

          <div id="tgf-results" class="tgf-results" style="display:none">
            <table>
              <thead>
                <tr>
                  <th>Fed. No.</th>
                  <th>Name</th>
                  <th>Club</th>
                  <th>HCP</th>
                  <th>Gender</th>
                  <th>Birth Date</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="tgf-results-body"></tbody>
            </table>
          </div>
        </div>
      </section>

      <section class="admissions-grid">
        <div class="panel">
          <h2>Available Players</h2>
          <div class="search-box">
            <input id="player-search" type="text" placeholder="Search by name, reg no, or club... (Press Enter to admit)" />
          </div>
          <div id="available-status" class="status-text"></div>
          <div class="table-wrapper">
            <table id="available-table">
              <thead>
                <tr>
                  <th data-sort="reg">Reg No</th>
                  <th data-sort="name">Name</th>
                  <th data-sort="club">Home Club</th>
                  <th data-sort="tee">Tee</th>
                  <th data-sort="hcp">HCP</th>
                  <th data-sort="phcp">Playing HCP</th>
                  <th data-sort="gender">Gender</th>
                  <th data-sort="age">Age</th>
                </tr>
              </thead>
              <tbody id="available-tbody">
                <!-- Populated dynamically -->
              </tbody>
            </table>
          </div>
        </div>

        <div class="panel">
          <h2>Admitted Players</h2>
          <div id="admitted-status" class="status-text"></div>
          <div class="table-wrapper">
            <table id="admitted-table">
              <thead>
                <tr>
                  <th data-sort="reg">Reg No</th>
                  <th data-sort="name">Name</th>
                  <th data-sort="club">Home Club</th>
                  <th data-sort="tee">Tee</th>
                  <th data-sort="hcp">HCP</th>
                  <th data-sort="phcp">Playing HCP</th>
                  <th data-sort="gender">Gender</th>
                  <th data-sort="age">Age</th>
                </tr>
              </thead>
              <tbody id="admitted-tbody">
                <!-- Populated dynamically -->
              </tbody>
            </table>
          </div>
        </div>
      </section>
      
      <button class="btn-remove-all" onclick="removeAllAdmissions()">Remove All Admissions</button>
      <button class="btn-save-admissions" onclick="saveAdmissionsNow()">Save Admissions</button>
    </main>

    <script>
      // Get round or tournament from URL
      const urlParams = new URLSearchParams(window.location.search);
      const roundId = urlParams.get('roundId');
      const tournamentIdParam = urlParams.get('tournamentId');
      
      let currentTournament = null;
      let currentRoundId = null;
      let currentRoundIndex = 0;
      let allPlayers = [];
      let admittedPlayers = [];
      let filteredPlayers = [];
      let highlightedIndex = -1;
      let availableSortColumn = null;
      let availableSortDirection = 'asc';
      let admittedSortColumn = null;
      let admittedSortDirection = 'asc';

      // Calculate age based on January 1st of current year
      function calculateAge(dob) {
        if (!dob) return '';
        try {
          const birthDate = new Date(dob);
          const currentYear = new Date().getFullYear();
          const referenceDate = new Date(currentYear, 0, 1);
          let age = referenceDate.getFullYear() - birthDate.getFullYear();
          return age;
        } catch (e) {
          return '';
        }
      }

      // Format handicap for display (negative values show as +)
      function formatHcp(hcp) {
        if (!hcp && hcp !== 0) return '';
        const num = parseFloat(hcp);
        if (isNaN(num)) return hcp;
        if (num < 0) return '+' + Math.abs(num).toFixed(1);
        return num.toFixed(1);
      }

      // Get tee data for a player (slope, rating, par)
      function getTeeData(player) {
        if (!currentTournament || currentRoundIndex === undefined || currentRoundIndex < 0) return null;
        const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
        if (!roundData) return null;
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeValue = '';
        
        // Check if player has an assigned tee (from categories)
        if (player.tee) {
          // Convert tee ID to courseId||teeIndex format
          const courses = getCourses();
          const courseId = roundData.course;
          const course = courses.find(c => c.courseId === courseId);
          
          if (course && course.teeIds) {
            const idx = course.teeIds.findIndex(id => {
              if (typeof id === 'object') {
                return id.men === player.tee || id.women === player.tee;
              }
              return id === player.tee;
            });
            
            if (idx !== -1) {
              teeValue = `${courseId}||${idx}`;
            }
          }
        }
        
        // If no assigned tee, use default from tournament settings
        if (!teeValue) {
          if (playerGender === 'male' || playerGender === 'm') {
            teeValue = roundData.teeMen || '';
          } else if (playerGender === 'female' || playerGender === 'f') {
            teeValue = roundData.teeWomen || '';
          }
        }
        
        if (!teeValue || !teeValue.includes('||')) return null;
        
        const [courseId, teeIndexStr] = teeValue.split('||');
        const teeIndex = parseInt(teeIndexStr, 10);
        
        const courses = getCourses();
        const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
        
        if (!course) return null;
        
        // Calculate total par from pars array (sum of all 18 holes)
        let par = 0;
        if (course.pars && Array.isArray(course.pars)) {
          par = course.pars.reduce((sum, holePar) => sum + (parseInt(holePar) || 0), 0);
        }
        
        // Get tee-specific data from teeData array
        const teeData = course.teeData?.[teeIndex];
        if (!teeData) return null;
        
        let slope, rating;
        
        // Check if this tee is for both genders (has nested ratings structure)
        const teeGender = course.genders?.[teeIndex];
        if (teeGender === 'B' && teeData.ratings) {
          // Both genders - use appropriate gender's ratings
          if (playerGender === 'male' || playerGender === 'm') {
            slope = teeData.ratings.men?.slope18;
            rating = teeData.ratings.men?.rating18;
          } else if (playerGender === 'female' || playerGender === 'f') {
            slope = teeData.ratings.women?.slope18;
            rating = teeData.ratings.women?.rating18;
          }
        } else {
          // Single gender tee
          slope = teeData.slope18 || teeData.slope;
          rating = teeData.rating18 || teeData.rating;
        }
        
        return { slope, rating, par, course };
      }

      // Calculate playing handicap using the formula:
      // PHCP = (HCP √ó (Slope/113) + (Rating - Par)) √ó HCP_Allowance
      // Round to nearest whole number (.5 rounds up)
      function calculatePlayingHcp(player) {
        const playerHcp = parseFloat(player.hcp);
        if (isNaN(playerHcp)) {
          return '';
        }
        
        const teeData = getTeeData(player);
        if (!teeData || !teeData.slope || !teeData.rating || !teeData.par) {
          return formatHcp(player.hcp); // Fallback to WHS HCP if data missing
        }
        
        const slope = parseFloat(teeData.slope);
        const rating = parseFloat(teeData.rating);
        const par = parseFloat(teeData.par);
        const hcpAllowance = parseFloat(currentTournament.meta?.hcpAllow || 100) / 100;
        
        if (isNaN(slope) || isNaN(rating) || isNaN(par)) {
          return formatHcp(player.hcp);
        }
        
        // Formula: (HCP √ó (Slope/113) + (Rating - Par)) √ó HCP_Allowance
        const playingHcp = (playerHcp * (slope / 113) + (rating - par)) * hcpAllowance;
        
        // Round to nearest whole number (.5 rounds up)
        const rounded = Math.round(playingHcp);
        
        // Format with + for negative values (plus handicaps)
        if (rounded < 0) {
          return '+' + Math.abs(rounded);
        }
        return rounded.toString();
      }

      // Get courses from localStorage
      function getCourses() {
        try {
          const raw = localStorage.getItem('courses');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Error loading courses:', err);
          return [];
        }
      }

      // Get tee name from course data
      function getTeeName(teeValue) {
        if (!teeValue) return '';
        
        // Handle format: courseId||teeIndex
        if (teeValue.includes('||')) {
          const [courseId, teeIndexStr] = teeValue.split('||');
          const teeIndex = parseInt(teeIndexStr, 10);
          
          const courses = getCourses();
          const course = courses.find(c => (c.courseId === courseId) || (c.fullName === courseId));
          
          if (course && Array.isArray(course.tees) && course.tees[teeIndex]) {
            return course.tees[teeIndex];
          }
        }
        
        // Handle format: C001-01 (tee ID from categories)
        const courses = getCourses();
        for (const course of courses) {
          if (!course.teeIds || !course.tees) continue;
          
          const idx = course.teeIds.findIndex(id => {
            if (typeof id === 'object') {
              return id.men === teeValue || id.women === teeValue;
            }
            return id === teeValue;
          });
          
          if (idx !== -1 && idx < course.tees.length) {
            return course.tees[idx];
          }
        }
        
        return teeValue;
      }

      // Get tee assignment for player based on gender
      function getTeeForPlayer(player) {
        // If player already has a tee assigned (from categories), use that
        if (player.tee) {
          return getTeeName(player.tee);
        }
        
        // Otherwise, use default tee from tournament settings
        if (!currentTournament || currentRoundIndex === undefined || currentRoundIndex < 0) return '';
        const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
        if (!roundData) return '';
        
        const playerGender = (player.gender || '').toLowerCase();
        let teeValue = '';
        
        if (playerGender === 'male' || playerGender === 'm') {
          teeValue = roundData.teeMen || '';
        } else if (playerGender === 'female' || playerGender === 'f') {
          teeValue = roundData.teeWomen || '';
        }
        
        return getTeeName(teeValue);
      }

      // Get tournaments from localStorage
      function getTournaments() {
        try {
          const raw = localStorage.getItem('tournaments');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Error loading tournaments:', err);
          return [];
        }
      }

      // Get players from localStorage
      function getPlayers() {
        try {
          const raw = localStorage.getItem('players');
          return raw ? JSON.parse(raw) : [];
        } catch (err) {
          console.error('Error loading players:', err);
          return [];
        }
      }

      // Get admission criteria for tournament
      function getAdmissionCriteria() {
        if (!currentTournament) return null;
        try {
          const raw = localStorage.getItem('admissionCriteria');
          const data = raw ? JSON.parse(raw) : {};
          return data[currentTournament.tournamentId] || null;
        } catch (err) {
          console.error('Error loading criteria:', err);
          return null;
        }
      }

      // Get current criteria from form (for real-time checking)
      function getCurrentCriteria() {
        // Check if criteria elements exist (they might not be loaded yet on first render)
        const hcpMenEl = document.getElementById('criteria-hcp-men');
        const hcpWomenEl = document.getElementById('criteria-hcp-women');
        
        if (!hcpMenEl || !hcpWomenEl) {
          // Fall back to saved criteria if form not loaded yet
          return getAdmissionCriteria() || {};
        }
        
        const hcpMen = hcpMenEl.value;
        const hcpWomen = hcpWomenEl.value;
        
        return {
          hcpMen: hcpMen,
          hcpMenValue: hcpMen !== 'NA' ? document.getElementById('criteria-hcp-men-value').value : '',
          hcpWomen: hcpWomen,
          hcpWomenValue: hcpWomen !== 'NA' ? document.getElementById('criteria-hcp-women-value').value : '',
          ageMin: document.getElementById('criteria-age-min').value,
          ageMax: document.getElementById('criteria-age-max').value,
          membersOnly: document.getElementById('criteria-members-only').value,
          gender: document.getElementById('criteria-gender').value
        };
      }

      // Check if player meets admission criteria
      function checkEligibility(player, criteria) {
        if (!criteria) return { eligible: true, reasons: [] };
        
        const reasons = [];
        
        // Normalize gender values (male/female -> M/F)
        const playerGender = (player.gender || '').toLowerCase() === 'male' ? 'M' : 
                            (player.gender || '').toLowerCase() === 'female' ? 'F' : 
                            (player.gender || '').toUpperCase();
        
        // Check HCP Men
        if (criteria.hcpMen !== 'NA' && playerGender === 'M') {
          const limit = parseFloat(criteria.hcpMenValue);
          
          if (criteria.hcpMen === 'Limit Playing') {
            // Use Playing HCP (PHCP)
            const phcp = calculatePlayingHcp(player);
            const playerPhcp = phcp.startsWith('+') ? -parseFloat(phcp.substring(1)) : parseFloat(phcp);
            if (!isNaN(limit) && !isNaN(playerPhcp) && playerPhcp > limit) {
              reasons.push(`Playing HCP ${phcp} exceeds men's limit ${limit}`);
            }
          } else if (criteria.hcpMen === 'Limit WHS') {
            // Use WHS HCP
            const playerHcp = parseFloat(player.hcp || 0);
            if (!isNaN(limit) && playerHcp > limit) {
              reasons.push(`HCP ${playerHcp} exceeds men's limit ${limit}`);
            }
          } else if (criteria.hcpMen === 'Adjust Playing') {
            // Adjust Playing HCP - player is adjusted by this value, but still eligible
            // This is informational - doesn't disqualify
          } else if (criteria.hcpMen === 'Adjust WHS') {
            // Adjust WHS HCP - player is adjusted by this value, but still eligible
            // This is informational - doesn't disqualify
          }
        }
        
        // Check HCP Women
        if (criteria.hcpWomen !== 'NA' && playerGender === 'F') {
          const limit = parseFloat(criteria.hcpWomenValue);
          
          if (criteria.hcpWomen === 'Limit Playing') {
            // Use Playing HCP (PHCP)
            const phcp = calculatePlayingHcp(player);
            const playerPhcp = phcp.startsWith('+') ? -parseFloat(phcp.substring(1)) : parseFloat(phcp);
            if (!isNaN(limit) && !isNaN(playerPhcp) && playerPhcp > limit) {
              reasons.push(`Playing HCP ${phcp} exceeds women's limit ${limit}`);
            }
          } else if (criteria.hcpWomen === 'Limit WHS') {
            // Use WHS HCP
            const playerHcp = parseFloat(player.hcp || 0);
            if (!isNaN(limit) && playerHcp > limit) {
              reasons.push(`HCP ${playerHcp} exceeds women's limit ${limit}`);
            }
          } else if (criteria.hcpWomen === 'Adjust Playing') {
            // Adjust Playing HCP - player is adjusted by this value, but still eligible
            // This is informational - doesn't disqualify
          } else if (criteria.hcpWomen === 'Adjust WHS') {
            // Adjust WHS HCP - player is adjusted by this value, but still eligible
            // This is informational - doesn't disqualify
          }
        }
        
        // Check Age Limit
        if (criteria.ageMin || criteria.ageMax) {
          const age = calculateAge(player.dob);
          if (age !== '' && age !== null && age !== undefined) {
            if (criteria.ageMin && age < parseInt(criteria.ageMin)) {
              reasons.push(`Age ${age} below minimum ${criteria.ageMin}`);
            }
            if (criteria.ageMax && age > parseInt(criteria.ageMax)) {
              reasons.push(`Age ${age} above maximum ${criteria.ageMax}`);
            }
          }
        }
        
        // Check Members Only
        if (criteria.membersOnly === 'yes' && !player.isMember) {
          reasons.push('Non-member');
        }
        
        // Check Gender
        if (criteria.gender && criteria.gender !== 'both') {
          if (!playerGender || playerGender !== criteria.gender) {
            reasons.push(`Only gender ${criteria.gender} allowed`);
          }
        }
        
        return { eligible: reasons.length === 0, reasons };
      }

      // Get admitted players for this round
      function getAdmittedPlayers() {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          return data[currentRoundId] || [];
        } catch (err) {
          console.error('Error loading admitted players:', err);
          return [];
        }
      }

      // Save admitted players for this round
      function saveAdmittedPlayers(players) {
        try {
          const raw = localStorage.getItem('admittedPlayers');
          const data = raw ? JSON.parse(raw) : {};
          data[currentRoundId] = players;
          localStorage.setItem('admittedPlayers', JSON.stringify(data));
          
          // Sync to Firebase
          if (typeof syncToFirebase !== 'undefined' && syncEnabled) {
            syncToFirebase('admittedPlayers', data).then(() => {
              console.log('‚úì Admitted players synced to Firebase');
            }).catch(e => console.log('Firebase sync failed:', e));
          }
        } catch (err) {
          console.error('Error saving admitted players:', err);
        }
      }

      // Manual save function
      function saveAdmissionsNow() {
        if (!currentRoundId) {
          alert('No round selected');
          return;
        }
        saveAdmittedPlayers(admittedPlayers);
        alert('Admissions saved successfully!');
      }

      // Remove all admissions
      function removeAllAdmissions() {
        if (!currentRoundId) {
          alert('No round selected');
          return;
        }
        
        if (admittedPlayers.length === 0) {
          alert('No admitted players to remove');
          return;
        }
        
        const confirmed = confirm(
          `Are you sure you want to remove ALL ${admittedPlayers.length} admitted players?\n\nThis action cannot be undone!`
        );
        
        if (confirmed) {
          admittedPlayers = [];
          saveAdmittedPlayers(admittedPlayers);
          renderTables();
          alert('All admissions have been removed.');
        }
      }

      // Format date as dd.mm.yyyy
      function formatDateDDMMYYYY(dateStr) {
        if (!dateStr) return '';
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        return `${day}.${month}.${year}`;
      }

      // Initialize page
      function init() {
        const tournaments = getTournaments();

        // Resolve tournament and round
        if (roundId) {
          // Preferred: find by roundId
          currentTournament = tournaments.find(t => (t.meta?.roundIds || []).includes(roundId));
          if (!currentTournament) {
            alert('Tournament not found for the selected round.');
            window.location.href = 'index.html';
            return;
          }
          const roundIds = currentTournament.meta?.roundIds || [];
          currentRoundIndex = Math.max(0, roundIds.indexOf(roundId));
          currentRoundId = roundId;
        } else if (tournamentIdParam) {
          // Fallback: find by tournament ID and select default round by date
          currentTournament = tournaments.find(t => t.tournamentId === tournamentIdParam);
          if (!currentTournament) {
            alert('Tournament not found.');
            window.location.href = 'index.html';
            return;
          }
          const roundsData = currentTournament.meta?.roundsData || [];
          const rIds = currentTournament.meta?.roundIds || [];
          // Choose default round: latest on/after first, and up to today
          let defaultIdx = 0;
          const today = new Date(); today.setHours(0,0,0,0);
          for (let i=0;i<roundsData.length;i++){
            const d = roundsData[i]?.date ? new Date(roundsData[i].date) : null;
            if (d){ d.setHours(0,0,0,0); if (today >= d) defaultIdx = i; else break; }
          }
          currentRoundIndex = defaultIdx;
          currentRoundId = rIds[defaultIdx] || `${currentTournament.tournamentId}_R${defaultIdx+1}`;
        } else {
          alert('No round or tournament specified.');
          window.location.href = 'index.html';
          return;
        }

        allPlayers = getPlayers();
        console.log('Loaded players:', allPlayers.length);
        
        // Check if multi-round tournament
        const roundsData = currentTournament.meta?.roundsData || [];
        const numRounds = currentTournament.meta?.rounds || 1;
        
        if (numRounds > 1 && roundsData.length > 1) {
          document.getElementById('round-selector').style.display = 'block';
          const select = document.getElementById('round-select');
          const roundIds = currentTournament.meta?.roundIds || [];
          roundsData.forEach((round, idx) => {
            const option = document.createElement('option');
            option.value = roundIds[idx] || `${currentTournament.tournamentId}_R${idx+1}`;
            option.textContent = `Round ${idx + 1} - ${round.date ? formatDateDDMMYYYY(round.date) : ''}`;
            select.appendChild(option);
          });
          select.value = currentRoundId;
          select.addEventListener('change', (e) => {
            // Reload page with new round ID
            window.location.href = `admissions.html?roundId=${encodeURIComponent(e.target.value)}`;
          });
        }

        loadAdmittedPlayers();
        loadCriteria();
        setupCriteriaHandlers();
        renderTables();
        setupSearch();
        setupTableSorting();
      }

      // Load admitted players
      function loadAdmittedPlayers() {
        admittedPlayers = getAdmittedPlayers();
      }

      // Load criteria into form
      function loadCriteria() {
        const criteria = getAdmissionCriteria();
        
        // HCP Men
        const hcpMenSelect = document.getElementById('criteria-hcp-men');
        const hcpMenValue = document.getElementById('criteria-hcp-men-value');
        if (criteria && criteria.hcpMen) {
          hcpMenSelect.value = criteria.hcpMen;
          if (criteria.hcpMen !== 'NA') {
            hcpMenValue.style.display = 'block';
            hcpMenValue.value = criteria.hcpMenValue || '';
          }
        }
        
        // HCP Women
        const hcpWomenSelect = document.getElementById('criteria-hcp-women');
        const hcpWomenValue = document.getElementById('criteria-hcp-women-value');
        if (criteria && criteria.hcpWomen) {
          hcpWomenSelect.value = criteria.hcpWomen;
          if (criteria.hcpWomen !== 'NA') {
            hcpWomenValue.style.display = 'block';
            hcpWomenValue.value = criteria.hcpWomenValue || '';
          }
        }
        
        // Age limits
        if (criteria) {
          document.getElementById('criteria-age-min').value = criteria.ageMin || '';
          document.getElementById('criteria-age-max').value = criteria.ageMax || '';
          document.getElementById('criteria-members-only').value = criteria.membersOnly || 'no';
          document.getElementById('criteria-gender').value = criteria.gender || 'both';
        }
      }

      // Setup criteria form handlers
      function setupCriteriaHandlers() {
        // Show/hide HCP value inputs
        document.getElementById('criteria-hcp-men').addEventListener('change', (e) => {
          const valueInput = document.getElementById('criteria-hcp-men-value');
          valueInput.style.display = e.target.value === 'NA' ? 'none' : 'block';
          if (e.target.value === 'NA') valueInput.value = '';
        });
        
        document.getElementById('criteria-hcp-women').addEventListener('change', (e) => {
          const valueInput = document.getElementById('criteria-hcp-women-value');
          valueInput.style.display = e.target.value === 'NA' ? 'none' : 'block';
          if (e.target.value === 'NA') valueInput.value = '';
        });
        
        // Save criteria button
        document.getElementById('btn-save-criteria').addEventListener('click', saveCriteria);
        
        // Real-time criteria updates - re-render when any criteria field changes
        const criteriaInputs = [
          'criteria-hcp-men', 'criteria-hcp-men-value',
          'criteria-hcp-women', 'criteria-hcp-women-value',
          'criteria-age-min', 'criteria-age-max',
          'criteria-members-only', 'criteria-gender'
        ];
        
        criteriaInputs.forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => {
              // Re-render tables with updated criteria (temporary, not saved yet)
              renderTables();
            });
          }
        });
      }

      // Save criteria to localStorage
      function saveCriteria() {
        if (!currentTournament) return;
        
        const hcpMen = document.getElementById('criteria-hcp-men').value;
        const hcpWomen = document.getElementById('criteria-hcp-women').value;
        
        const criteria = {
          hcpMen: hcpMen,
          hcpMenValue: hcpMen !== 'NA' ? document.getElementById('criteria-hcp-men-value').value : '',
          hcpWomen: hcpWomen,
          hcpWomenValue: hcpWomen !== 'NA' ? document.getElementById('criteria-hcp-women-value').value : '',
          ageMin: document.getElementById('criteria-age-min').value,
          ageMax: document.getElementById('criteria-age-max').value,
          membersOnly: document.getElementById('criteria-members-only').value,
          gender: document.getElementById('criteria-gender').value
        };
        
        try {
          const raw = localStorage.getItem('admissionCriteria');
          const data = raw ? JSON.parse(raw) : {};
          data[currentTournament.tournamentId] = criteria;
          localStorage.setItem('admissionCriteria', JSON.stringify(data));
          
          // Update admitted players based on new criteria
          updateAdmittedPlayersForCriteria(criteria);
          
          alert('Criteria saved successfully!');
          renderTables();
        } catch (err) {
          console.error('Error saving criteria:', err);
          alert('Error saving criteria.');
        }
      }

      // Update admitted players when criteria changes
      function updateAdmittedPlayersForCriteria(newCriteria) {
        if (!admittedPlayers || admittedPlayers.length === 0) return;
        
        const warnings = [];
        
        admittedPlayers.forEach(function(player) {
          const playerGender = (player.gender || '').toLowerCase() === 'male' ? 'M' : 
                              (player.gender || '').toLowerCase() === 'female' ? 'F' : 
                              (player.gender || '').toUpperCase();
          
          // Check if Adjust Playing criteria for men
          if (playerGender === 'M' && newCriteria.hcpMen === 'Adjust Playing') {
            const adjustLimit = parseFloat(newCriteria.hcpMenValue);
            if (!isNaN(adjustLimit)) {
              const phcpString = calculatePlayingHcp(player);
              let phcp = phcpString.startsWith('+') ? -parseFloat(phcpString.substring(1)) : parseFloat(phcpString);
              
              if (phcp > adjustLimit) {
                player.phcp = adjustLimit;
              }
            }
          }
          // Check if Adjust Playing criteria for women
          else if (playerGender === 'F' && newCriteria.hcpWomen === 'Adjust Playing') {
            const adjustLimit = parseFloat(newCriteria.hcpWomenValue);
            if (!isNaN(adjustLimit)) {
              const phcpString = calculatePlayingHcp(player);
              let phcp = phcpString.startsWith('+') ? -parseFloat(phcpString.substring(1)) : parseFloat(phcpString);
              
              if (phcp > adjustLimit) {
                player.phcp = adjustLimit;
              }
            }
          }
          
          // Check if Limit criteria is applied - if so, warn if player doesn't meet it
          if (playerGender === 'M' && newCriteria.hcpMen && newCriteria.hcpMen.startsWith('Limit')) {
            const limit = parseFloat(newCriteria.hcpMenValue);
            let playerValue;
            
            if (newCriteria.hcpMen === 'Limit Playing') {
              const phcpString = calculatePlayingHcp(player);
              playerValue = phcpString.startsWith('+') ? -parseFloat(phcpString.substring(1)) : parseFloat(phcpString);
            } else if (newCriteria.hcpMen === 'Limit WHS') {
              playerValue = parseFloat(player.hcp || 0);
            }
            
            if (!isNaN(limit) && !isNaN(playerValue) && playerValue > limit) {
              warnings.push(`${player.firstName} ${player.lastName} (${player.reg}) already admitted but does not meet men's criteria`);
            }
          }
          
          // Check if Limit criteria is applied for women
          if (playerGender === 'F' && newCriteria.hcpWomen && newCriteria.hcpWomen.startsWith('Limit')) {
            const limit = parseFloat(newCriteria.hcpWomenValue);
            let playerValue;
            
            if (newCriteria.hcpWomen === 'Limit Playing') {
              const phcpString = calculatePlayingHcp(player);
              playerValue = phcpString.startsWith('+') ? -parseFloat(phcpString.substring(1)) : parseFloat(phcpString);
            } else if (newCriteria.hcpWomen === 'Limit WHS') {
              playerValue = parseFloat(player.hcp || 0);
            }
            
            if (!isNaN(limit) && !isNaN(playerValue) && playerValue > limit) {
              warnings.push(`${player.firstName} ${player.lastName} (${player.reg}) already admitted but does not meet women's criteria`);
            }
          }
          
          // Check Age Limit criteria
          if (newCriteria.ageMin || newCriteria.ageMax) {
            const age = calculateAge(player.dob);
            
            if (newCriteria.ageMin && age < parseInt(newCriteria.ageMin)) {
              warnings.push(`${player.firstName} ${player.lastName} (${player.reg}) age ${age} below minimum ${newCriteria.ageMin}`);
            }
            if (newCriteria.ageMax && age > parseInt(newCriteria.ageMax)) {
              warnings.push(`${player.firstName} ${player.lastName} (${player.reg}) age ${age} above maximum ${newCriteria.ageMax}`);
            }
          }
          
          // Check Gender criteria
          if (newCriteria.gender && newCriteria.gender !== 'both') {
            if (playerGender !== newCriteria.gender) {
              warnings.push(`${player.firstName} ${player.lastName} (${player.reg}) gender ${playerGender} does not match criteria ${newCriteria.gender}`);
            }
          }
          
          // Check Members Only criteria
          if (newCriteria.membersOnly === 'yes' && !player.isMember) {
            warnings.push(`${player.firstName} ${player.lastName} (${player.reg}) is not a member but members only selected`);
          }
        });
        
        // Save updated admitted players
        if (admittedPlayers.length > 0) {
          saveAdmittedPlayers(admittedPlayers);
        }
        
        // Show warnings if any
        if (warnings.length > 0) {
          alert('‚ö†Ô∏è Warning - Players already admitted that do not meet new criteria:\n\n' + warnings.join('\n'));
        }
      }

      // Render tables
      function getAdjustedHcp(player, criteria) {
        if (!criteria || !player) return player.hcp;
        
        const playerGender = (player.gender || '').toLowerCase() === 'male' ? 'M' : 
                            (player.gender || '').toLowerCase() === 'female' ? 'F' : 
                            (player.gender || '').toUpperCase();
        
        let hcp = parseFloat(player.hcp);
        
        if (playerGender === 'M' && criteria.hcpMen === 'Adjust WHS') {
          const adjustLimit = parseFloat(criteria.hcpMenValue);
          if (!isNaN(adjustLimit) && !isNaN(hcp) && hcp > adjustLimit) {
            hcp = adjustLimit;
          }
        } else if (playerGender === 'F' && criteria.hcpWomen === 'Adjust WHS') {
          const adjustLimit = parseFloat(criteria.hcpWomenValue);
          if (!isNaN(adjustLimit) && !isNaN(hcp) && hcp > adjustLimit) {
            hcp = adjustLimit;
          }
        }
        
        return hcp;
      }

      function getAdjustedPhcp(player, criteria) {
        if (!criteria || !player) return calculatePlayingHcp(player);
        
        const phcpString = calculatePlayingHcp(player);
        let phcp = phcpString.startsWith('+') ? -parseFloat(phcpString.substring(1)) : parseFloat(phcpString);
        
        const playerGender = (player.gender || '').toLowerCase() === 'male' ? 'M' : 
                            (player.gender || '').toLowerCase() === 'female' ? 'F' : 
                            (player.gender || '').toUpperCase();
        
        if (playerGender === 'M' && criteria.hcpMen === 'Adjust Playing') {
          const adjustLimit = parseFloat(criteria.hcpMenValue);
          if (!isNaN(adjustLimit) && !isNaN(phcp) && phcp > adjustLimit) {
            phcp = adjustLimit;
          }
        } else if (playerGender === 'F' && criteria.hcpWomen === 'Adjust Playing') {
          const adjustLimit = parseFloat(criteria.hcpWomenValue);
          if (!isNaN(adjustLimit) && !isNaN(phcp) && phcp > adjustLimit) {
            phcp = adjustLimit;
          }
        }
        
        // Format back to string with + for negatives
        if (phcp < 0) {
          return '+' + Math.abs(Math.round(phcp));
        }
        return Math.round(phcp).toString();
      }

      // Get which properties of a player fail criteria
      function getFailedCriteriaProperties(player, criteria) {
        const failed = {};
        if (!criteria || !player) return failed;
        
        const playerGender = (player.gender || '').toLowerCase() === 'male' ? 'M' : 
                            (player.gender || '').toLowerCase() === 'female' ? 'F' : 
                            (player.gender || '').toUpperCase();
        
        // Check HCP Men
        if (criteria.hcpMen !== 'NA' && criteria.hcpMen.startsWith('Limit') && playerGender === 'M') {
          const limit = parseFloat(criteria.hcpMenValue);
          let playerValue;
          
          if (criteria.hcpMen === 'Limit Playing') {
            const phcpString = calculatePlayingHcp(player);
            playerValue = phcpString.startsWith('+') ? -parseFloat(phcpString.substring(1)) : parseFloat(phcpString);
            if (!isNaN(limit) && !isNaN(playerValue) && playerValue > limit) {
              failed.phcp = true;
            }
          } else if (criteria.hcpMen === 'Limit WHS') {
            playerValue = parseFloat(player.hcp || 0);
            if (!isNaN(limit) && playerValue > limit) {
              failed.hcp = true;
            }
          }
        }
        
        // Check HCP Women
        if (criteria.hcpWomen !== 'NA' && criteria.hcpWomen.startsWith('Limit') && playerGender === 'F') {
          const limit = parseFloat(criteria.hcpWomenValue);
          let playerValue;
          
          if (criteria.hcpWomen === 'Limit Playing') {
            const phcpString = calculatePlayingHcp(player);
            playerValue = phcpString.startsWith('+') ? -parseFloat(phcpString.substring(1)) : parseFloat(phcpString);
            if (!isNaN(limit) && !isNaN(playerValue) && playerValue > limit) {
              failed.phcp = true;
            }
          } else if (criteria.hcpWomen === 'Limit WHS') {
            playerValue = parseFloat(player.hcp || 0);
            if (!isNaN(limit) && playerValue > limit) {
              failed.hcp = true;
            }
          }
        }
        
        // Check Age Limit
        if (criteria.ageMin || criteria.ageMax) {
          const age = calculateAge(player.dob);
          if ((criteria.ageMin && age < parseInt(criteria.ageMin)) || 
              (criteria.ageMax && age > parseInt(criteria.ageMax))) {
            failed.age = true;
          }
        }
        
        // Check Gender
        if (criteria.gender && criteria.gender !== 'both') {
          if (playerGender !== criteria.gender) {
            failed.gender = true;
          }
        }
        
        return failed;
      }

      // Render tables
      function renderTables() {
        const availableTbody = document.getElementById('available-tbody');
        const admittedTbody = document.getElementById('admitted-tbody');
        // Use current form values for real-time checking
        const criteria = getCurrentCriteria();
        
        console.log('Rendering - allPlayers:', allPlayers.length, 'admittedPlayers:', admittedPlayers.length);
        
        // Filter out already admitted players
        const admittedRegNos = new Set(admittedPlayers.map(p => p.reg));
        const availablePlayers = allPlayers.filter(p => !admittedRegNos.has(p.reg));
        
        // Render available players (use filtered list if search is active)
        let playersToShow = filteredPlayers.length > 0 || document.getElementById('player-search').value 
          ? filteredPlayers 
          : availablePlayers;
        
        // Apply sorting if a column is selected
        if (availableSortColumn) {
          playersToShow = sortPlayers(playersToShow, availableSortColumn, availableSortDirection);
        }
        
        availableTbody.innerHTML = playersToShow.map((player, idx) => {
          const eligibility = checkEligibility(player, criteria);
          const eligibleClass = !eligibility.eligible ? 'ineligible' : '';
          const highlightClass = idx === highlightedIndex ? 'highlighted' : '';
          const title = !eligibility.eligible ? eligibility.reasons.join(', ') : '';
          const age = calculateAge(player.dob);
          const adjustedHcp = getAdjustedHcp(player, criteria);
          const adjustedPhcp = getAdjustedPhcp(player, criteria);
          const failedProps = getFailedCriteriaProperties(player, criteria);
          
          const hcpStyle = failedProps.hcp ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          const phcpStyle = failedProps.phcp ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          const ageStyle = failedProps.age ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          const genderStyle = failedProps.gender ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          
          return `
            <tr class="${highlightClass} ${eligibleClass}" data-index="${idx}" data-eligible="${eligibility.eligible}" title="${title}">
              <td>${player.reg || ''}</td>
              <td>${player.firstName || ''} ${player.lastName || ''}</td>
              <td>${player.club || player.homeClub || ''}</td>
              <td>${getTeeForPlayer(player)}</td>
              <td style="${hcpStyle}">${formatHcp(adjustedHcp)}</td>
              <td style="${phcpStyle}">${adjustedPhcp}</td>
              <td style="${genderStyle}">${player.gender || ''}</td>
              <td style="${ageStyle}">${age}</td>
            </tr>
          `;
        }).join('');
        
        // Render admitted players
        let sortedAdmittedPlayers = admittedPlayers;
        if (admittedSortColumn) {
          sortedAdmittedPlayers = sortPlayers(admittedPlayers, admittedSortColumn, admittedSortDirection);
        }
        
        admittedTbody.innerHTML = sortedAdmittedPlayers.map(player => {
          const age = calculateAge(player.dob);
          const phcpDisplay = player.phcp !== null && player.phcp !== undefined ? 
            (player.phcp < 0 ? '+' + Math.abs(player.phcp) : player.phcp.toString()) : 
            calculatePlayingHcp(player);
          const failedProps = getFailedCriteriaProperties(player, criteria);
          
          const hcpStyle = failedProps.hcp ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          const phcpStyle = failedProps.phcp ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          const ageStyle = failedProps.age ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          const genderStyle = failedProps.gender ? 'background-color:#ffcccc;color:#c00;font-weight:600' : '';
          
          return `
            <tr data-reg="${player.reg}">
              <td>${player.reg || ''}</td>
              <td>${player.firstName || ''} ${player.lastName || ''}</td>
              <td>${player.club || player.homeClub || ''}</td>
              <td>${getTeeForPlayer(player)}</td>
              <td class="hcp-editable" data-reg="${player.reg}" data-hcp="${player.hcp}" style="${hcpStyle}">${formatHcp(player.hcp)}</td>
              <td style="${phcpStyle}">${phcpDisplay}</td>
              <td style="${genderStyle}">${player.gender || ''}</td>
              <td style="${ageStyle}">${age}</td>
            </tr>
          `;
        }).join('');
        
        // Update status
        const eligibleCount = playersToShow.filter(p => checkEligibility(p, criteria).eligible).length;
        document.getElementById('available-status').textContent = `${playersToShow.length} player(s) available (${eligibleCount} eligible)`;
        document.getElementById('admitted-status').textContent = `${admittedPlayers.length} player(s) admitted`;
        
        // Add double-click handlers for available players
        availableTbody.querySelectorAll('tr').forEach(row => {
          const idx = parseInt(row.getAttribute('data-index'));
          const eligible = row.getAttribute('data-eligible') === 'true';
          
          row.addEventListener('dblclick', () => {
            if (eligible && playersToShow[idx]) {
              admitPlayer(playersToShow[idx]);
              const searchInput = document.getElementById('player-search');
              searchInput.value = '';
              filteredPlayers = [];
              highlightedIndex = -1;
              renderTables();
              searchInput.focus();
            }
          });
        });
        
        // Add double-click handlers for admitted players (to remove them)
        admittedTbody.querySelectorAll('tr').forEach(row => {
          row.addEventListener('dblclick', (e) => {
            // Don't remove player if clicking on editable HCP cell
            if (e.target.classList.contains('hcp-editable') || e.target.classList.contains('hcp-input')) {
              return;
            }
            const reg = row.getAttribute('data-reg');
            removePlayer(reg);
          });
        });
        
        // Add click handlers for editable HCP cells
        admittedTbody.querySelectorAll('.hcp-editable').forEach(cell => {
          cell.addEventListener('click', (e) => {
            e.stopPropagation();
            // Don't create another input if already editing
            if (cell.querySelector('.hcp-input')) return;
            
            const reg = cell.getAttribute('data-reg');
            const currentHcp = parseFloat(cell.getAttribute('data-hcp')) || 0;
            
            // Create input element
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '0.1';
            input.min = '-10';
            input.max = '54';
            input.value = currentHcp.toFixed(1);
            input.className = 'hcp-input';
            
            // Replace cell content with input
            const originalContent = cell.innerHTML;
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            // Handle save on blur or Enter
            const saveHcp = () => {
              const newHcp = parseFloat(input.value);
              if (!isNaN(newHcp) && newHcp >= -10 && newHcp <= 54) {
                // Update player HCP in admitted list
                const player = admittedPlayers.find(p => p.reg === reg);
                if (player) {
                  player.hcp = Math.round(newHcp * 10) / 10; // Round to 1 decimal
                  // Recalculate playing HCP
                  player.phcp = null; // Force recalculation
                }
              }
              renderTables();
            };
            
            input.addEventListener('blur', saveHcp);
            input.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                saveHcp();
              } else if (e.key === 'Escape') {
                renderTables(); // Cancel edit
              }
            });
          });
        });
      }

      // Setup search functionality
      function setupSearch() {
        const searchInput = document.getElementById('player-search');
        
        searchInput.addEventListener('input', (e) => {
          const query = e.target.value.toLowerCase().trim();
          highlightedIndex = -1;
          
          if (!query) {
            filteredPlayers = [];
            renderTables();
            return;
          }
          
          const admittedRegs = new Set(admittedPlayers.map(p => p.reg));
          filteredPlayers = allPlayers.filter(p => {
            if (admittedRegs.has(p.reg)) return false;
            const name = `${p.firstName || ''} ${p.lastName || ''}`.toLowerCase();
            const reg = (p.reg || '').toString().toLowerCase();
            const playerNo = (p.playerNo || '').toString().toLowerCase();
            const club = (p.club || p.homeClub || '').toLowerCase();
            return name.includes(query) || reg.includes(query) || playerNo.includes(query) || club.includes(query);
          });
          
          if (filteredPlayers.length > 0) {
            highlightedIndex = 0;
          }
          
          renderTables();
        });
        
        searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            if (highlightedIndex >= 0 && filteredPlayers[highlightedIndex]) {
              admitPlayer(filteredPlayers[highlightedIndex]);
              searchInput.value = '';
              filteredPlayers = [];
              highlightedIndex = -1;
              renderTables();
              searchInput.focus();
            }
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (filteredPlayers.length > 0) {
              highlightedIndex = Math.min(highlightedIndex + 1, filteredPlayers.length - 1);
              renderTables();
            }
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (filteredPlayers.length > 0) {
              highlightedIndex = Math.max(highlightedIndex - 1, 0);
              renderTables();
            }
          }
        });
      }

      // Sort players array
      function sortPlayers(players, column, direction) {
        const sorted = [...players];
        
        sorted.sort((a, b) => {
          let aVal, bVal;
          
          switch(column) {
            case 'reg':
              aVal = (a.reg || '').toString();
              bVal = (b.reg || '').toString();
              break;
            case 'name':
              aVal = `${a.firstName || ''} ${a.lastName || ''}`;
              bVal = `${b.firstName || ''} ${b.lastName || ''}`;
              break;
            case 'club':
              aVal = (a.club || a.homeClub || '');
              bVal = (b.club || b.homeClub || '');
              break;
            case 'tee':
              aVal = getTeeForPlayer(a);
              bVal = getTeeForPlayer(b);
              break;
            case 'hcp':
              aVal = parseFloat(a.hcp) || 0;
              bVal = parseFloat(b.hcp) || 0;
              break;
            case 'phcp':
              // Calculate PHCP dynamically for sorting
              const aPhcp = calculatePlayingHcp(a);
              const bPhcp = calculatePlayingHcp(b);
              // Convert to numbers, handling +/- format
              aVal = aPhcp.startsWith('+') ? -parseFloat(aPhcp.substring(1)) : (parseFloat(aPhcp) || 0);
              bVal = bPhcp.startsWith('+') ? -parseFloat(bPhcp.substring(1)) : (parseFloat(bPhcp) || 0);
              // Handle NaN cases
              aVal = isNaN(aVal) ? (parseFloat(a.hcp) || 0) : aVal;
              bVal = isNaN(bVal) ? (parseFloat(b.hcp) || 0) : bVal;
              break;
            case 'gender':
              aVal = (a.gender || '');
              bVal = (b.gender || '');
              break;
            case 'age':
              aVal = calculateAge(a.dob) || 0;
              bVal = calculateAge(b.dob) || 0;
              break;
            default:
              return 0;
          }
          
          // Compare values
          if (typeof aVal === 'number' && typeof bVal === 'number') {
            return direction === 'asc' ? aVal - bVal : bVal - aVal;
          } else {
            // Use Turkish locale for string comparison
            const result = aVal.localeCompare(bVal, 'tr-TR', { sensitivity: 'base' });
            return direction === 'asc' ? result : -result;
          }
        });
        
        return sorted;
      }

      // Setup table header sorting
      function setupTableSorting() {
        // Available players table
        document.querySelectorAll('#available-table th[data-sort]').forEach(th => {
          th.addEventListener('click', () => {
            const column = th.getAttribute('data-sort');
            
            // Toggle direction if same column, otherwise reset to ascending
            if (availableSortColumn === column) {
              availableSortDirection = availableSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
              availableSortColumn = column;
              availableSortDirection = 'asc';
            }
            
            // Update header indicators
            document.querySelectorAll('#available-table th').forEach(h => {
              h.classList.remove('sort-asc', 'sort-desc');
            });
            th.classList.add(`sort-${availableSortDirection}`);
            
            renderTables();
          });
        });
        
        // Admitted players table
        document.querySelectorAll('#admitted-table th[data-sort]').forEach(th => {
          th.addEventListener('click', () => {
            const column = th.getAttribute('data-sort');
            
            // Toggle direction if same column, otherwise reset to ascending
            if (admittedSortColumn === column) {
              admittedSortDirection = admittedSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
              admittedSortColumn = column;
              admittedSortDirection = 'asc';
            }
            
            // Update header indicators
            document.querySelectorAll('#admitted-table th').forEach(h => {
              h.classList.remove('sort-asc', 'sort-desc');
            });
            th.classList.add(`sort-${admittedSortDirection}`);
            
            renderTables();
          });
        });
      }

      // Admit player
      function admitPlayer(player) {
        const criteria = getCurrentCriteria();
        const eligibility = checkEligibility(player, criteria);
        
        if (!eligibility.eligible) {
          alert('Player does not meet admission criteria:\n' + eligibility.reasons.join('\n'));
          return;
        }
        
        // Check if player is already admitted
        if (!admittedPlayers.find(p => p.reg === player.reg)) {
          // Add tee assignment and PHCP to player
          const playerWithTee = {...player};
          const roundData = currentTournament.meta?.roundsData?.[currentRoundIndex];
          
          // First, set default tee based on gender
          if (roundData) {
            const playerGender = (player.gender || '').toLowerCase();
            if (playerGender === 'male' || playerGender === 'm' || playerGender === 'e') {
              playerWithTee.tee = roundData.teeMen || '';
            } else if (playerGender === 'female' || playerGender === 'f' || playerGender === 'k') {
              playerWithTee.tee = roundData.teeWomen || '';
            }
          }
          
          // Check if player matches any category and override tee if needed
          const categories = currentTournament.categories || [];
          let teeAssigningCategory = null;
          const allMatchingCategories = [];
          
          for (const cat of categories) {
            const playerGender = (playerWithTee.gender || '').toLowerCase();
            const catGender = (cat.gender || '').toLowerCase();
            
            let genderMatch = false;
            if (!catGender || catGender === 'any' || catGender === '') {
              genderMatch = true;
            } else if (catGender === 'male' && (playerGender === 'm' || playerGender === 'male' || playerGender === 'e')) {
              genderMatch = true;
            } else if (catGender === 'female' && (playerGender === 'f' || playerGender === 'female' || playerGender === 'k')) {
              genderMatch = true;
            }
            
            if (genderMatch && playerMatchesCategory(playerWithTee, cat)) {
              allMatchingCategories.push(cat.code);
              
              // For tee assignment, use the first non-result-only category
              if (!cat.isResultOnly && !teeAssigningCategory) {
                teeAssigningCategory = cat;
              }
            }
          }
          
          // Store ALL categories this player belongs to
          playerWithTee.categories = allMatchingCategories;
          
          // For backward compatibility, also store primary category
          if (allMatchingCategories.length > 0) {
            playerWithTee.category = allMatchingCategories[0];
          }
          
          // If player matches a tee-assigning category, override the tee
          if (teeAssigningCategory && teeAssigningCategory.playsFrom) {
            playerWithTee.tee = teeAssigningCategory.playsFrom;
            console.log(`‚úì Player ${playerWithTee.firstName} ${playerWithTee.lastName} admitted with category tee: ${teeAssigningCategory.name} (${teeAssigningCategory.playsFrom})`);
          }
          
          // Calculate and save PHCP with the player (as numeric value)
          const phcpString = calculatePlayingHcp(playerWithTee);
          // Parse to number (handle "+2" format)
          let phcpValue = phcpString.startsWith('+') ? parseInt(phcpString.substring(1)) * -1 : (phcpString === '' ? null : parseInt(phcpString));
          
          // Apply PHCP adjustment if criteria specifies it
          const criteria = getCurrentCriteria();
          const playerGender = (playerWithTee.gender || '').toLowerCase() === 'male' ? 'M' : 
                              (playerWithTee.gender || '').toLowerCase() === 'female' ? 'F' : 
                              (playerWithTee.gender || '').toUpperCase();
          
          if (playerGender === 'M' && criteria.hcpMen === 'Adjust Playing') {
            const adjustLimit = parseFloat(criteria.hcpMenValue);
            if (!isNaN(adjustLimit) && phcpValue !== null && phcpValue > adjustLimit) {
              phcpValue = adjustLimit;
            }
          } else if (playerGender === 'F' && criteria.hcpWomen === 'Adjust Playing') {
            const adjustLimit = parseFloat(criteria.hcpWomenValue);
            if (!isNaN(adjustLimit) && phcpValue !== null && phcpValue > adjustLimit) {
              phcpValue = adjustLimit;
            }
          }
          
          playerWithTee.phcp = phcpValue;
          
          // Add to the top of the list
          admittedPlayers.unshift(playerWithTee);
          saveAdmittedPlayers(admittedPlayers);
          renderTables();
        }
      }
      
      // Helper function to check if player matches category criteria
      function playerMatchesCategory(player, category) {
        // Check handicap
        if (category.handicapMin !== undefined && category.handicapMin !== null && category.handicapMin !== '') {
          if (player.hcp === undefined || player.hcp === null || parseFloat(player.hcp) < parseFloat(category.handicapMin)) return false;
        }
        if (category.handicapMax !== undefined && category.handicapMax !== null && category.handicapMax !== '') {
          if (player.hcp === undefined || player.hcp === null || parseFloat(player.hcp) > parseFloat(category.handicapMax)) return false;
        }
        
        // Check age
        if (category.ageMin !== undefined && category.ageMin !== null && category.ageMin !== '') {
          const age = calculateAge(player.dob);
          if (age === null || age < parseInt(category.ageMin)) return false;
        }
        if (category.ageMax !== undefined && category.ageMax !== null && category.ageMax !== '') {
          const age = calculateAge(player.dob);
          if (age === null || age > parseInt(category.ageMax)) return false;
        }
        
        return true;
      }

      // Remove player
      function removePlayer(reg) {
        admittedPlayers = admittedPlayers.filter(p => p.reg !== reg);
        saveAdmittedPlayers(admittedPlayers);
        renderTables();
      }

      // ========== Criteria Panel Toggle ==========
      function toggleCriteriaPanel() {
        var content = document.getElementById('criteria-content');
        var icon = document.getElementById('criteria-toggle-icon');
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          icon.classList.remove('expanded');
        } else {
          content.classList.add('expanded');
          icon.classList.add('expanded');
        }
      }

      // ========== TGF Import Functions ==========
      var tgfParsedPlayers = [];
      var tgfSelectedIndex = -1;

      function toggleTgfPanel() {
        var content = document.getElementById('tgf-content');
        var icon = document.getElementById('tgf-toggle-icon');
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          icon.textContent = '‚ñº';
        } else {
          content.classList.add('expanded');
          icon.textContent = '‚ñ≤';
        }
      }

      function openTGFSearch() {
        var searchName = document.getElementById('tgf-search-name').value.trim();
        
        // Open TGF page FIRST (before any alerts) to avoid popup blocking
        var baseUrl = 'https://scoring-tr.datagolf.pt/scripts/handicaps.asp?club=ALL&ack=6V35FTY88T&fedstatus=9';
        var tgfWindow = window.open(baseUrl, '_blank');
        
        if (!searchName) {
          alert('TGF page opened.\n\nEnter a player name in the "ƒ∞sim:" field and click "ARA" to search.');
          return;
        }
        
        // Show instructions after opening the window
        setTimeout(function() {
          alert('TGF page opened in a new tab.\n\n' +
                '1. On that page, type "' + searchName + '" in the "ƒ∞sim:" (Name) field\n' +
                '2. Click "ARA" (Search) button\n' +
                '3. Select and copy the player row(s) you want\n' +
                '4. Come back here and paste in the text area');
        }, 100);
      }

      function parseTgfData() {
        var text = document.getElementById('tgf-paste-area').value.trim();
        if (!text) {
          alert('Please paste the table data first.');
          return;
        }

        tgfParsedPlayers = [];
        tgfSelectedIndex = -1;
        var lines = text.split('\n');

        for (var i = 0; i < lines.length; i++) {
          var line = lines[i].trim();
          if (!line) continue;

          // Try to parse as table row
          var parts = line.split('\t');
          if (parts.length < 5) {
            parts = line.split('|').map(function(p) { return p.trim(); });
          }
          if (parts.length < 5) continue;

          // Skip header rows
          if (parts[0] === 'Feder.No.' || parts[0] === '---' || parts[1] === 'ƒ∞sim') continue;

          var fedNo = parts[0] ? parts[0].trim() : '';
          var fullName = parts[1] ? parts[1].trim() : '';
          var club = parts[2] ? parts[2].trim() : '';
          var hcp = parts[3] ? parts[3].trim() : '';
          var gender = parts[5] ? parts[5].trim() : '';
          var category = parts[6] ? parts[6].trim() : '';
          var birthDate = parts[9] ? parts[9].trim() : '';

          // Validate: must have at least fed number and name
          if (!fedNo || !fullName || isNaN(parseInt(fedNo))) continue;

          // Parse name into first/last
          var nameParts = fullName.split(' ');
          var firstName = nameParts[0] || '';
          var lastName = nameParts.slice(1).join(' ') || '';

          // Parse club - remove code prefix if present
          var clubName = club;
          var clubMatch = club.match(/^\d+-(.+)$/);
          if (clubMatch) {
            clubName = clubMatch[1];
          }

          // Parse handicap
          var handicap = parseFloat(hcp) || null;

          // Check if already exists in players list
          var exists = allPlayers.some(function(p) {
            var regWithP = 'P' + fedNo;
            return p.federationNumber === fedNo || p.reg === fedNo || p.reg === regWithP;
          });

          // Check if already admitted
          var alreadyAdmitted = admittedPlayers.some(function(p) {
            var regWithP = 'P' + fedNo;
            return p.federationNumber === fedNo || p.reg === fedNo || p.reg === regWithP;
          });

          tgfParsedPlayers.push({
            federationNumber: fedNo,
            firstName: firstName,
            lastName: lastName,
            fullName: fullName,
            club: clubName,
            handicap: handicap,
            gender: gender,
            category: category,
            birthDate: birthDate,
            country: 'TUR',
            exists: exists,
            alreadyAdmitted: alreadyAdmitted
          });
        }

        if (tgfParsedPlayers.length === 0) {
          alert('Could not parse any player data. Make sure you copied the table correctly.');
          return;
        }

        renderTgfResults();
      }

      function renderTgfResults() {
        var resultsDiv = document.getElementById('tgf-results');
        var tbody = document.getElementById('tgf-results-body');
        var html = '';

        for (var i = 0; i < tgfParsedPlayers.length; i++) {
          var p = tgfParsedPlayers[i];
          var rowClass = i === tgfSelectedIndex ? 'tgf-selected' : '';
          var statusText = '';
          var btnHtml = '';

          if (p.alreadyAdmitted) {
            statusText = '<span style="color:#dc3545;font-size:12px;">Already admitted</span>';
            btnHtml = '';
          } else if (p.exists) {
            statusText = '<span style="color:#28a745;font-size:12px;">In players</span>';
            btnHtml = '<button class="tgf-btn tgf-btn-success" style="padding:4px 8px;font-size:11px" onclick="admitTgfPlayer(' + i + ')">Admit</button>';
          } else {
            btnHtml = '<button class="tgf-btn tgf-btn-primary" style="padding:4px 8px;font-size:11px" onclick="importAndAdmitTgfPlayer(' + i + ')">Import & Admit</button>';
          }

          html += '<tr class="' + rowClass + '" data-idx="' + i + '">';
          html += '<td>' + p.federationNumber + '</td>';
          html += '<td><strong>' + p.firstName + '</strong> ' + p.lastName + '</td>';
          html += '<td>' + p.club + '</td>';
          html += '<td>' + (p.handicap !== null ? p.handicap.toFixed(1) : '-') + '</td>';
          html += '<td>' + p.gender + '</td>';
          html += '<td>' + (p.birthDate || '-') + '</td>';
          html += '<td>' + statusText + btnHtml + '</td>';
          html += '</tr>';
        }

        tbody.innerHTML = html || '<tr><td colspan="7" style="text-align:center;padding:20px;color:#64748b;">No players found</td></tr>';
        resultsDiv.style.display = 'block';
      }

      function importAndAdmitTgfPlayer(idx) {
        var p = tgfParsedPlayers[idx];
        if (!p) return;

        // First, import the player to the players list
        var players = getPlayers();
        
        // Check if already exists
        var existingIdx = -1;
        for (var i = 0; i < players.length; i++) {
          var regWithP = 'P' + p.federationNumber;
          if (players[i].federationNumber === p.federationNumber || 
              players[i].reg === p.federationNumber ||
              players[i].reg === regWithP) {
            existingIdx = i;
            break;
          }
        }

        var regNo = 'P' + p.federationNumber;
        var genderValue = p.gender;
        if (p.gender === 'M') genderValue = 'male';
        else if (p.gender === 'F') genderValue = 'female';

        var playerData = {
          id: regNo,
          reg: regNo,
          federationNumber: p.federationNumber,
          firstName: p.firstName,
          lastName: p.lastName,
          club: p.club,
          homeClub: p.club,
          hcp: p.handicap,
          handicap: p.handicap,
          gender: genderValue,
          category: p.category,
          dob: p.birthDate,
          country: 'TUR',
          owner: 'main'
        };

        if (existingIdx >= 0) {
          players[existingIdx] = Object.assign(players[existingIdx], playerData);
        } else {
          players.push(playerData);
        }

        // Save to localStorage and Firebase
        try {
          localStorage.setItem('players', JSON.stringify(players));
          if (typeof syncToFirebase !== 'undefined') {
            syncToFirebase('players', players);
          }
        } catch(e) {
          alert('Error saving player: ' + e.message);
          return;
        }

        // Update allPlayers array
        allPlayers = players;

        // Now admit the player
        admitTgfPlayer(idx, playerData);
      }

      function admitTgfPlayer(idx, playerDataOverride) {
        var p = tgfParsedPlayers[idx];
        if (!p) return;

        // Find the player in allPlayers
        var regNo = 'P' + p.federationNumber;
        var player = playerDataOverride || allPlayers.find(function(pl) {
          return pl.reg === regNo || pl.federationNumber === p.federationNumber;
        });

        if (!player) {
          alert('Player not found in players list. Please import first.');
          return;
        }

        // Use the admitPlayer function
        admitPlayer(player);

        // Update the TGF results
        p.exists = true;
        p.alreadyAdmitted = true;
        renderTgfResults();

        // Clear search and re-render main tables
        document.getElementById('player-search').value = '';
        filteredPlayers = [];
        highlightedIndex = -1;
        renderTables();
      }

      function clearTgfData() {
        document.getElementById('tgf-paste-area').value = '';
        document.getElementById('tgf-results').style.display = 'none';
        document.getElementById('tgf-results-body').innerHTML = '';
        tgfParsedPlayers = [];
        tgfSelectedIndex = -1;
      }
      // ========== End TGF Import Functions ==========

      // Load data from Firebase before initializing
      async function loadFromFirebase() {
        // Wait for Firebase to be ready
        let attempts = 0;
        while (!syncEnabled && attempts < 10) {
          await new Promise(resolve => setTimeout(resolve, 200));
          attempts++;
        }
        
        if (syncEnabled) {
          try {
            // Load tournaments
            if (typeof loadTournamentsFromFirebase !== 'undefined') {
              await loadTournamentsFromFirebase();
            }
            // Load players
            if (typeof loadPlayersFromFirebase !== 'undefined') {
              await loadPlayersFromFirebase();
            }
            // Load admitted players
            const admittedData = await syncFromFirebase('admittedPlayers');
            if (admittedData) {
              localStorage.setItem('admittedPlayers', JSON.stringify(admittedData));
            }
            console.log('‚úì Data loaded from Firebase');
          } catch(e) {
            console.log('Firebase load error:', e);
          }
        }
      }

      // Initialize on page load
      loadFromFirebase().then(() => init());
    </script>
  </body>
</html>
